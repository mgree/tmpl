theoretical and empirical studies on using program mutation to test the functional correctness of programs a richard j yale richard a berkeley and tech g yale introduction in testing for program correctness approaches have finding data d a finite subset of all inputs to p such that the standard on possible if for all x in d px then p f fx where f is a partial recursive function that specifies the intended behavior of the program and p is the function actually computed by program p a major block in such formalization has been that the conclusion of is so strong that except for trivial classes of programs is bound to be formally undecidable l there is an among to consider program testing an ad hoc human technique one creates test data that intuitively seems to capture some aspect of the program the program in execution on it and then conclusions on the programs correctness based on the observations to augment this strategy techniques have been proposed that yield quantitative information on the degree to which a program has been tested see for a recent survey thus the is given an inductive basis for that holds for the particular application the undecidability of deductive testing methods the inductive methods all have had trivial examples of failure these deductive and inductive approaches have had a common all have at the strong conclusion of program mutation the other hand is a testing technique that aims a weaker yet quite realistic conclusion of the following nature on at if for all x in d px fx then e f or p is to f work or fee are the to prior a is by permission of machinery to copy otherwise or to republish requires a fee and or specific permission acm if p is not and px fx for all then p f x in d below we will make precise what is meant by p is for now it suffices to say that p not means that p was written by a programmer who had a good understanding of the task to be performed therefore if p does not realize f it is close to doing so this underlying hypothesis of program mutation has become known as the programmer hypothesis either p f or some program q close to p has the property q f to be more testing method of correctness specific program mutation that proposes the following testing is a version given that find test p f p was by a data d for which pd fd programmer implies our method of developing d assuming either p or some program close to p is correct is by eliminating the alternatives let be the set of programs close to p we the method as follows find test data d such that i for all x in d px fx and ii for all q in either q p or for some x in d qx px if test i and from data d can ii then alternatively be developed we say that p passes having properties d p the test the goal theoretical questions of this paper and experimental is to study from both two basic question if p is written programmer and if p test data d does p f by a the test with note that after formally defining for p in a fixed programming language l an answer to question reduces to showing that the programmer hypothesis holds for this l and we have observed that under many natural definitions of there is often a strong this work was supported in part by grant from and and by grant from between members of and a small subset v that is often one can reduce the problem of finding test data that p from to that of finding test data that p from u we will call this subset p the of p and the second question we will study involves the socalled effect question effect test with data d does test with data d if p passes p pass the the u intuitively programs one can think of p as representing that are very close to p the in the next section we will present two types of theoretical results concerning the two questions above general results expressed in terms of properties of the language class l and specific results for a class of decision table programs and for a subset of lisp portions of the work on decision tables and lisp have appeared elsewhere but the given here are both simpler and more unified in the final section we present a system for applying program mutation to fortran and we introduce a new type of software experiment called a the system experiment for evaluating how well our system approximates an response to the program mutation questions theoretical studies our major interest in studying program mutation from a theoretical viewpoint is to gain insight on where and how to apply the method to real programming languages there are two possible study approaches i for fixed l define the of p in terms of syntactic and semantic transformation rules that alter ps syntax and interpretation in a way that formally captures the notion of that is reflect the errors a could have made in producing p here is a subset of l ii simply let l for these initial studies we choose approach questions ii in order to investigate in terms of properties of l we have the following the simpler the immediately theorem if there is an automatic method to generate data d that satisfies the mutation test for p then the equivalence of p and any program in must be decidable q the proof is trivial since we used the equivalence property in defining what is meant by data that the mutation test furthermore if we have such data then to decide equivalence we merely execute the two programs if the results agree they are equivalent if not they obviously not equivalent at first the result of this theorem appears to cast serious on our ability to derive any interesting positive results since the equivalence interesting problem is undecidable for most language classes as will be seen in the sequel however the implication is that we must carefully very choose properties the set to capture some of being close to the original program p for the remainder consider two specific of this section we will examples of program types decision tables a decision table is a highly structured way of describing are decision alternatives such tables used in and data processing applications used to test although they data selection can also be predicates to form a decision table we have a set of conditions a set of actions and a table composed of two parts entries in the upper part are from the set yes no dont care denoted y n and entries in the lower table are either dont do denoted x and o each column do or in the matrix is called a rule an example is shown in figure condition condition condition condition action action action figure a typical ny decision table to execute the program on some input the conditions are first simultaneously evaluated forming a vector of entries this vector is then compared to every rule if the vector matches any rule the indicated actions are performed if for each possible data item there is at least one rule that can be satisfied we say the decision table is complete we say it is consistent if there is at most one rule we will assume that the program under test is consistent we can also assume it is complete since an incomplete decision table can always be turned into a complete one by adding further actions that merely return an error flag and further that are satisfied by the previously inputs we will also assume that no two rules specify exactly the same set of actions we can do this with little loss of generality since two such rules can be combined with at most the addition one new condition of given a decision table program p let be the set of all consistent programs having the same conditions and actions as p this means that members of differ from p only in the table portions or the number of rules they contain the p of p will be those members of that are formed by taking a single entry and changing it first into a y and then into an n entry if p is consistent then all the will be consistent some of these may be equivalent to p the that changes position j in rule i from a to a y can be equivalent to p only if it is impossible for any input to satisfy rule i and not satisfy this condition there are at most two for every table entry in p this means there each requires are no more than nm at most a single test case to it from p therefore even though there are potentially n different inputs an adequate mutation set need have only at most nm inputs we will all of make the following assumptions apply to the program p is both consistent and complete given an example of inputoutput behavior we can determine which rule was applied to produce the output from the input in particular this implies that no two rules specify exactly the same set of actions there exists at least one input that satisfies each rule we can decide the equivalence of p and any member of we will investigate the power of a set of inputs that p from p in particular we will show that this set in fact p from assume we have such a set d we will assume that every rule in p is at least once by some member of d adding points if necessary to meet this condition we can initially fail to meet this condition only if there are some rules that do not contain s we will note without further comment that we could have guaranteed this condition with if we also the action matrix as was done in the original paper it now seems that to do so causes an unnecessary increase in the complexity of the proof for such a small matter given any q in if for each x in d px qx then we will say q tests equal to p since each rule in p has a unique set of actions by a simple counting argument we know that if q tests equal to p then for each rule in p there is a corresponding rule in q with exactly the same actions using this fact we can show the following theorem if d p from p and equal to p then for each rule in p the set inputs satisfying the corresponding rule in strictly larger than that of p q tests of q is proof first to have rule this were so could satisfy note that it a y entry in in q to have no data that the rule in is not possible p and for the an n or vice satisfied the q for a versa if rule in p now consider each entry in p there are two cases if the change that replaces this by a y the same argument holds for n is equivalent this means the conjunction of the other conditions implies a yes in this position in this case it doesnt matter whether q has a y or a and these are the only two possibilities ­ this change cannot contribute to decreasing the size of the set of inputs accepted by q on the other hand if this change is not equivalent d contains points that while satisfying the rule particular both satisfy condition and fail to satisfy this both these must be by the same rule in q therefore q must also have a in this position the only remaining possibility is that some rule in p has a y or n and the corresponding position in q has a this strictly increases the size of the set of inputs accepted by this rule giving our result o if d p from p from u then d proof let pi be the set of inputs accepted by rule i in p since p is consistent the p are disjoint since p is complete they cover the entire space of inputs each rule in q must accept at least the set accepted by the corresponding rule in p since q is consistent it can satisfy no more o recall that theorem stated that we could form an adequate mutation set only if we could decide equivalence of p and each of its obviously there are some cases where this is for example when all the conditions are independent and therefore none of the are equivalent we can easily find examples where this is not true this is the case whenever we have two conditions where the question of whether the first condition implies the second is undecidable figure condition condition example where undecidable y equivalence is we can replace the in the condition row with y if and only if condition always implies condition in this fashion using almost any classic question we can construct a program with the property that the equivalence question for it and one of its is undecidable a the most restrictive assumption made in proving theorem seems to be that each rule must have a distinct set of actions to show that this restriction cannot be eliminated consider the two decision tables shown in figure the two programs are not equivalent they process the input differently yet they agree on a set of test inputs which is sufficient to eliminate all the of program figure program a case not y covered by the mutation test we do not know whether the restriction having distinct actions can be replaced weaker assumption or whether there is method that can be used to demonstrate in this case other than trying all n possibilities to rules with a any test correctness lisp programs in this section we will consider programs written in the subset of lisp containing the functions car cdr and cons and the predicate atom a similar class of programs has been studied previously we will make the convention that we will use the less points have unique atoms two programs agree on all such points all certainly if they must agree on all of generality inputs hence we do this without loss we will call a lisp program a selector program if it is composed of just car and cdr we will inductively define a program as a selector program or a program formed by the cons of two other programs programs we first note that program is very weak the power of a selector theorem if two selector identical values on any both defined they must on all points programs return input for which they are compute identical values proof the only power of a selector program is to choose a subtree out of its input and return it we can view this process as selecting a position in the complete tree and returning the subtree rooted at that position since there is a unique path from the root to this position there is a unique predicate that selects it since atoms are unique by merely observing the output we can infer the subtree that was selected d we will say that a program px is well formed if for every occurrence of the construction it is the case that a and do not share an immediate parent in x the intuitive idea of the definition should be clear a is well formed if more work than it needs to well formed is an observable it is not doing any notice that being property of programs independent of testing b we can define a measure of the complexity programs by their is defined as follows of where the the of a selector program is zero of a program px is l x p theorem if two compute both defined then well on they formed selector programs any point for which they must have the same are proof assume we have two programs p and p and a point x such that px that there is at least one subtree yet the this implies in the structure of p that was produced by two straight line programs while the same subtree in produced by a selector but then the objects must have an immediate ancestor in x was p the fact that p is well formed d theorem if programs agree both defined two well formed on any point x for which they are then they must agree on all points proof the proof will be by induction on the by theorem any two programs that agree on x must have the same by theorem the theorem is true for programs of zero hence we will assume it is true for programs of n and show the case for nl if program pl has nl then it must be of the form where and p have no greater than n assume we have two programs p and p in this fashion then for all y py py py iff and py iff hence by the induction must agree for all y hypothesis o p and p we can easily generalize theorem to the case where we have multiple inputs recall that each atom is unique therefore given a vector of arguments we can form them into a list and the result will be a single point with unique atoms similarly a program with multiple arguments can be replaced by a program with a single argument by assuming the inputs are in the form of a list and replacing each occurrence of an argument name with a selector function accessing the appropriate position in this list using this construction one can verify that if theorem did not hold in the case of multiple arguments one could construct two programs with single arguments for which it did not hold giving a contradiction to summarize this section for program any unique for which the function is defined the program from all formed programs any well formed atomic point is adequate to other well recursive programs the type of programs section can be described we will study as follows in this the input to the program will consist of selector variables denoted xl xm and constructor variables denoted y a program will consist of a program body and a a program body consists of n statements each composed of a predicate of the form where t is a selector function and xl a selector variable and a output function over the selector and constructor variables a is divided into two parts the constructor part is composed of p assignment statements for each of the p constructor variables where yl is assigned a function over the selector variables and yi the selector part is composed of m assignment statements for the m selector variables where xi is assigned a selector function of itself the example in figure should give a more intuitive picture of this class of programs given such a program execution proceeds as follows each predicate is evaluated in turn if any predicate is undefined so is the result of the execution otherwise if any predicate is true the result of execution is the associated output function otherwise if no predicate evaluates true then the assignment statements in the and constructor are performed and execution continues with these new values we will make the following programs we will consider the program if then r else if else if then yl then else y rj xm xl nl xi nm t figure an example program all the recursion selector and recursion constructor functions must be nontrivial every selector variable must be tested by at least one predicate there is at least one output function that is not a constant freedom for each and l there exists at least one input that causes the program to i times before with output function k let be the set of all programs with the same number of selector and constructor variables as p the same number of predicates and output functions no deeper than some fixed limit our goal is to construct a set of test cases d that p from all members of the set of u will be described in the course of the proof as they enter into the arguments the proof will proceed in several smaller steps in subsection we give some basic definitions and demonstrate some tools that we will use in later sections subsection shows how to use testing to bound the depth of the selector functions in subsection we narrow the form of the selector functions still further and finally in subsection show that they must exactly match p in subsection we deal with the points tested by the predicates and in subsection we give the main theorem subsection concludes with some comments on the difficulty of proving a program correct in this manner and ways in which the results here could be definitions and tools we will use letters from the end alphabet xr y and z to represent vectors inputs hence we will refer to px rather y similarly we will abbreviate the simultaneous application of constructor functions by cx and recursion selectors by rx of the of than we will use letters from the start of the alphabet to represent positions in a variable where a position is defined by a finite path from the root when no confusion can arise we will frequently refer to position a in x we mean position a in some xi or yi in x we will sometimes refer to position b relative to position a by which we mean to follow the path to a and starting b from that point follow the path to the depth of a position will be the number of or necessary to reach the position starting from the root similarly the depth of a function will be the position it references relative to its inputs let w be the maximum depth of any of the selector constructor or output functions in p the size of an input x will be the maximum depth of any of the atoms in x we can extend the definition of s to of inputs by saying xy if and only if selector variables in x are smaller than respective variables in y and similarly constructor variables the space all the their the we will say y is x at position a if y is the largest input less than or equal to x in which a is atomic this process can be viewed as simply taking the subtree in x rooted at a and replacing it by a unique atom if a position relative is tested by some predicate position in question has positions by the going into recursion the to the original input we will say that the been call the predicates of p without primary positions of p n the assumption of freedom asserts existence of inputs x that will cause a specific number of times a specific output function our first shows that this can be made constructive only the the program and exit by theorem theorem given l o and s in an input x so that px is defined x as an input p k times output function i we can construct and when given before by proof consider mp infinite trees corresponding to the mp input variables mark in blue every position that is by a predicate function and found to be nonatomic in order for p to l times and reach the predicate i then mark in red the point by predicate i after f times the assumption of freedom implies that vertex can appear in the infinite subtree at the red vertex and that the red vertex also be marked blue no blue rooted cannot now mark in all points that are used by constructor functions in l times and each position used by output function i after t times the assumption of freedom again tells us that no vertex can appear in the infinite subtree rooted at the red vertex the red vertex may however also be colored as may the blue vertices it is a simple input x so that matter then to construct an all blue vertices are interior to x nonatomic the red vertex is atomic and all vertices are contained in x they may be atomic notice that the procedure given in the proof of theorem allows one to find the smallest x such that the indicated conditions hold if a is the position in question call this point the minimal a point defined freedom hence concept implies that no point the minimal a point is can be twice a well given an input x such that px be the function px note that by theorem by this single point is defined let such that fx is defined theorem for any x for which px is defined we can construct an input y with the properties that py is defined yx and proof input output variable let t and l x p function i xj be the constants k times before let the predicate such pi that by test on there are two cases assume f is not a constant function now it is possible that the position that would be tested by pi after ql times s an position in x but since x s bounded there must be a smallest k l such that the predicate is either true or undefined using theorem we can find an input z that causes p to k times before by output function i let y be the union of x and z since yz p must at least as much on y as it did on z since the final point tested is still atomic py will k times before by output function i since z we have that the second case arises when fi is a constant function by assumption there is at least one output function that s not a constant function let fi be this function let the predicate pi test variable xj the same argument as before goes through with the exception that it may happen by that py px ie py returns the constant value in this case increment k by and perform the same process and it cannot happen again that py px n theorem if p a location a then we can construct two inputs x and y with the properties that px and py are defined then for any q in if px qx and py then q must touch a proof let z be the minimal a point theorem we can construct an input px is defined x z and at a using x such that let y be x we first assert that py is defined and to see this note that every point that was tested by p in pz and found to be nonatomic is also nonatomic in y position a is atomic in both and if the output function was defined on z then it must be defined on y which is strictly larger suppose given input y a program q l times before by output function i but does not touch position a since x is strictly larger than y on x q must at least as much and at least reach predicate i let the position in y that was by predicate i and found to be atomic be b since position b is not the same as position a position b is also atomic in x therefore given input x q will l times and exit by output function i but this implies by theorem that a contradiction d bounding predicate the depth functions of the and our first set given in theorem n primary positions of test inputs uses the procedure to demonstrate that each of the in p are indeed next for each selector variable use the procedure given in theorem to show that the first nl positions by depth must be let d be the maximum size of these positions we will assume d is at least and larger than both w and s theorem processes selectors if q is a program in that correctly these points then the recursion of q have depth d or less proof study each selector variable separately at least one of the nl points in that variable must have been after q had at least once if the recursion selector had depth greater than d the program could not possibly have the point in question h theorem associated greater if q c correctly points then none of with the predicates than d processes the selector can have these programs a depth proof at least one of the inputs causes q to at least once hence all the predicates must have evaluated false and therefore were defined if any of the predicates did have a depth greater than d they would have been undefined on this input o since we also know that on the output functions of q d is a bound we are now in a position to make a comment concerning the size of the points computed by the procedure given in theorem let l be the maximum depth of the relative root the current variable position relative to the original variable tree at the time position a s we know the minimal a tree is no larger than lw this being the case to find an atomic or undefined point as in the procedure associated with theorem we at worst have to to a position lw deep but no more than deep hence neither of the two points constructed m theorem need be any larger than this fact be of use in proving theorem narrowing selectors the form of the recursion we will say a selector function f factors a selector function g if g is equivalent to f composed with itself some number of times for example factors we will say that f is a simple factor of g if f factors g and no function factors f other than f itself let us denote by si factors of the recursion m the functions that is for each variable i there is a constant ii so that the recursion selector r is si composed with itself ki times let q be the greatest recursion common of all the is selectors of p can be written hence the as sq for some recursion selector s we now construct a second set of data points in the following fashion for each selector variable let a be the first position with depth greater than d in xl using theorem two points that demonstrate that position be let do be the set containing m points computed so far generate a must all the theorem if q computes correctly on do then recursion selector i of q must be a power of si proof assume the recursion selector of x i in q is not a power of si recall that the depth of the selector cannot be any greater than d once it has past the depth d it will be in a totally different subtree from the path taken by the recursion selector of p since d it is required that q touch that has depth at least d q must therefore touch this point prior to to the d by theorem this is impossible o a point depth we can result in fact prove a slightly stronger theorem if q computes correctly there exists a constant r such that selectors of q are exactly sr on do then the recursion proof we know by theorem that the recursion selectors of q must be of si for each selector construct the ratio of the power of si in q to that in p theorem is equivalent to saying that all these are the same assume they are different and let xi be the variable with the ratio and xj the variable with the largest let x and y be the two inputs that demonstrate that a position a of depth greater than d in xi is both p and q must at least d times on these inputs in comparison to what p is doing xj is at least one level every time q by the time xi is within touch a xj will have d levels range to too far since xj will have run off the end of its input hence q cannot have received the correct answer on x and y d theorem gave us a method to demonstrate a position is we now give the opposite way to demonstrate a position is not a theorem if q computes correctly on all test points so far constructed then for any position a not by p we can construct inputs x and y so that if px qx and py then q does not touch a the two proof let position a be in variable xi let the smallest number such that after times the recursion selector i is deeper than let l be the maximum depth of any recursion selectors at this point let x be the complete tree of depth ld at a m be m a there are two cases if px is not defined assume q a the relative roots of q cannot be deeper than ld at the time when a is hence the minimal a point is no deeper than ld since x is strictly larger than the minimal a point we know that qx must be defined which contradicts the fact that qx px the second case arises if px is defined using theorem we construct an input zx such that let y be z at a assume q a since yx must be defined so assume py is defined by construction but since q is a contradiction o a which recursion selectors must be the same as p if qe executes correctly on then from theorem we know the recursion must be s for some constant r selectors of q from theorem we know the depth of s is no larger than d hence there are at most of s choices for each possible r not equal to q construct a program p which is equal to p in all respects but the selectors which are sr in this section we will consider test cases as pairs of inputs generated using the procedure given in theorem which return either the value yes saying they were generated by the same program or the value no saying they other than this we will not be concerned with the output of the if each a point that p does not then construct two points using theorem to demonstrate this if any only points that p itself then we will say p cannot be shown correct by this testing method call this set of test cases d theorem if qe executes correctly dl then the recursion selectors of exactly sq on do and q must be proof assume not and that the recursion selectors are sr for some constant r q no matter what the primary positions of q are we know it must touch at some point the primary positions of p it therefore must always touch the primary positions of p relative to the position it has to but therefore it must at least touch the points that the associated with r does u testing the primary positions of p consider each primary position separately assume that in some program q in the position is not primary but that it is after having e times let b be the position of a relative to sql this means in q that b is primary now b cannot even be let alone be primary in p because of the assumption of freedom using the procedure given in theorem construct two points that demonstrate that b is not which demonstrates that a must be primary taken together these test points that the primary positions of p must be primary in all other programs notice carefully that we need to make no other assumptions about the other primary positions in q we can treat each of them independently we therefore have at most of sq programs hence at most twice this number of test points call this test set d theorem and d then those of p if qe executes correctly the primary positions of on do dl q are exactly notice that the following by theorem this also gives us theorem the output those of p functions of q are exactly main theorem once we have the other elements fixed the constructors are almost given to us remember one of the assumptions made in the beginning was that each of the constructor variables appears in its in at least one of the output functions all we need do is to construct p data points so that data point i causes the program p to once and exit using an output function that contains the constructor variable i call this set d using theorem we then have theorem the recursion be exactly those of p constructors of q must the only remaining source of variation is the order in which the primary positions are tested the only solution we have been able to find here short of making more restrictions on is to try all possibilities there are n of these some of which may be equivalent to the original program let d be a set of data points that p from all of this set putting theorem all of this together gives us our main theorem given a program p in executes correctly on the test points in theorems and then equivalent to p if qe constructed q must be corollary either p is correct the intended function or no program in corollary if the holds then p is correct programmer hypothesis discussion we note that studied here is of the examples be expressed in although the class of programs small it is not several studied previously can our form we point out that even with the assumed bound on the depth of the output functions we did not bound the number of cons functions they can contain hence there are an infinite number of programs in the set this is true even after we have bounded the depth of the recursion selectors and the predicate selectors in theorem the most important aspect of this result is not the proof which in fact has rather limited applicability we have fixed but the method of the proof once the recursion selectors via test set do the remainder of the arguments can be proved by constructing a small set of alternative programs the and showing that test data designed to distinguish these from the original actually will distinguish p from a much larger class of programs in all we constructed of s of sq pn and we proved that test data that distinguished p from this set of actually distinguished p from the infinite set of programs in we note that although the proof of the result given here is rather long and tedious the result is a procedure for proving correctness that is entirely mechanical the user of such a procedure need have no knowledge of the proof that was used to validate the method much as the user of a system need have no knowledge of how the operating system is implemented this is the direction we feel research in testing should follow finding mechanical methods that may be difficult to verify but that once verified give an easy procedure for finding good test data empirical studies a program mutation system has been implemented to test programs in building real real programming languages be considered are called fortran testing tools for the issues that must what is the cost of performing what is from performing the test the test note that these two issues should somewhat as time and space off in algorithms but in addressing the first the system must at least be tractable off issue given a fortran program p having n statements one could construct a set u having size exponential in n each being a reasonable alternative to p what is done in however is to define p via a set of operators that upon analysis result in us having size bounded roughly by the product of the of data references constants scalar variables and array references times the number of unique data references operators are very simple syntactic and semantic program transformation rules that act on p in only a local way for example one operator changes a single occurrence of a binary operator in p to a syntactically legal alternative operator in forming a identical to p in all but one symbol another operator changes the semantics of a single do loop to be interpreted as a for loop here the is syntactically identical to p but unlike p precisely one of the k loop bodies might never be executed in of the controlling do statement being executed a description of the exact nature of the other operators has already been published although the complexity of the mutation system is now reasonable one should question the effectiveness of applying program mutation with only simple alternatives since the remaining more complicated but reasonable alternatives are the effect mentioned in section indirectly addresses the more complicated alternatives of p test data that causes all simple of p to fail is so sensitive that it implicitly causes all complex combinations of them to fail we will illustrate a representative case of in a fortran program the program is adapted from the ibm scientific subroutines package a collection of statistical and scientific programs in fairly common use the error was inserted in a study by and the error occurs in the line that reads but should read subroutine nv no s integer real temp integer j ij real integer i real real integer no nv real a do o ij no do jl no continue do do ij no do jl no temp do temp temp temp continue temp goto continue do goto do return end there are a number error consider for the statement of that discover this example the one that changes if temp to if control reaches this point only if is than temp so control always passes to l by tracing the flow of control we can discover that temp is equal to the value of the input parameter at this point to eliminate this then we must find a value where is less than one but larger than therefore must be less than one there is nothing in the specifications that rules out s being less than one but the error causes to be assigned to the integer variable all the feasible paths that go through the statement also go through label which references since is less than or equal to zero this is out of bounds and the error is discovered we shall not directly address the effect further here evidence for it has been previously reported in many sources but instead will report on experiments evaluating issue above at the system involves evaluation examining of any program testing the following question are there test incorrect programs that pass the systems since as was argued above the be yes for any system that tests more interesting question is answer will always real programs a what types of errors are always detected by the system and what error types might be at present accepted these questions can only be studied because of the lack of any widely formal models of programming errors the ideal experiment for evaluating a program mutation system would be the classic experiment the has n with varying levels of programming and testing and m programs that have zero or more errors known only by the and each subject reports on the errors detected in trying to pass the test classical statistical techniques are then used to evaluate the results unfortunately the high cost of performing such controlled experiments makes them we have however designed and performed a experiment which we claim gives significant results in evaluating the mutation system we call such an experiment a the system experiment the single subject is having a very high level of programming and much with the concepts of programming mutation in general and the fortran mutation system in particular the m programs now one or more errors and furthermore the subject now has complete knowledge of what the errors are the subject tries to the mutation system to pass the mutation test with an incorrect program by developing test data on which the program is correct but on which all of the program fail if there are error types for which the highly subject cannot the system then we have high that these error types would be detected by any user of the system on the other hand if there are error types for which the subject can consistently the system then more investigation of operators is needed the system might be weak in detecting those error types the the system experiment is an example of worstcase analysis in that we attempt to find out how the system will perform under the worst possible we note that the the system experiment is an extension of the reliability studies done previously these earlier studies however were directed at comparing two or more and deriving statistical information of the form on the following samples of programs method a discovered x of the errors and method y t in the the system experiments b discovered we are much less concerned with the number of errors and much more concerned with the type of errors furthermore this information is not used to compare two methods but is designed to evaluate the mutation analysis system and to direct the search for new operators that will improve the system for example several of the programs we studied in early experiments that a significant number of errors in fortran are caused by programmers treating the do statement as if it were an algol for statement that no matter what the limits are a do statement will always perhaps loop at least once the way we chose to detect these errors was to introduce a that changed a do statement into a for statement this fact to the programmers attention and forcing to derive data that indicated he had knowledge of this potential so far we have the system experiments on programs all of which have previously studied in the testing literature wish to express our to robert was the subject in most of these experiments the appendix contains the appropriate references and further details on the programs and their errors been we who it is difficult to construct a classification scheme for error types that is neither so specific that each error forms its own type nor so general that important patterns cannot be detected if the classification is based on logical then it is often hard to relate errors to in the code on the other hand it seems difficult to base a scheme just on in the since often a single logical will be responsible for changes in several locations in the program and and among others have to construct a generally applicable system neither of their systems to our gives a sufficiently intuitive picture of the errors in any particular class therefore we have chosen to group the errors in these programs into the following categories missing path errors these are errors where a whole sequence of computations that should be performed in special is omitted incorrect predicate errors these are errors that arise when all important paths are contained in the program but a predicate that determined which path to follow is incorrect incorrect that arise incorrect computation statement from a computation in some respect these statement are errors that is missing computation statement missing clause in predicate case of an incorrect predicate is so hard to detect we give this is a special error but since it special treatment it the errors in these programs range from simple to extremely subtle errors because of the worstcase nature of the experiment the fact that errors are not discovered does not mean that these errors would always remain if mutation analysis was used in a normal debugging situation we merely cannot guarantee their discovery table gives the number of errors detected by error type of these errors only would be using branch analysis missing incorrect incorrect missing missing path error predicate error computation statement computation statement clause in predicate figure number of errors detected number by error type one can notice that in three of these the errors are caused by the lack of certain constructs in the program since the testing method is being to guess at something that not in the program we should be that it does as well as indicated nonetheless missing path and missing clauses in predicates are probably the most difficult errors for any testing method to discover is the failure of the system to detect these errors is really not an of a in the method per se rather it reflects on our choice of operators it is quite possible that with another set of operators many of these errors would be we are looking for patterns in the types of errors in order to discover new operators that would aid in the detection of these errors remarks a framework for studying the program mutation testing method from both theoretical and empirical has been presented the initial results indicate that program testing when studied under assumptions in addition to the standard p is correct on test data d is a area for both theoretical and empirical research we remark that there is a very real tradeoff in the two types of research we have presented can prove theorems that allow perfect testing of programs for very limited languages languages that programmers would find rather but undecidability stands in the way of these to real programming languages given this we have empirical evidence that we implies that the type of results we would like prove do indeed hold in the real world both types of results are useful and important in understanding the nature of program testing to although our specific results have dealt solely with program testing we feel that the potential for developing other software that try to exploit some of the programming process as illustrated by our use of the programmer hypothesis should not be finally we feel that the type comparable to our the system example of experimental computer to many other testing of experiments approach are an science references a t r a t a r j and f g mutation analysis technical report institute of technology r s b and k n select a formal system for testing and debugging programs by symbolic execution sigplan notices june gordon h algorithm the greatest common of communications of the acm and bound n integers for july j r and m testing for software reliability proceedings of the international conference on reliable software ieee pages number ieee a and richard j mutation analysis of decision table programs proceedings of the conference on information sciences and systems pages the university a and richard j proving lisp programs using test data digest for the workshop on software testing and test pages a test data preparation mutation analysis of phd thesis yale university program in h y fault systems of digital richard selection computer a g help for richard j and on test data the programmer april k foster error sensitive test cases digest for the workshop on software testing and test documentation pages ­ m test program correctness acm data as an aid in communications may proving of the l and of in applications of modern programming transactions on software engineering september ieee se john b and s l towards a theory ieee transactions june of test data selection on software engineering se j a survey of program testing issues in p editor research directions in software technology pages mit press john d and paul an study of computer program debugging human factors may richard theory testing of reliability digest for the workshop on software and test documentation pages synthesis of lisp programs from examples proceedings of the fourth international joint conference on artificial pages held in p in structured and r programming an experiment bit c a r hoare proof of a program communications of the acm january find john e hopcroft and jeffrey d unman formal languages and their relation to automata addisonwesley william e methodology for the generation of program test data ieee transactions on computers c may william e an evaluation effectiveness of symbolic testing practice and experience of the software william e reliability of the path analysis testing strategy ieee transactions on software engineering ­ september j c an approach to program testing journal of the acm september international scientific application machines subroutine package program h system ibm h programming the case for structured bit r j and f g the status of research on program mutation digest for the workshop on software testing and test documentation pages m decision tables research associates p bit by action science l j and l d with a fortran program analyzer proceedings of the national computer conference pages s l h t and w j john decision tables and sons theory and practice d e w k and c c inferring lisp programs from examples proceedings of the fourth international joint conference on artificial pages held in philip examples phd thesis program construction yale from l j e i and b a domain strategy for computer program testing technical report state university n pl the computer a programming language for journal of the acm appendix this appendix describes the programs in the the system experiments studied the first program is written in an algol and initially appeared in a paper by and its is to read and process a string of characters that represent a sequence of where a is any string terminated by the keywords the program for words longer than a fixed limit and and each along with a count of the number of words it contains plus an of lhe presence or absence of words the program has also been studied in and and the program contains the following p which is intended to that characters are and that following the loop the variable letter contains a character while input do input if input letter and then input read the while loop terminates either on an empty string or on a character if it terminates on an empty string and the first character in the buffer loaded by the instruction is letter can contain a character when this program is translated into fortran and executed on the system the error is not necessarily the reason for this failure is not so much a failure of mutation testing as it is of algol treats strings as a basic type whereas in they are simulated by arrays of integers the fact that strings are basic to algol means that if we were constructing a mutation system for instead of fortran we would have to consider a different set of operators a natural operator one would consider can be explained by noting that play a role in string processing programs analogous to that by zero in numbers hence we might a push operator similar to the zero push operator in if we had such an operator an attempt to force the expression to would certainly reveal the error the second program appears in a paper by describing the language pl it is intended to take a vector of n numbers and sort them into decreasing order it was also studied by and as the outer loop is over the list of elements the inner loop is designed to find the maximum of the remain ing elements and set register r to the index of this maximum if the position set in the outer loop is indeed the maximum then r will have an incorrect value and the three assignment statements ending the loop will give erroneous results for rl o by to n begin ro for r rl by to n begin if ar ro then begin ro ar r r end end r ro ar r there are three that cannot be eliminated without discovering this error the first two change the statement ro ar into ro ar and ro the third changes the statement into ar ar we leave it as an exercise to verify that none of these can be eliminated without discovering the error the third program is written in fortran and computes the total average minimum maximum and standard for each variable in an observation matrix the program is adapted from the ibm scientific subroutines package it was analyzed and three artificial errors were inserted in a study by and as in the study by we considered only one of these errors it occurs in a loop that computes standard the program has the statement a pair of parentheses expression has been left off the final let x stand for the the correct standard is the only way this can be made zero is for x to be zero but the program containing the error computes the standard as if x is zero this is hence the standard is wrong or if the incorrect expression is forced to be zero then the correct standard should be greater than one hence by forcing the standard in this line to be zero the error is easily the program a year predicate fourth program appeared in an article by in the communications of the acm the contains a predicate that whether is a year is given as in the paper this year rem o or year rem o and year o when the correct predicate is year mm if year is and year rem z o or year o by then it must also be by in the incorrect predicate therefore the second part of the or clause is true if and only if year rem is true if a branch analysis method attempts to follow all the hidden paths the error will be discovered when an attempt is made to make year rem true and year rem false with mutation analysis the error is discovered when we replace year rem with true the fifth program computes the greatest common of a vector of integers it appeared in an article by in the communications of the acm the program contains the following four errors if the last input number is the only nonzero number and it is negative then the greatest common returned is negative if the greatest common is not then a loop index is used after the loop has completed normally which is an error according to the fortran standard there are two do loops for which it is possible to construct data so that the upper limit is less than the lower limit which causes the to produce incorrect results since do loops always execute at least once none of the errors is using branch analysis all are with mutation analysis the next three programs are adapted from the ibm scientific subroutines package in each program three errors were inserted in a study by and the first program computes the first four of a vector of observations one of errors would be detected branch the other two can be all three errors be discovered using mutation analysis the the second program computes statistics from observation table again one error would be discovered using branch analysis but all three errors are discovered with mutation analysis an the third program computes coefficients two of the errors are detected with branch analysis all three are detected mutation analysis with the next program takes three sides of a and whether it is or paper by and it first appeared in a and describe a bug where two occurrences of the constant are replaced with the variable k this bug is very subtle but it can be detected with the test case neither branch analysis nor mutation analysis would force the discovery of this error the program is the find program from an article by c a r hoare the bug has been studied by the group developing the select symbolic execution system the bug is very subtle and neither branch analysis nor mutation analysis would guarantee its discovery this bug was however easily discovered by mutation analysis in the normal debugging situation during some early experiments on the effect the last program appeared in a paper also written by in algol and has also been studied widely the program is intended to read a string of characters consisting of words separated by or characters or both and to output as many words as possible with a between every pair of words there is a fixed limit on the size of each output line and no word can be broken between two lines the version studied here is that of and containing five errors three of these and in their numbering are by mutation analysis 
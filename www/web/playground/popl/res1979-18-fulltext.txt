illinois automatic data structure selection in setl institute of technology and t schwartz and institute of mathematical sciences abstract in relatively low level programming setl is a very high level programming language supporting set theoretical syntax and semantics it allows algorithms to be and without requiring data structure declarations to be supplied though such declarations can be manually specified later without re coding the program to improve the of program execution we describe a new technique for automatic selection of appropriate data representations during compiletime for or partially declared present an efficient data structure selection algorithm whose complexity is comparable with those of the known general dataflow algorithms of tarjan ta and reif re introduction languages datastructures have to be selected in before starting to code the program the code to be written then depends on this selection and large sections of it are solely to the manipulation of the selected data structures these code sections constitute a significant source of bugs and become in the program logic to the extent that they have to be replaced or modified when we want to change the data representation the programming language setl being designed and implemented at new york uni will serve in this paper as a prototype of a very high level language which treats the selection of data struc tures in a different way we will describe an automatic technique which the level of a programming language is enables the setl programmer to code his determined by the power of its semantic program in a high level relatively primitives which influence the ease and of specific datastructure and speed of programming in the language pro yet allows a reasonable level of see ha for an attempt at to be achieved these abstract concepts in the setl system the data thus a language of very high level tation used to realize an algorithm provide high level abstract objects and depends on its code and not vice versa operations between them high level more specifically algorithms are coded structures and the ability to select without specifying any concrete data data representation in an easy and structures at all the objects appearing ble manner it is the third property of in a program are dynamically assigned very high level in this paper languages that we address appropriate the basic abstract data types data types from among supported by the s us work was supported by the national of energy research science contract foundation grant and the language in the optimizing version of setl each such data type is viewed as a generic representing a tion of more specific datastructures all of which are capable of representing the same abstract data type thus the data type set can be represented as a hash table or a linked linear list or a etc however the semantic features of the abstract setl data types as well as of the operations on them are independent of any specific data struc ture selection thus program code need not be modified when this selection is made once an algorithm in setl has been coded and executed successfully and in future also proved correct can be selected in order to improve execution efficiency two selection techniques are provided the more conservative technique is manual in technique the program text is with declarations specifying data structure representation for some or all program variables to be used if these representations are con with the abstract data types actually acquired by the declared vari ables during execution then the program will be precisely to the original purely abstract one but can run much more efficiently in the second more data structuring mode which is the one to be described in this paper datastructure selection is performed automatically by an optimizing compiler this is in general a complex task because each particular data structure will usually be more efficient for some instructions and less efficient for others so that in order to arrive at a realistic evaluation of the cost of us ing alternative data structures for a given program variable we must perform an appropriate global analysis of the way in which program objects are used and related to each other our main aim in this paper is to pre sent an automatic data structure choice algorithm while this algorithm reflects the particular semantic environment of setl and therefore cannot be regarded as a general selection purpose procedure automatic data structure it does establish the possibility of performing automatic data structure selection in a reasonably manner in a language of very high level this paper is organized as follows in section we briefly review setl and its manual data structuring system known as the system section will describe our datastructure selection algorithm in detail including examples the way in which this algo rithm applies to sample programs we take this to thank several members of the setl project at new york university namely robert b k and for numerous suggestions concerning datastructure particular our work selection has been in greatly by earlier work of li the setl language and its system we now summarize the principal features of the setl language setl admits finite set theoretical objects such as arbitrary finite sets maps and tuples and supports most of the opera tions between these objects the language also supports the major elementary data types found in most programming languages in particular integers reals and strings true and false are strings used to represent boolean values tuples in setl are dynamically extensible ordered sequences of component values which can be either primitive or themselves structured tuple concatenation indexed and storage of components and storage operations and a tuple length operator are provided sets in setl are unordered collections of elements these elements being tive or structured such that no element can appear in a set more than once setl provides the usual settheoretic opera tions union intersection etc and some special operators summarized below setl also provides general set former expressions universal and existential quantifiers compound operators on sets and similar high level constructs maps in setl are simply sets of tuples of length called pairs and can repre sent both functions and relations setl provides functional style constructs for map and storage as well as several special operators eg domain and range which compute the domain set and the range set of a map since maps are sets all operators can also be used with maps data structures such as trees and graphs are represented in setl using maps which give the relationships between the elements of the structure without having to specify the detailed storage structure to be used a special value om for is used to indicate an undefined value all vari ables are operations constraints initialized can also are not to yield met om and certain om if domain for example vi sent yields length om if v is a tuple is less than i whose pre the setl control structures are conventional and include the else clause case statements while loops numerical iteration etc and also a few additional very high level control struc tures eg iteration and existential over a set quantifiers setl like apl has value semantics rather than pointer semantics this means that the value of each program variable is essentially independent of the values of other variables and will not be affected when other variables storage optimization are modified several variables can share a common value using pointer mechanisms but care will always be taken to create new copies of that value when ever logically necessary this value semantics also implies that parameters are passed by value rather than by name and that no explicit reference and manipulation of pointers are allowed the following table summarizes the main operations of setl for additional details see de and sc table some of the primitive operations operation remarks setl xy x y xy xy x and y x or y x implies not x x xy x y xy xy x xy y x with y x less x x from y y xy fx l integer and real union tuple and integer and real set difference integer and real set intersection tuple arithmetic division boolean operations addition string set multiplication string and y of sets length of tuples and strings equality and inequality comparisons arithmetic comparisons string comparisons set insertion tuple increment ing set deletion set membership test select arbitrary element of x select element and delete an arbitrary of the set y set with specified elements tuple with specified elements function or call indexed from a tuple or a string if f is a map fx domain f range f x y fx y fx y fx y type x fx is the unique y such that xy in f y exists otherwise the set fx of all om undefined y such that in f f must be a map operators producing domain and range of maps simple assignment yielding y as a value map storage which will cause all other pairs xz to be deleted from f indexed assign ment for tuples and strings map storage corresponding to the operator fx extract starting at component number x and ending at y of the tuple or string f corresponding storage operator is also available generate a new unique atom the current type of x in addition to the above primitives setl provides several high level con involving explicit or implicit iterations over sets and tuples table summarizes some of these constructs this table the iterator denotes a construct of the form in x in xn in nl i q where sions e rr e n are and iteration is carried out by assigning all possible elements in the corresponding sets to x rx xn moreover cx x is a boolean n valued expression which defines the sets of values to be in the iterations table additional high level constructs setl name form iteration over sets set former tuple former existential quantifier if iterator xn iterator where x f variables of x are the n the iterator free j where x l if order xn are as is important above all iterations should be numerical iterator the free are set variables to their x x first value during the iteration for which the condition c is true and are otherwise undefined the expression yields true or false respectively the special constant set or map nl denotes the null let us now describe the tures which setl supports tuples are represented as dynamic arrays of tive memory locations which have to be if their length increases beyond their current allocation sets are represented as linked hash tables so that iteration over a set is fairly but most of the other set operations involve hashing into a set an operation which can be expected to be relatively costly in fact as will be seen later the main optimization that our automatic selection of data structures aims to achieve is to minimize the number of hashing operations performed during the execution of a program the default representation of maps is either their standard set representation or if it can be during ion that an object will always assume a map value then it is represented as a linked hash table on the domain elements of the map where each entry in the table points to the range value of the corresponding domain element this operations such as map and storage but makes set operations such as set union ly more than they are for the default set representation in order to obtain a coherent extended class of efficient data representations we introduce new program objects called bases which are used as universal sets of program values cf de for a more detailed description bases enable us to access related groups of program variables in efficient manner this is the only use of bases once one or more bases have been introduced other program variables can be described by their relationship to these bases the set of these declarations will determine the run time value of these bases because bases are ed to maintain the validity of these relationships for example we can declare a program variable x to be an element of a base b by writing if this declaration is made then during execution any value assigned to x is inserted into b unless this value is found to be already in b internally a base b is represented as a linked hash table of element blocks each such block contains a program value or a pointer to such a value and as many additional fields as are needed to store program variables which have been declared to be based on b i variable x declared as e b is represented by a pointer tic some element block of b so that the actual value of x can be obtained simply by de this pointer whenever x is represented in this way we shall say that x is located in b computation of such a which may imply insertion of a new value into b will be called a base operation a main aim of our data structuring system is to minimize the number of these search and insert opera tions normally realized as hashing which are performed during program execution in addition to the element of a base representation described above which can be declared for any program variable related based representations are able for sets and maps a set s can be declared as a subset of a base b by ing one of the following declarations s local set c b s indexed set b s sparse set b if the first declaration is used a single bit position is in each element block of el this bit is on iff the element represented in the block belongs to s this representation of s supports very fast insertion and deletion of elements from s and membership tests operations that would have otherwise required hashing into s and it to the familiar notion of an bit or flag in a structure if the second declaration is used then all these bits will be into a stored independently of b in order to access this string via b a unique index is assigned to each element block of b when this block is created the bits these of s are indices in the order of thus to perform the insertion operation s with x where x is declared as e b the following steps are taken a element ix block the index of the to which x points b turn on the bit of s note that in both cases the set tion operation s with x is fast only if x is represented as an element of b in any other case the value of x must first be into b to find the corresponding element block or create a new element block if the value of x is not yet in b this observation indicates that based representations are when con are given to all the vari ables involved in hashing operations using the same base even when this is done hashing operations will still be required to create b however they will be fewer than in the case the first two declarations have one common to iterate over s we must iterate over b and perform a membership test in s for each element in b this is certainly less efficient than a direct iteration over s as would have been done in the case and is especially so if the cardinality of s is much smaller than that of b when tion over such a sparse set is performed can use the third representation in which s is represented by a linked hash table whose entries are pointers to element blocks of b this representation supports slightly fast more iteration over s and is than the representation for search tion and deletion from s since equality of pointers can be checked whereas equality of general values is much more expensive similar alternative representations are available for maps a map f whose domain is a subset of a base b can be declared in one of the following ways f local map g b f indexed map b f sparse map e b where denotes any representation for the range of f we will assume that f is singlevalued to simplify the description of its corresponding thus for example map b int denotes a map from some subset of b to some set of integers if the first declaration is used a fixed field within each element block x of b is allocated and for storing the value or a pointer to the value of fx or om if fx is undefined this makes map and storage operations very efficient for the tion y fx as an element of where x is represented b can be implemented as a simple indexed load and the need to hash on x in f is eliminated this local map representation captures the familiar notion of data structures consisting of base element blocks within which various fields contain either values if the range of the corresponding map is or pointers to other nodes local representation of sets and maps have one basic since they are allocated in static fields within each element block of a base their number must be at compile time also no other variable can share their value without the value semantics of the language thus whenever such variables are assigned to other variables or within other composite objects or are passed as parameters to a procedure their value must be copied first hence if such a variable is frequently to operations of this kind its tation may be quite inefficient the indexed representation is provided to avoid declaration such problems is used for if the f then indexed an array v disjoint from b is allocated for f and contains the range values of f in the order of the indices in b thus to fx provided that x is represented as e b two indexed loads are performed as follows a element ix block the index of the to which x points b we will refer to each of the data structures which can be declared in the modes thus range from system primitive as a mode modes such as int atom and string to modes which can be nested to any level for example a two dimensional map can be represented as local a value map e bl indexed of a map declared map c b to have this int representation can be using three indexed loads which is even faster than of a component of a two dimensional array in fortran e now illustrate the preceding con by an example showing the process of declarative datastructure selection in setl the following program computes a minimum cost path between two nodes in a directed graph statement numbers are given for later reference program read read in mation cost is graph and auxiliary graph is a set of an map on these edges and y is the x is the target source node prev g prev is a map from each encountered node to its predecessor val val maps each ed node to the minimal cost cf a path reaching it from x val x o start node has zero cost path x initially node is newly reached start while nl while there exist newly reached nodes n from select such a node and for each of its successors nm calculate new path cost j or path val m note path value n and predecessor keep searching if goal not reached with m end if end if end v end while if om then y is from not x reachable is not reachable from x else path y build up path z y starting with the last node while z chain to om preceding node path with z end while and now reverse path il path end if end program this is the pure setl program in which no specification of data structures has been supplied after this program has been coded and tested we can select data structures for its variables a typical choice might be as follows introduce a base nodes which will be the set of all nodes in the graph then declare graph cost local local map g nodes map nodes c nodes indexed map nodes local set nodes prev local nodes e nodes ie singlevalued map val local g nodes e nodes path tuple nodes int in the presence of these declarations a hash table will be generated for the base nodes this hash table will be filled in automatically as soon as the graph is read in by our program each block in this hash table will contain several fields which store values bits and pointers to other entries in this table after the input phase the rest of the program is executed without performing a single hashing operation we pay a very small price for this when we print path since each component must be to its actual value before being out we the point that we can map our objects onto lower level data structures and generate code sequences quite close to those which would appear in a lower level variant of our algorithm such as one written in pascal or pl and comparable efficiency without the original form of our algorithm at all this example indicates that the off between programming language level and execution efficiency need not be as as is generally expected of course in our example we lower somewhat the level of pure setl by the datastructure declarations however this program is very small compared with the that would be involved in an actual of the algorithm in a lower level language furthermore as will be shown in the sections the that we have declared can be selected automatically thus the program of the task of specifying any data structures at all an automatic algorithm datastructure selection the algorithm to be sketched below is not our first attempt at performing in setl see sc and de a strategy common to these approaches and to our new algorithm as well is to generate bases and corresponding based representation for variables requiring involved hashing in operations otherwise these bases initially reflect only local mation and separate bases are generated for each hashing operation to integrate these local into an overall structure they are prop globally during propagation individual bases are equivalence whenever logically appropriate we feel that the efficiency and simplicity of our present algorithm makes it our best candidate for performing automatic data structuring in setl to illustrate the strategy which this algorithm consider the following setl code fragment program shown in taken from the the previous section n from n with m in this code instructions and implicitly require hashing operations thus we first and generate two establish bases the prev where vi m set denotes b m b the occurrence b eb of a variable v at instruction i and denotes any mode note that we generate repre for variable occurrences rather than for the variables themselves this is because setl is only weakly typed so that each variable may assume more than one datatype in the course of execution various problems arising in view of this fact will be addressed later on however since there exists a link between m and m it follows that m and can therefore assume be we therefore the same an element merge the value which must both of b and b representations of and m into by identifying one common representation b with b we can then propagate the resulting to tion which is a operation whose execution speed is of the representation of its arguments then in view of the dataflow link between and we give the same representation as and also put nl c an additional propagation step using the n link gives prev tion map e b b the our algorithm the strategy that has been sketched above in a rela efficient and simple manner before describing this algorithm let us sketch the form of input it assumes we suppose that the program to be analyzed has already several other analyses and optimization including a modified version of the analysis cf al which computes a data flow map called whose definition is as follows let vo v be two occur of a variable vol e iff v then v is a use of v and their exists an execution path leading from vo to v which s free of other occurrences of v cf sc for more details we also assume that type analysis has been performed using approach so that type information will have been assigned to each variable occurrence in a manner ensuring that the calculated type of each variable occurrence dominates every data type that the variable can acquire at that program point during execution assuming consists of all this the following our algorithm phases a base generation b representation merging and base c and representation d a base generation this phase performs a linear pass through the code being analyzed for each instruction i we introduce enough bases and corresponding based representations for arguments of i to ensure that execution of i with these based representations for its arguments is not slower than execution of i with ed arguments for example i suppose that i is s with x then we introduce a base b and assume the eb tion of bi representations note that here set b the up the execution of i considerably ii next suppose that i is fx y here we introduce two bases b b and gb i essential represent g b i since its fl map here only introduction g bb b is a hashing operation and we refer to b as an effective base the introduction of b does not speed up execution of i but does not slow it down we refer to b as a neutral either base and the utility of neutral bases will become clear in our description of the next phase of the data structure choice algorithm iii next suppose that i is x vj where v is a tuple here no speedup is possible but nevertheless we introduce a neutral base b and establish the representations tuple i b x iv finally suppose b that i is x x here no base can be intro without running the of i down significantly because of the pos introduction of conversion opera tions for the created values of x between their int mode and their tive b mode hence we introduce no base for i in this first phase we also build up a map em mapping each generated base to the mode of its elements during this phase all these modes are but they may be transformed into based modes during phase b b representation merging and base this phase executes a linear pass through the map for each pair of variable occurrences vv vo have the same such type that and both vo and that vol and v have both received based representations in phase a we perform the following representation merging ation recursively let ri r denote the based of vol v respectively three cases are possible i ie case both r and r are base pointers r and r equivalence b and b in this ii one of these representations say and based representation the other in is this a composite case merge with r setting to r if the former is an mode iii both r and r are composite repre since the settheoretic types of vo and v are assumed to be equal the composite structures specified by ri and r must also have the same type ie both must be sets or maps or if one is in this case merge the of ri with that of r if ri and r represent maps merge their domain and their range separately if rl and r represent tuples of the same known length n each component then having its own type and representation perform n merges this process can be made highly efficient by using a tree representation for the set of all generated bases cf t this representation allows tion of a sequence of opera tions in almost linear time the mode map em need be kept only for roots ie we only need to keep one value per equivalence class whenever two trees whose roots are are merged into one we also update the map em of the new root which is either b or b as follows i if both and are they must be equal so that no updating need take place ii if one of them is based and the other is not set em of the new root to the based mode iii if both are based then leave either of the two at the new root but merge them with one another note that phase b uses the neutral bases introduced in phase a to transmit information between instructions without global actually propagation having to technique use any this point is illustrated by the following example s with x vi s t vj s is v is a set a tuple of sets y from t t is a set phase a will have generated the follow ing v using set tuple tuple set the g bl e b b b s s link eb eb y g b phase b will set set bl in of the v v link we then equivalence b and b setting em of the new root to set bl then in of the t link we merge z b with set b ie merge set bl t and set b which causes b and b tion would and b q to be equivalence were this have been more difficult if and rather complex propagation information through the of code would have been required c base pruning and representation when phase b termi the set of all initial bases will have been split into equivalence classes each such class corresponds to one actual base b and the map em maps the root of this class to the common representation of the elements of b it is ble that such a base b may be useless in the sense that its introduction cannot speed up the execution of any instruction or even if some instructions are made more efficient due to the introduction of b all these instructions involve only the same composite object s based on b in this latter case introduction of b will simply replace the hash table of s by that of b which us nothing such cases are detected and eliminated by phase c as follows i we find all actual bases which are useless according to the criterion stated above and flag them as such ii we update all based representations of variable occurrences and also the element modes of all actual bases in the following recursive manner ii modes are left unchanged ii each base b appearing in a mode is replaced actual base if is by the corresponding a not useless if b is useless we replace the b by em iii we enter all useful bases into the symbol table it can be shown that the preliminary phase of the optimizer can be in such a way as to guarantee that this recursive operation will always converge note also that it is only after this that a variable occurrence can have a based representation involving more than one level of specification eg set tuple b as an example consider the case of an map f in compilation of setl each of the value is expanded into the code sequence t fx z ty phase a of our algorithm will generate the following representations eb map bl map b c b b now we assume that the equivalence class of b turns out to be useless which is the case eg if f is always accessed as a map and also that b is use less eg no set manipulation of the range of f occurs in the program being analyzed phase b will merge the representations of tl and t to obtain map e b b hence phase c will update the representation of fl to map bl map c b e b and again to map bl map b int which is probably the representation that a program would have chosen manually and is also the best representation for sparse multivariate maps defined domains d this phase of our is the final algorithm at the end of phase c based tions as well as type information will have been computed for each variable occur rather than for each variable we use occurrences rather than variables because the weak typing of setl allows a variable to assume more than one datatype during execution moreover even objects with the same datatype may be represented in different ways at difference occur of the same variable nevertheless the information collected by our algorithm must finally be stated on a per variable basis since subsequent compiler phases eg our generator cannot support more than one type or detailed representation per variable furthermore the first three phases of our algorithm ignore the operations which actually insert elements into a base b for example consider the code x x s with x the first three phases of our algorithm will assign int as the representation and e b as the representation of of xt where b is some base this means that instruction can assume that the value of x is represented by a pointer into b but of course such a pointer must be first created these two problems of information integration and base insertion are solved simultaneously in the phase of our algorithm in this phase we first scan all occurrences of each program vari able x for each representation r assigned to at least one of these occur we generate a new entry which we denote by xr and which is said to be split from x we then replace all occurrences of x having the tation r by occurrences of xr if two occurrences of the same original variable x having different representations ri r are linked by then we must of course ensure that conversion of the value of x from representation r to tion r will take place as control advances from the first occurrence to the second one to enforce this conversion we insert the code an assignment at some optimal r xr into cy place separating these two occur the algorithm which inserts such conversions into the code is rather simple and is based on the interval structure al of the flow graph of a setl program for each occurrence vo of a variable v which is linked by to other occur of v which have different our algorithm will insert a conversion to the split variable of vo either just before vo or just before the head of some interval containing vo for example in the code fragment v x x end t v s with end v x a conversion from the tion appropriate for x within the first loop to the based representation for x within the second loop will be inserted just before the start of the second loop the choice of the interval at whose head we insert a conversion involves safety criteria which will not be mentioned here for a full description of this aspect of our method the reader is referred to gs it is important to note that the set of all program points at which there occur conversions to representations based on a base b is also the set of all points at which elements are added to b by hashing operations in general the number of these conversions will be smaller and for typical programs substantially smaller than the number of hashing operations which would have been required without the presence of b a comment on the complexity of our algorithm phases a and c are linear in the length n of the code phase b is almost linear in the number m of links which for typical programs be linear in n phase d is om n thus the overall complexity of our algorithm is of order on where a is an extremely growing function cf ta for details an example we will now the way in which our algorithm applies to the program earlier for simplicity we consider only the first section of the program which searches through the graph within which a path is phase a will generate the following based representations prev cost x y general m ap g b g b va va g b e b b b x b set b x b set set c b c b n e b graph m ap e b b e instruction of the code expands into roughly the following sequence and thus generates the following representations m b g cost map e b e e e a map e b no bases are generated va e by instruction map e b e q o map w u map g b c b my e q b e among the above b m q b bases only b are effective and phase b will perform the following merging and in view of the link we equivalence b with and ith in link we equivalence view of the b with x x etc and ith in link b and b are view of the equivalence only one additional merge extra comment namely the step which merges the representation of and and which belongs to case ii of the general description of merging given above this merge step causes us to set b mation map thereby b generated e b the will be used by phase c to update representations con b which will turn out to be useless at the end of phase b the equivalence classes of bases will have been formed b b a class containing all the bases since only b is effective remaining the first three classes are useless phase c will thus eliminate any reference to bases in these classes eg the representation of will be updated to map map b int as for a eb by we simply replace since as the is easily checked em int at the end of phase b phase c will thus assign the repre suggested in section to most of the occurrences of the variables graph prev val x y m and n however the occurrences graph cost x and y remain this will cause phase d of our algorithm to split each of these variables into two entries a based one and an one and to insert four conversions from each of the split variables to the corresponding based one before entering the while loop but the conversion of x will instruction as x has already the based representation the base is built precisely at these places and then remains constant during execution of the remainder of the program a few final words concerning refine ment of the based representations selected by our algorithm our algorithm is to speed a main goal of up program tion by reducing the number of hashing operations performed by the program having achieved this optimization we can expect a considerable speedup in the execution of the program however tional improvement is possible if we refine the based representations thereby selected choosing suitable local or sparse representations for based sets and maps however to choose refined datastructures effectively may require frequency information object size etc which are able during compile time but cf lo for various interactive and runtime techniques which can help such information since our aim is to develop a fully automatic ing technique we any attempt to collect and use such information and make do with a and more approach which can be summarized roughly as follows i if a based object a is iterated upon choose the sparse representation for a ii if not but a is in global operations or is assigned to any variable or passed as a procedure parameter or incorporated into other objects or used in a manner requiring value copying choose the index ed representation for a iii in all other can have local representation references al de gs allen f e control flow sis proc symp compiler tion sigplan notices ­ a sc e and schwartz programming by refinement as by the setl tion to appear in cacm a and m on name li lo re sl se sc sc ta ta e splitting in setl optimization setl inst sci new york h elements of soft science north holland new york s c automatic data structure choice in setl phd thesis inst math sci new york to appear low j r automatic data structure selection an example and overview cacm reif j h phd thesis university to appear e and s c manual and automatic data structuring in setl proc th annual iii conference france j t automatic structure choice in a language of very high level proc nd popl conference palo alto schwartz j t as a technique in setl inst new york schwartz j t on programming an report on the setl project nd edition inst math sci new york tarjan r e efficiency of a good but not linear algorithm jacm tarjan r e solving path problems on directed graphs tech rep stanford university a m type tion for very high level languages computer sci rep math sci new york inst 
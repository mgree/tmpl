proof spaces for unbounded parallelism university of podelski university of abstract in this paper we present a new approach to automatically verify multithreaded programs which are executed by an unbounded number of threads running in parallel the starting point for our work is the problem of how we can existing automated verification technology for sequential programs abstract interpretation craig interpolation constraint solving etc for multithreaded programs suppose that we are given a correctness proof for a trace of a program or for some other program fragment we observe that the proof can always be decomposed into a finite set of hoare triples and we ask what can be proved from the finite set of hoare triples using only simple combinatorial inference rules without access to a theorem prover and without the possibility to infer new hoare triples we introduce a proof system where one proves the correctness of a multithreaded program by showing that for each trace of the program there exists a correctness proof in the space of proofs that are derivable from a finite set of axioms using simple combinatorial inference rules this proof system is complete with respect to the classical proof method of establishing an inductive invariant which uses thread quantification and control predicates moreover it is possible to check whether a given set of axioms is sufficient to prove the correctness of a multithreaded program using ideas from transition systems introduction in this paper we present a new approach to verifying multithreaded programs which are executed by an unbounded number of concurrent threads many important systems and application programs belong to this category eg device drivers web servers and image processing applications we will start by our approach on a simple example consider a program in which an unknown number of threads concurrently execute the code below the goal is to verify that if g holds initially then it will always hold regardless of how many threads are executing global int g local int x x g g gx consider the set of the hoare triples a d given below permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than the authors must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january copyright is held by the publication to acm acm a g x g x b g x g g x g c g x g g d x x g x here we use x to refer to thread s copy of the local variable x and x g to indicate the instruction x g executed by thread we will discuss how such hoare triples can be generated automatically but for now suppose that we have been given the above set of hoare triples and consider a deductive system in which these triples are taken as axioms and the only rules of inference are sequencing symmetry and conjunction these rules are easily illustrated with concrete examples · sequencing two hoare triples sequentially for example sequencing a and d yields a d g x g x g x · symmetry thread identifiers for example renaming a and c mapping yields a g x g x c g x g g and renaming d mapping and yields d x x g x · conjunction two hoare triples by pre and postconditions for example a and c yields a c g x g g x and a and d yields a d g x x g x x naturally the deductive system may apply inference rules to hoare triples as well for example by sequencing ac and a d we get the hoare triple g x g x g x x a proof space is a set of valid hoare triples which is closed under sequencing symmetry and conjunction that is it is a theory of this deductive system any finite set of valid hoare triples generates an infinite proof space by considering those triples to be axioms and taking their closure under deduction we call such a finite set of hoare triples a basis for the generated proof space one key insight in this paper is that although it may be challenging to formalize a correctness argument for a multithreaded program any given trace sequence of program instructions of the program is just a simple sequential program which can be easily proved correct in fact just these three simple inference rules sequencing symmetry and conjunction are sufficient to prove the correctness of any trace of the example program that is for any trace of the program g g belongs to the proof space generated by a d regardless of which or how many threads execute in and due to the simplicity of the inference rules this fact can be checked completely automatically by techniques developed in the context of transition systems now let us turn to the problem of how hoare triples like a d can be generated automatically an important feature of proof spaces is that they are generated from a very simple set of hoare triples of the sort one could expect to generate using standard technology for sequential verification to the simplicity of these triples consider the following inductive invariant for the program the classical notion of correctness proof for multithreaded programs g xi which indicates that g is at least and all threads i at line of the program have xi at least this is a simple invariant for this program but it is one which we cannot rely on a sequential verifier to find because it makes use of features which are not encountered on sequential programs thread quantification i and control predicates in contrast the triples a d are of the form one might expect to generate using a sequential verifier thus proof spaces are a solution to the problem of how to use automated proof technology for sequential programs to prove the correctness of programs with many threads one possible algorithm discussed further in section for proof spaces is to build a basis for a proof space iteratively in a manner analogous to a counterexample abstraction refinement cegar loop while this algorithm is not the focus of this paper it is important to recognize the context of and motivation behind proof spaces the algorithm operates as follows first choose a trace for which there is no correctness theorem in the proof space for example suppose that we start with the trace x g x g g g x this trace can be viewed as a sequential program and we can use standard technology eg abstract interpretation constraint solving craig interpolation to construct a proof for it for example the one on the right by extracting the atomic hoare triples along this sequence we can arrive at the triples a b and d which we add to our basis we may g x g x x g x g g x g then extract a new trace which cannot be proved using just a b and d and the loop the loop terminates when and if it finds a feasible counterexample or all traces of the program have correctness theorems in the proof space the key contribution of this paper is the notion of proof spaces a proof system which can be used to exploit sequential verification technology for proving the correctness of multithreaded programs with many threads the of proof spaces are as follows · rather than the language of assertions introducing thread quantification and control predicates and more powerful symbolic reasoning proof spaces use simple assertions which can be combined using combinatorial reasoning ie without a theorem prover · we show that the combinatorial reasoning involved in checking whether all traces of a program have a correctness theorem in a proof space can be automated and give an algorithm which ideas from transition systems we show that this proof space checking problem is undecidable in general but our algorithm is a decision procedure for an interesting subclass of proof spaces · despite the apparent of our three inference rules and the restricted language of assertions we show that proof spaces are complete relative to a variant of classical proof system for multithreaded programs which universal thread quantification and control predicates motivating example consider a simplified implementation of a thread pool where there are arbitrarily many threads each executing the code that appears in figure the global variable tasks holds an array of tasks of size len the global variable next stores the index of the next available task and the global variable m is a lock which access to next we denote the threads of the program by t t each thread ti has two local variables ci and which represent the current and last task in the block of tasks acquired by ti each thread operates by simply a block of consecutive tasks lines and then performing the tasks in its acquired block in sequence lines the else branch line ensures that once the end of the array is reached all remaining threads that attempt to acquire a block of tasks acquire an empty block c end the details of the tasks are omitted for simplicity and we maintain only enough information to assert a desired property that no two threads are ever assigned the same task this property is encoded by using the tasks array to represent the status of each task started finished a thread can fail the assertion if between some task and executing the assertion some other thread starts that same task global int len total number of tasks global int tasks array of tasks global int next position of next available task block global lock m lock next thread t local int c position of current task local int end position of last task in acquired block acquire block of tasks c next next next if next len end next else end len perform block of tasks while c end mark task c as started work on the task c mark task c as finished no other thread has started task c c c figure thread example adapted from the sketch below illustrates a of the tasks array and other instantiated local and global variables in the thread pool program where threads to have all finished their block of tasks but have not yet started to complete them and thread has not started the process yet locking true m m f initialization true c next c next end next c next end c c next next next c next true end next end next true len len next len next end len end next loop true end c end true f end c c c end c c end c c end c figure the basis of a proof space for the thread example the variable c denotes the copy of the local variable c in thread and the command c next denotes the instance of the command c next in thread etc trivial hoare triples of the type i where the set of variables that i modifies is disjoint from the set of variables in have been omitted for brevity end end end end len c c c c next in order to show that two threads say threads and cannot be assigned the same task we may argue that the intervals assigned to them c end and c end are disjoint by proving that end is less than or equal to c proof space for thread figure illustrates a finite set of hoare triples a basis that generates a proof space for the thread program in the figure the hoare triples are into three groups locking initialization and loop we omit hoare triples that represent trivial invariance axioms of the form i where the command i does not write to a variable that appears in for example c next c next c next note that the set of triples in figure use mixed assertions in the terminology in which relate the values of local variables to global variables eg c next as well as assertions which relate the local variables of different threads eg end c as discussed in both mixed assertions and assertions raise an issue when one attempts to use predicate abstraction techniques assertions cannot be used in classical compositional proof systems eg proofs in these proof systems relationships can only be through auxiliary variables to represent the program in a simple formal model we encode each conditional branch as a nondeterministic branch between assume commands one for the condition and one for its negation and we encode through a command for the negation of the expression e which leads to a new error location we thus encode the correctness of the program the validity of the assert statement through the of the error location by any thread an error trace is an interleaved sequence of commands of any number of threads which leads some thread to the error location eg in figure the sequence in a followed by the sequence in b thus we can express the correctness of the program by the validity of the hoare triple true false for every error trace given this hoare triple as the specification of correctness of a trace we have that a trace is correct if and only if it is infeasible let us now demonstrate how the proof space is used to argue for the correctness of the program we must show that for every error trace there exists a derivation of true false which can be constructed from the triples in figure using only the combinatorial inference rules of symmetry conjunction and sequencing let us first consider the pair of hoare triples in the locking group we treat the command as the atomic sequence m and command as the assignment m intuitively the locking hoare triples the reasoning required to prove that the lock m provides mutually exclusive access to the variable next any trace that violates the locking semantics can be proved infeasible using the hoare triples in the locking group along with the sequencing and symmetry rules to see why consider that any such trace can be decomposed as · i · · j · such that the following hoare triples are valid true true m m false i j true m m false false this decomposition exploits the fact that any trace which violates the semantics of locking has a shortest prefix which contains a violation that is we may assume that contains no commands because if it did there would be a prefix in which two threads simultaneously hold the lock m having justified their semantic validity we may now consider how to derive these triples using symmetry and sequencing from the locking axioms in figure the two triples above concerning the command are inferred from the triples in the locking group by renaming thread ie using the symmetry rule to i and j respectively the rest of the triples come from the simple invariance hoare triples not depicted in figure but mentioned in the that allow us to infer m i m for any command except and true i true and false i false for every command we now turn our attention to the error traces which do respect locking semantics and show that they are infeasible the six hoare triples in the initialization section of figure are sufficient to prove that after two threads say and acquire their block of tasks those blocks do not overlap ie we have either end c or end c depending on the order in which the threads acquire their tasks an example of such a trace which can be proved using just sequencing and symmetry operations appears in figure a we the reader to show using conjunction that if we extend the trace in figure a by the initialization sequence of a third thread say thread to obtain a trace then true end c end c end c belongs to the proof space as well following similar proof combination steps one can see that the argument can be adapted to traces with any number of threads finally the triples in the loop section can be used to show two things first the property established in the initialization section is preserved by the loop for example if end c holds at the beginning of the loop then if thread or thread or any other thread executes the loop end c continues to hold second assuming the condition holds if some task has been completed then it remains completed for example if then when thread starts task c ie assigns to it cannot the value of the array cell this is by the precondition c end c which implies c c figure b gives an example proof which can be derived using the loop section the sequential composition of traces in figure a and figure b forms an error trace ie one that leads to the error location and sequencing their proofs yields a proof that the error trace is infeasible we hope that it is now intuitively clear or at least that given any particular error trace it is possible to derive true false using the symmetry sequencing and conjunction rules starting from the axioms given in figure the question is how can one be that all infinitely many error traces can be proved infeasible in this way in section we will show how to formalize such an argument and moreover give a procedure for checking that it holds in this section we will define our program model and introduce some technical definitions we fix a set of global variables gv and a set of local variables lv intuitively these are the variables that can appear in the program text we will often make use of the set lv × n of indexed local variables and denote a pair x i lv × n by xi intuitively such an indexed local variable xi refers to thread is copy of the local variable x for simplicity we will assume that program variables take integer values and the program is expressible in the theory of linear integer arithmetic this assumption is made only to simplify the presentation by making it more concrete our approach and results true true c next true next next true len true end next end next end next end next c next end c next next end c len end next end next end c end c a initialization example end c end c end end c c end end c c end end c end c end end c false b loop example figure example traces do not depend on linear arithmetic in any essential way given a set of variable symbols v we use to denote the set of linear terms with variables drawn from v similarly denotes the set of linear arithmetic formulas with variables drawn from v we here use v as a parameter which we will instantiate according to the context for example lv denotes the set of terms which may appear in the text of a program which refers to the thread template and lv × n denotes the set of formulas which may appear in a postcondition which refers to concrete threads we use the notation x t to denote a substitution which replaces the variable x with the term t and generalize the notation to parallel substitutions in the standard way the application of a substitution to a formula or a term t is denoted or t two classes of substitutions of particular interest for our technical development are instantiations and permutations · given an index i n we use i to denote the instantiation substitution which replaces each local variable x lv with an indexed local variable xi for example if we take i to be and c is a local variable and next is a global we have c next c next · each permutation n n defines a substitution which replaces each indexed local variable xi with xi we notation by identifying each permutation with the substitution it defines for example if is a permutation which maps then c next c next we identify a program p with a control flow graph for a single thread template which is executed by an unbounded number of threads the extension to more than one thread template is straightforward a control flow graph is a directed labeled graph p loc init err src tgt where loc is a set of program locations is a set of program commands init is a designated initial location err is a designated error location and src tgt loc are functions mapping each program command to its source and target location note that our definition of a control flow graph using src and tgt implies that we distinguish between different occurrences of a program instruction a program command is of one of two forms · an assignment of the form x t where x gv lv and t lv or · an assumption of the form assume where lv we will denote a pair consisting of a program command and an index i n as the indexed command i intuitively such an indexed command i refers to thread is instance of the program command or the index i indicates the identifier of the thread which executes a trace i i · · · n in is a sequence of indexed commands a hoare triple is a triple where is a trace and and are formulas with global variables and indexed local variables ie lv × n the validity of hoare triples for traces is defined as one would expect intuitively if the command reads or writes the local variable x then the indexed command i ie the command executed by thread i reads or writes thread is copy of the local variable x to express this formally we use the instantiation substitution i introduced above in particular if x is a local variable xi is the indexed local variable xi and if x is a global variable xi is simply x for a trace of length ie for an indexed command we have · x t i is valid if xi ti · assume i is valid if i where denotes entailment modulo the theory of integer linear arithmetic for a trace of the form i the triple i is valid if there exists some formula such that and i are valid we call a trace infeasible if the hoare triple true false is valid intuitively is infeasible if it does not correspond to any execution given a program p identified by the control flow graph of a single thread template ie a graph with edges labeled by commands and with the initial location init and the error location err a trace is an error trace of p if · for each index i n the projection of onto the commands of thread i corresponds to a path through p starting at init ie each thread i starts at the initial location and · there is at least one index j n such that the projection of onto the commands of thread j corresponds to a path through p ending at err ie some thread j ends at the error location we say that a program p is correct if every error trace of p is infeasible ie there is no execution of p some thread reaches the error location err the notion of correctness be used to encode many correctness properties including reachability and thus the safety of assert commands and mutual exclusion the encoding is possibly done by introducing monitors ghost instructions on ghost variables much in the same way that safety properties can be reduced to in sequential programs proof spaces we will now introduce proof spaces the central technical idea of this paper we begin by formalizing the inference rules of sequencing symmetry and conjunction the sequencing rule is a modification of the familiar one from hoare logic we omit the rule of consequence from hoare logic and instead incorporate consequence in our sequencing rule that is we allow triples and to be composed when and do not exactly match but entails however a design goal of proof spaces is that the inference rules should be purely combinatorial and thus should not require access to a theorem prover to the entailment towards this end we define a combinatorial entailment relation on formulas identifying a conjunction with the set of its conjuncts we have if is a superset of formally n m if n m the sequencing rule is formalized as follows sequencing the symmetry rule exploits the fact that thread identifiers are in our program model and therefore uniformly thread identifiers in a valid hoare triple yields another valid hoare triple symmetry i · · · n in i · · · n in nn is a permutation the rule of conjunction allows one to combine two the about the same trace by preconditions and post conditions conjunction next we formalize our notion of a proof space definition proof space a proof space h is a set of valid hoare triples which is closed under sequencing symmetry and conjunction our definition restricts proof spaces to contain only valid hoare triples for the sake of convenience clearly the sequencing symmetry and conjunction rules preserve validity the strategy behind using proof spaces as correctness proofs can be summarized in the following proof rule if we can find a proof space h such that for every error trace of the program p we have that the hoare triple true false belongs to h then p is correct our main interest in proof spaces is using the above proof rule as a foundation for algorithmic verification of concurrent programs towards this end we augment the definition of proof spaces with additional conditions that make them easier to manipulate we call the proof spaces satisfying these conditions finitely generated proof spaces first we define basic hoare triples which are the generators of such proof spaces definition basic hoare triple a basic hoare triple is a valid hoare triple of the form i where the postcondition cannot be constructed by two other formulas and for each j n if an indexed local variable of the form xj appears in the precondition then either j is equal to the index i of the command or xj or some other indexed local variable yj with the same index j must appear in the postcondition the precondition only relevant threads the between the precondition and the postcondition in condition is justified by the rule of consequence given a hoare triple i we may split the postcondition to arrive at two valid triples i i from which the original triple may be derived via conjunction as a result the postcondition restriction on basic hoare triples does not lose significant generality since preconditions cannot be split in this way definition is asymmetric definition finitely generated we say that a proof space h is finitely generated if there exists a finite set of basic hoare triples h such that h is the smallest proof space which contains h in this situation we call h a basis for h proof spaces give a new proof system for verifying safety properties for multithreaded programs the remainder of this paper studies some of the questions which arise from introducing such a proof system in the next section we consider the question of the expressive power of proof spaces that is what can be proved using proof spaces in sections and we discuss how proof spaces may be used in the context of algorithmic verification completeness the method of using global inductive invariants to prove correctness of concurrent programs back to the work of method originally applied to programs with finitely many threads but can be adapted to the infinite case by into the language of assertions universal quantifiers over threads in this section we prove the completeness of proof spaces relative to method this establishes that the combinatorial operations of proof spaces are adequate for representing proofs even though assertions make use of features not available to proof space assertions namely universal quantifiers over threads and control assertions we start by formalizing proofs we can treat each local variable as an uninterpreted function symbol of type n z ie the interpretation of x lv is a function which maps each thread identifier i n to the value of thread is copy of x we let tv be a set of thread variables which are variables whose values range over the set of thread identifiers n we typically use i j i to refer to thread variables note that we use i j i to refer to thread identifiers ie elements of n we use to denote the set of terms xi where x lv and i tv a data assertion is a linear arithmetic formula built up from global variables and terms of the form xi where x lv and i tv ie a global assertion is defined to be a sentence of the form inv i in where inv is a formula built up from boolean combinations of · data assertions · control assertions with i tv and loc and · thread equalities i j and i j with i j tv for any program command we use to denote the transition formula which represents some thread executing this is a formula over an extended vocabulary which includes a copy of each of the global and local variable symbols interpreted as the values of those variables this formula is of the form ii ji j where intuitively describes the state change for the thread which executes thread i and describes the state change for all other threads thread j for example if is an assignment x x g where x is local g is global and src and tgt then i loc i x i xi g g g j i loc j xj x j we may now formally define invariants definition invariant given a program p an invariant is a global assertion inv such that init entails inv for any command we have that inv entails inv where inv denotes the formula obtained by replacing the symbols in inv with their copies inv entails err clearly the existence of an invariant for a program implies its correctness that is that the error location of the program is unreachable the following theorem is the main result of this section which establishes the completeness of proof spaces relative to invariants theorem relative completeness let p be a program if there is an invariant which proves the correctness of p then there is a finitely generated proof space which proves the correctness of p proof to simplify notation we will prove the result only for the case that the proof has two quantified thread variables the generalization to an arbitrary number of quantified thread variables is straightforward let p be a program and let inv be an proof without loss of generality we may assume that inv is written as inv i i loc i j i j where each i and i j is a integer arithmetic formula ie does not contain loc furthermore we can assume that inv is symmetric in the sense that i j is syntactically equal to j i and that i j entails i for any i j we can prove that any inv can be written in this form by induction on inv we also assume that err i false and init i init init i j true the fact that this no generality is a consequence of conditions and of definition finally we assume that each formula i and i j is not syntactically a conjunction cf condition of definition this assumption is validated by observing any formula is equivalent to false which is not a syntactic conjunction we construct a set of basic hoare triples h by collecting the set of all hoare triples of the following four types where src and tgt we now must show that each hoare triple in h is ba ie satisfies definition and for every trace of p true false belongs to the proof space generated by h condition is delayed to section where we prove a stronger result proposition here we will just prove condition one can easily observe that conditions and of definition hold it remains to show that each hoare triple in h is valid we will prove only the validity of the hoare triple where src and tgt the other cases are similar let us write as ii ki k for a proof by contradiction let us suppose that the above hoare triple is invalid this means k k it follows that there exists a structure a such that a k k and a without loss of generality we may assume that loc a our strategy will be to construct from a a structure b such that b inv k k but b inv which contradicts condition of definition we obtain b simply by restricting the interpretation of the thread sort to the set intuitively we consider a of the program in which and are the only threads then we have b k k by downward of universal and b by upward of quantifierfree from b we have b loc by assumption we have b loc it follows that b loc loc and thus from the symmetry condition imposed on inv that b inv it is then easy to see that b inv k k holds finally we note that since b loc loc and b b is incompatible with every disjunct of loc loc and thus b inv as we mentioned previously invariants are able to make use of features which are not available to proof spaces namely control assertions ie assertions of the form and universal quantification over thread variables these features are typical for program logics for concurrent programs with unbounded parallelism as a general rule classical verification techniques for sequential programs do not synthesize assertions which make use of these features the price we pay for the relative ease of generating proof spaces is the relative difficulty of checking them we address this topic in the next section proof checking we now turn to the main algorithmic problem suggested by the proof rule for proof spaces presented in section given a program p and a finite basis h of a proof space h how do we check whether for every error trace we have that true false belongs to h our solution to this problem begins by introducing a new class of automata predicate automata which can be used to represent both the set of error traces of a program and the set of traces which have the theorem true false in a finitely generated proof space we show that the problem of checking whether for every error trace we have that true false belongs to h can be reduced to the emptiness problem for predicate automata we show that the general emptiness checking problem is undecidable and we give a and show that it is a decision procedure for an interesting subclass of predicate automata which correspond to proofs predicate automata predicate automata are a class of automata which recognize languages over an infinite alphabet of the form × n for readers familiar with alternating finite automata a helpful analogy might be that predicate automata are to firstorder logic what are to propositional logic a predicate automaton pa is equipped with a relational vocabulary q ar in the usual sense of firstorder logic consisting of a finite set of predicate symbols q and a function ar q n which maps each predicate symbol to its arity a state of a pa is a proposition qi where q q and i n the transition function maps such states to formulas in the vocabulary of the pa where disjunction corresponds to nondeterministic existential choice and conjunction corresponds to universal choice it is important to note that the symbols q q are uninterpreted they have no special semantics and any subset of is a valid interpretation of q given a vocabulary q ar and given the set tv of thread variables ie variables whose values range over the set of thread identifiers n we define the set of positive formulas fq ar over q ar to be the set of formulas where each atom is either a proposition of the form qi in where i in tv or an equation i j where i j tv or a i j where i j tv predicate automata are defined as follows definition predicate automata a predicate automaton pa is a tuple a q ar start f where · q ar is a relational vocabulary · is a finite alphabet · start f q ar is an initial formula with no free variables · f q is a set of accepting predicate symbols · q × f q ar is a transition function which satisfies the property that for any q q and the free variables of q are members of the set i to understand the restriction on the variables in the formula q it may be intuitively helpful to think of q as qi and of as i we will this definition by first describing the dynamics of a pa pa dynamics will be defined by a nondeterministic system where edges are labeled by elements of the indexed such languages are commonly called data languages readers familiar with should note that we are effectively describing the of pa alphabet × n and where the nodes of the transition system are configurations which we will introduce next definition configuration let a q ar start f be a pa a configuration c of a is finite set of ground propositions of the form qi where q q and i n it is convenient to identify a configuration c with the formula qi we define the initial configurations of a to be the of the disjunctive normal form dnf of start for example if start is p q r then the initial configurations are p q and p r a configuration is accepting if for all qi c we have q f otherwise it is a pa a q ar start f induces a transition relation on configurations as follows c k c if c is a in the dnf of the formula q i k i i qi c the fact that the free variables of q must belong to the set i guarantees that the formula above has no free variables and therefore its dnf corresponds to a set of configurations note also that the formula above may contain equalities and but since they are ground have no free variables they are equivalent to either true or false and thus can be eliminated we can think of q as a rewrite rule whose application the implicit formal parameters i of q to the actual parameters i in and i to k the index of the letter being read in light of this interpretation we will often write in a form that makes the implicit formal parameters explicit for example instead of q i i qi i qi i i i qi i qi i we will typically write qi j k k i qk i qi j k i qi j qj i a trace i · · · n in is accepted by a if there is a sequence of configurations cn c such that cn is initial for each r n cr cr c is accepting it is important to note that the definition of acceptance implies that a pa reads its input from right to left rather than left to right we will discuss the reason behind this when we explain the correspondence between proof spaces and predicate automata proposition our first example of a predicate automaton will be the one constructed to accept the language of error traces of a program proposition given a program p there is a predicate ap such that is the set of error traces of p proof let p be a program given by the thread template p loc init err src tgt we define a pa ap q ar start f which closely the control structure of p · q loc err loc where err and loc are distinguished predicate symbols to be explained in the following · and for all loc ar · let with say src and tgt the transition rule for a location loc is given by i j i j i i j i if i j i if the transition rule for loc is given by loc i loc i the transition rule for err is given by err i i if err err if err · start loc err · f init loc intuitively the distinguished predicate symbol err represents some thread is at the error location the loc predicate is responsible for the program counter of threads in the backwards direction that is loc ensures that in every reachable configuration c of ap every and every i n we have that if c i c then i c where src for example let with src and tgt by reading the initial configuration loc err may transition to loc err if is not err or to loc if is err we omit a formal proof that is indeed the set of error traces of p as the following proposition states predicate automata are also sufficiently powerful to represent the set of traces which are proved correct by a given proof space proposition let h be a proof space which is generated by a finite set of basic hoare triples h there exists a pa ah which can be computed effectively from h such that is exactly the set of traces such that true false h proof let h be a set of basic hoare triples the predicate automaton ah q ar start f closely the structure of h intuitively the predicates of ah correspond to the assertions used in h and each hoare triple corresponds to a transition in the key step in defining ah is to show how each hoare triple in h corresponds to a transition rule noting that if there are several hoare triples with the same postcondition we may combine their transition rules for a concrete example consider the hoare triple t t t t t t t this triple corresponds to the transition t ti j k i j i k j k t j t tk j the predicates which appear in this formula are canonical names for the formulas in the hoare triples eg t is the canonical name for t after constructing the transition relation as in the example we construct ah by taking the set of predicates to be the canonical names for formulas which appear in h false to be the initial formula and true to be the set of final formulas the construction of a pa from a set of basic hoare triples for proposition reveals that the reason we defined predicate automata to read a trace backwards ie the sequence of indexed commands from right to left is the between pre and postconditions in basic hoare triples definition requires that the postcondition of a basic hoare triple cannot be constructed by two other formulas while the precondition is arbitrary ie we may think of the postcondition as a single proposition while the precondition is a set of propositions since the transition function of a pa is defined on single propositions the action of a transition must transform a postcondition to its precondition which reading the traces backwards propositions and together imply that the problem of checking whether a proof space proves the correctness of every trace of a program can be reduced to the language inclusion problem for predicate automata the following proposition reduces the problem further to the emptiness problem for predicate automata noting that is equivalent to proposition predicate automata languages are closed under intersection and complement proof the constructions for intersection and of predicate automata follow the classical ones for alternating finite automata let a and a be we form their intersection a a by taking the vocabulary to be the disjoint union of the of a and a and define the transition relation and accepting predicates accordingly the initial formula is obtained by the initial formulas of a and a given a pa a q ar start f we form its complement a q ar start f as follows we define the vocabulary q ar to be a copy of q ar q q q q and the set of accepting predicate symbols is the set of predicate symbols from a f q q q q f for any formula in fq ar we use to denote the de of defined recursively by ­ qi qi ­ i j i j and i j i j ­ and we define the transition function and initial formula of a by de q q and the initial formula is start checking emptiness for predicate automata in this section we give a for checking pa emptiness which is sound when the procedure terminates it gives the correct answer and complete for counterexamples if the pa accepts a word the procedure terminates our procedure for checking pa language emptiness is a variant of the algorithm for transition systems cf the algorithm is essentially a exploration of a predicate automaton starting from an initial configuration searching for a reachable accepting configuration but with one crucial improvement we the state space with a covering preorder and the search space by removing all of those configurations which are not minimal with respect to this order the key insight behind the development of transition systems is that if the order satisfies certain conditions namely it is a order this pruning strategy is sufficient to ensure termination of the search ie although the search space may be infinite the search space is finite a order is a preorder such that for any infinite sequence there exists i j such that xi xj we begin by defining the covering relation on pa configurations definition covering given a pa a q ar start f we define the covering preorder on the configurations of a as follows if c and c are configurations of a then c c c covers c if there is a permutation n n such that for all q q and all qi c we have qi c the idea behind the pruning strategy is that if two configurations c and c are both in the search space and c c then we may remove c the correctness of this strategy relies on the fact that if c c and an accepting configuration is reachable from c then an accepting configuration is reachable from c and thus if an accepting configuration is reachable then an accepting configuration is reachable without going through c this fact follows from a compatibility lemma lemma compatibility let a be a pa and let c and c be configurations of a such that c c then we have the following if c is accepting then c is accepting for any j × n if we have c j c then there exists a configuration c and an index k n such that c k c and c c we now develop our algorithm in more detail in the remainder of this section let us fix a predicate automaton a q ar start f exploration of pa is complicated by the fact that the alphabet is infinite and therefore are infinitely branching although for a fixed letter each configuration has only finitely many successors the key to solving this problem is that all but finitely many i n are from the perspective of a given configuration c with this in mind let us define the support of a configuration c to be the set of all indices which appear in c formally ir qi c r intuitively if i j then i and j are effectively starting from c this intuition is formalized in the following lemma lemma let c be a configuration k k n and for all configurations c such that c k c there exists a configuration c such that c k c and c c and c c as a result of this lemma from a given configuration c it is sufficient to explore i such that i plus one additional j in our algorithm we simply choose the additional j to be more than the maximum index in finally we state our procedure for pa emptiness in algorithm this algorithm operates by expanding a reachability forest n e where the nodes n are configurations and the edges e are labeled by indexed letters the frontier of the reachability tree is kept in a worklist worklist and the set of closed nodes configurations which have already been expanded is kept in closed theorem algorithm is sound and is complete for non emptiness given a predicate automaton a if algorithm returns empty then la is and if la is nonempty then algorithm returns a word in la input predicate automaton a q start f output empty if la is empty a word w la if not closed n e worklist while worklist do c worklist if closed st c c then expand c foreach i max do foreach do foreach c st c i c and c n do n n c e e c i c if c is accepting then return word w labeling the path in the graph n e from c to a root else worklist worklist c end end end end end closed closed c end return empty algorithm emptiness check for predicate automata decidability results although algorithm is sound and complete for it is not complete for emptiness algorithm may fail to terminate in the case that the language of the input pa is empty in fact this must be the case for any algorithm because pa emptiness is undecidable in the general case proposition general pa emptiness is undecidable proof the idea behind the proof is to reduce the halting problem for machines to the problem of deciding emptiness of a predicate automaton the reduction uses two binary predicates ln and ln to encode the value of the two counters for example a configuration ln ln ln ln encodes that the value of counter is while the value of counter is ie the value of counter i corresponds to the length of the chain the challenging part of this construction is to encode but we omit this technical discussion from the paper monadic predicate automata since pa emptiness is undecidable in general it is interesting to consider subclasses where it is decidable we say that a predicate automaton a q ar start f is monadic if for all q q we have the following proposition algorithm terminates for monadic predicate automata ie emptiness is decidable for the class of monadic predicate automata and algorithm is a decision procedure proof a sufficient but not necessary condition for algorithm to terminate is if is a order this is a standard result from transition systems the fact that is a order on configurations of monadic predicate automata follows easily from lemma the fact that algorithm is a decision procedure for the emptiness problem for monadic predicate automata follows from theorem and the fact that it terminates the pa for a program proposition always corresponds to a monadic pa a finitely generated proof space h fails to be monadic ie correspond to a monadic pa exactly when one of the basic hoare triples which generates it i has a postcondition which relates the local variables of two or more threads together for example an assertion of the form x y monadic pa have a conceptual correspondence to proofs which also assertions which relate the local variables of different threads indeed if there exists a proof for a program then there exists a monadic proof space ie a proof space which corresponds to a monadic pa this correspondence is not exact however monadic proof spaces are strictly more powerful than proofs in particular one can show that any correct boolean or program has a proof space which corresponds to a monadic proof space to see why consider that the transition function of a boolean program corresponds to a finite set of hoare triples discussion decidability beyond monadic predicate automata note that the converse of proposition is not true ie proofs do not necessarily cause algorithm to diverge for example the proof of the thread program from section is not monadic for example the assertion end c is and yet algorithm terminates for this example we will informally discuss some other classes for which algorithm terminates we can generalize the monadic condition in a number of different ways while maintaining termination one such generalization is effectively monadic pa where there is a finite set of indices d n such that in any reachable minimal with respect to configuration c for all qi in we have at most one of i in not in d intuitively effectively monadic can be used to reason about programs where one or more processes play a distinguished role eg a program where there is a single distinguished server but arbitrarily many clients another alternative is pa where there exists some bound k such that in any reachable minimal with respect to configuration c the cardinality of the set qi in c is less than k the thread example from section is with a bound of intuitively can be used to reason about programs which do not require unbounded chains of relationships there is a great deal of research on proving that classes of systems are ordered which can be adapted to the setting of predicate automata for example we may admit a single binary predicate which forms a total order relation by lemma or a tree by tree theorem meyer showed in that processes are ordered which implies that for processes of known depth the covering problem can be decided using a standard backward algorithm for intuitively the covering problem whether a system can reach a configuration that contains some process that is this assumes that every command of the program is deterministic but this is without loss of generality because for boolean programs it is always possible to replace nondeterministic commands eg b with a nondeterministic branch between deterministic commands eg b and b in a local error state the question whether the covering problem is decidable for the entire class of processes was later addressed in where an adequate domain of limits was developed for transition systems that are induced by processes and consequently the existence of a forward algorithm for deciding the covering problem was demonstrated completeness of pa in this section we the relative completeness result from section theorem establishes that any proof for a program p corresponds to a finitely generate proof space h which covers the traces of p but given our earlier undecidability result proposition there is cause for concern that although we can construct a basis h for h there may be no way to validate that it covers the traces of a program in this section we introduce emptiness certificates for pa and complete the picture by showing that we can construct an emptiness certificate for ap ah definition let a q ar start f be a pa an emptiness certificate for a is a formula fq ar which may additionally have arbitrary quantification of thread variables such that · start · for all c c i such that c and c i c we have c · every model of is an emptiness certificate can be seen as a kind of inductive invariant which shows that the language of a given predicate automaton is empty the following proposition establishes that emptiness certificates can be viewed as proofs that the language of a given predicate automaton is empty proposition let a be a pa such that there exists an emptiness certificate for a then la finally we can state a strengthening of the completeness result from section not only do proofs correspond to finitely generated proof spaces but they correspond to proof spaces proposition pa completeness let p be a program if there is an proof of correctness for p then there is a proof space h which covers the traces of p and there is an emptiness certificate for the predicate automaton ap ah proof we continue from the point started in the proof of theorem we let p be a program inv be an invariant of the form inv i i loc i j i j and let h be as in theorem we must construct an emptiness certificate for the automaton ap ah recall that the vocabulary of ap ah consists of the vocabulary of ap along with the vocabulary of ah that is the set of predicate symbols is err loc for any loc we use i as shorthand for i loc the following formula which we call inv is such an emptiness certificate loc i i i loc i ji j i j i j err false the conditions of definition can easily be checked the intuition behind this emptiness certificate comes from the observation that the negation of a inductive invariant is a backwards inductive invariant verification algorithm in this section we outline a verification algorithm based on the automatic construction of proof spaces and then discuss how the algorithm can be using various heuristics known and some perhaps yet to be discovered keep in mind that our aim in this section is not the presentation andor evaluation of such heuristics but rather to place proof spaces in their algorithmic context and to discuss some of the interesting research problems which are by this specific algorithmic context the highlevel verification procedure based on proof spaces is given in algorithm it is essentially a variation of a standard counterexample abstraction refinement cegar loop is a procedure that computes a finite set of basic hoare triples such that true false belongs to the proof space generated by one straightforward implementation of is to use sequence interpolation given a trace i · · · n in we may use sequence interpolation to compute a sequence of intermediate assertions n such that true n false and for every j n the hoare triple j j ij j is valid we may then take the to be the set of all such hoare triple j j ij j algorithm takes as input a program p and if it terminates returns either a counterexample showing that the error location of p is reachable or a basis h of a proof space which proves the correctness of p the algorithm operates by repeatedly sampling error traces of p for which true false is not in the proof space generated by h if is feasible then the program is incorrect and the counterexample is returned otherwise we add the hoare triples from to h if we are unable to sample a trace for which true false is not in the proof space generated by h then h is a basis for a proof space which proves the correctness of p and we return h the highlevel properties of this algorithm are summarized in the following theorem theorem algorithm is sound and is complete for counter examples given a program p if algorithm returns safe then err is unreachable if err is reachable then algorithm returns a feasible trace which reaches err discussion there is a great deal of flexibility in the design choices of the procedure let us discuss some of the design considerations and directions for future research concerning the construction of a proof space from a trace an abstract procedure can be viewed to include these two steps technically speaking these triples may not satisfy condition of definition so we must define to be the set of all j false j ij j false construct program automaton ap h basis for a proof space while ap ah do select from ap ah algorithm algorithm if is feasible then return counterexample else h h end end return proof h algorithm construct a program p such that p the input trace in the sense that is an error trace of p and true p false and construct a proof of correctness for p decompose the proof from step to get a finite set of basic hoare triples step can be replaced by a variety of different algorithms the straightforward algorithm we suggested above ie sequence interpolants is one option one can also view step to be implemented as a refinement loop in the sense that an approximation is constructed and if a proof of correctness cannot be constructed for it it is refined until a proof can be found there are an array of known techniques that lie in the middle of the from the sequence interpolants for the trace where we take p to a fully generalized refinement construction of the generalization of the trace where p is the most general provably correct program containing for example path programs can be used to restore some of the looping structure from p in order to take advantage of sequential loop invariant generation techniques bounded programs are another category of suitable candidates for p where a concurrent underapproximation of p is constructed through a correctness proof for the bounded program can then be constructed using techniques for concurrent program verification step decomposition of the proof is more subtle than it might seem in particular the requirement that preconditions of basic hoare triples may contain only relevant threads condition of definition may be difficult to enforce an interesting feature of the sequence interpolation procedure outlined above is that the requirement follows immediately from the properties of interpolants but in general it may be necessary to develop nontrivial algorithms for a proof into basic hoare triples an interesting alternative to step is to consider the problem of constructing basic hoare triples directly rather than to extract them from an existing proof for example one possibility is to design an interpolation procedure which yields monadic proof spaces perhaps techniques from tree interpolation related work there is a body of work on analysis and verification of concurrent programs in this section we limit ourselves to the substantial body of work on verification of programs with unbounded parallelism below we provide some context for our work in this paper and compare with the most related work unbounded parallelism and unbounded memory the proof checking procedure presented in section can be viewed as a kind of pre analysis using the proof space which may be of predicate abstraction there are two particular approaches to predicate abstraction for programs with unbounded parallelism and unbounded memory which are related to ours indexed predicate abstraction and dual reference programs indexed predicate abstraction allow predicates to have free thread variables eg xi with the goal of computing an invariant ie a universally quantified invariant of a fixed quantifier depth free thread variables allows indexed predicates to be combined under the quantifier and thus compute complex quantified invariants from simple components in view of the symmetry closure condition of proof spaces indexed predicates serve a similar function to our ground hoare triples and our use of combinatorial generalization shares the goal of to compute complex invariants from simple components uses a theorem prover to reason about universal quantifiers and program data simultaneously and determines an invariant for a program by computing the least fixpoint in a finite abstract domain determined by a set of indexed predicates our technique does not require a theorem prover which supports universal quantifiers or heuristics for quantifier instantiation and the predicate automata inclusion check algorithm based on the algorithm for transition systems replaces the abstract fixpoint computation the separation between reasoning about data and thread quantification provides a fresh perspective on what exactly makes reasoning about unbounded parallelism difficult and enables us to state and prove results such as the decidability of the monadic case ie proposition which has no obvious analogue in the setting of dual reference programs allow two types of predicates predicates mixed assertions in the terminology in which refer to and the of one thread and predicates which refer to and the of two threads where one thread is universally quantified eg xj although dual reference programs are not necessarily transition systems shows that it is always possible to convert a dual reference program obtained from an asynchronous program via predicate abstraction to a in contrast with our technique is complete relative to invariants moreover we are able to use standard techniques from sequential verification to compute refinement predicates whereas it is less clear how to automatically generate their predicates that are of the form l lp where l is the local variable of a distinct active thread and lp stand for a local variable of all passive threads and therefore the predicates are universally quantified model checking modulo theories is a general method for proving safety of systems which generalize finitestate parameterized systems the algorithm is essentially a pre computation which techniques from transition systems to guarantee termination for a subclass of systems which can be expressed in ordered theories this is similar in spirit to the proof checking algorithm presented in section and the covering relation defined in is similar to definition in is combined with abstraction which in some practical cases terminates when the algorithm does not perhaps the most difference between our approach and is that we separate the verification problem into two constructing a proof space and checking the adequacy of the proof space there is some work on automated invariant generation for programs where the number of threads and memory are unbounded these methods generally differ from ours in that they compute inductive invariants and are not property driven in starting with a set of candidate invariants assertions the approach builds a reflective abstraction from which invariants of the concrete system are obtained in a fixpoint process the number of quantifiers used in the invariants is a parameter of the abstract domain that needs to be fixed a priori in data flow graphs are used to compute invariants of concurrent programs with many threads their abstraction is not expressive enough to capture relations between local variables and global variables or local variables of other threads in a language of recursively defined formulas about arrays of variables suitable for specifying safety properties of parameterized systems is used their main contribution is a proof method for implications between such formulas which the implementation of an abstract interpreter their effort was in the direction of proving entailment between complex formulas our effort is to avoid them the problem of proving data structure invariants for programs with many threads is in and aims to exploit in their proofs which restricts the ways in which threadlocal variables may be for the practical gain of a faster analysis additional can be captured using the technique of in which a universally quantified environment assertion is used to keep track of relationships between a distinguished thread and all other threads unbounded parallelism and bounded memory in a case between unbounded and bounded data is investigated where shared variables range over unbounded domain of but the local states of processes are finite ie local variables of threads range over finite domains there has been a great deal of work in the area of automated verification and analysis of concurrent programs where the number of threads is unbounded but the threads are finitestate we skip a detailed discussion of the of techniques in this area as they are not as closely related to our technique in the sense that they are limited to finitestate threads automata on infinite alphabets one of the main contributions of this paper is a method for determining whether the language of error traces of some program p are included inside the set language of correct traces proved by some proof space h classical techniques cannot directly be applied because the alphabet of program commands is infinite however the automata community has developed of automata to infinite alphabets the most relevant to our work is alternating register automata which are closely related to predicate automata register automata were first introduced in for register automata was shown to be undecidable in which implies emptiness is undecidable in the general case however the emptiness problem for with register cf monadic predicate automata was proved to be decidable in by reduction to reachability for counter machines and a direct proof based on transition systems was later presented in program verification the method presented in this paper is inspired by the approach to program correctness proposed in notably this approach has also been used in the context of concurrent programs with a fixed number of threads and concurrent programs with many threads one fundamental difference between our approach and previous techniques is that in a finite set of program statements and therefore a finite alphabet was used in counting proofs were presented as a method for automatically synthesizing auxiliary variables in complex counting arguments for parameterized protocols counting proofs ie proofs that use auxiliary counters are not expressible as proof spaces without the use of these auxiliary variables on the other hand proof spaces are capable of proving properties of programs which involve reasoning about local variables which is beyond the counting proofs framework it will be interesting to investigate whether the of the counting proofs and proof spaces can be combined into a single framework conclusion we conclude with a discussion of our work in a context and with an to future work abstract interpretation from the perspective of abstract interpretation proof spaces introduce a new class of abstract transformers for multithreaded programs we will here only sketch the details of a formalization of proof spaces in the abstract interpretation framework the main part of the pa emptiness algorithm algorithm applied to the predicate automaton ap ah for the program p and the basis h of a proof space iterates an abstraction of the of the transition function the corresponding abstract domain is the free lattice generated by the set consisting of the of the assertions that are used in the basis h and the set of control assertions the fact that the lattice is free ie ignores the logical meaning of assertions our calling the abstract fixpoint computation combinatorial the definition of the abstract transformer can be inferred from the definition of the transition function of the predicate automaton in contrast to work on software model checking for unbounded parallelism we have not abstraction as a transformation ie a mapping of a program into another one instead we have taken the more general approach of abstract interpretation which is to define an abstraction through a mapping of a function over a domain into another one symbolic vs combinatorial reasoning in program verification there is a of the problem of proving that a program satisfies a property of interest into two finding a simplified model of the program which simulates it and verifying that the property holds in the model the first is a symbolic problem which requires reasoning about the programs often data theory eg integers and the second is combinatorial problem over a possibly very large finite state space a classical example of this is the slam tool which computes a recursive boolean program which abstracts a given program using a finite set of predicates generated via symbolic reasoning and then verifies the boolean program using cfl reachability a combinatorial algorithm proof spaces achieve a similar separation between symbolic and combinatorial reasoning symbolic reasoning is required to construct the basis of a proof space and then checking whether every error trace can be proved infeasible using the sequencing symmetry and conjunction rules is a combinatorial problem from this point of view our algorithm for predicate automaton emptiness serves a role which is analogous to cfl reachability in slam it is interesting to note that unlike cfl reachability the emptiness problem for general predicate automata is undecidable there is a body of work on other combinatorial verification problems to serve as targets for multithreaded programs but none are complete in the sense of section thus our work reflects a fundamental between completeness and decidability in the setting of unbounded parallelism which does not exist for sequential programs or even multithreaded programs with a fixed number of threads unbounded vs infinite the number of threads which in an error trace of a multithreaded program is unbounded rather than infinite this enables proof spaces to use conjunction and symmetry in place of universal thread quantification and thus avoid the problem of directly synthesizing quantifiers one may view using universal quantification to reason about unbounded threads as in proof system as a because an entailment is only provable in first order logic if it holds for all models including models which have an infinite universe of threads for termination and liveness properties one needs to reason about infinite traces this creates the need to distinguish between programs with many threads eg computations which are over a number of processes which is determined at run time and programs with infinitely many threads eg programs with dynamic thread creation which spawn infinitely many threads over an infinite execution in the setting of unbounded parallelism then even if a trace is infinite it can involve only finitely many threads thus it may in principle be possible to extend proof spaces to termination and liveness properties this is a topic of future work references a chen and ahmed constrained monotonic abstraction a cegar for parameterized verification in concur pages ­ a c and general decidability theorems for systems in lics pages ­ and lazy abstraction with interpolants for arrays in pages ­ a proving assertions about parallel programs j comput syst sci ­ february berdine tal g and sagiv thread quantification for concurrent shape analysis in cav pages ­ thomas a henzinger majumdar and rybalchenko path invariants in pldi pages ­ ahmed and regular model checking in cav pages ­ a and l on equations for regular languages finite automata and sequential networks theoretical computer science ­ k c kozen and j alternation j acm ­ january and extending proof tree preserving interpolation to sequences and trees in workshop on smt solving and ltl with the quantifier and register automata acm trans comput logic ­ april f daniel michael and thomas counterexampleguided abstraction refinement for symmetric concurrent programs formal methods in system design ­ and verification of parameterized concurrent programs by modular reasoning about data and control in popl pages ­ and podelski inductive data flow graphs in popl pages ­ and podelski proofs that count in popl pages ­ diego alternating register automata on finite words and trees logical methods in computer science a generalization of the procedure of and to well structured transition systems in icalp pages ­ and transition systems everywhere theoretical computer science ­ flanagan n and qadeer verification for programs in esop pages ­ and towards smt model checking of systems in pages ­ matthias and podelski refinement of trace abstraction in sas pages ­ thomas a henzinger jhala majumdar and l abstractions from proofs in popl pages ­ and andrew e recursive abstractions for parameterized systems in fm pages ­ daniel and thomas dynamic detection in parameterized concurrent programs in cav pages ­ daniel and thomas lost in abstraction monotonicity in multithreaded programs in concur pages ­ michael and automata theor comput sci ­ november la and modelchecking parameterized concurrent programs using linear interfaces in cav pages ­ k and e predicate abstraction with indexed predicates acm trans comput logic december cartesian abstraction and verification of multithreaded programs phd thesis university of meyer on in depth in the picalculus in ifip pages ­ s symmetry and completeness in the analysis of parameterized systems in pages ­ frank thomas and finite state machines for strings over infinite alphabets acm trans comput logic ­ july pnueli and d automatic deductive verification with invariants in tacas pages ­ thomas w reps horwitz and sagiv precise interprocedural dataflow analysis via graph reachability in popl pages ­ de concurrency verification introduction to compositional and methods cambridge university press cambridge and invariant generation for parametrized systems using in sas pages ­ springer tal and sagiv abstract transformers for thread analysis in pages ­ and wang on interference abstractions in popl pages ­ thomas and thomas a henzinger forward analysis of processes in pages ­ 
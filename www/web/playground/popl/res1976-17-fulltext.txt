verifying formal specifications of synchronous processes p and j h center for research in computing technology university cambridge massachusetts abstract is an automatic programming system for the synthesis of solutions to problems of synchronization among concurrent processes from specifications written in a high level assertion language the correctness of the solutions constructed by follows from the soundness of the synthesizer itself and from a verification phase which is applied to the specifications this verification phase is the main topic of this paper to provide context for the verification the paper includes a discussion of synchronization problems and a brief overview of both the system and the specification language a formal definition of the correctness of a specification is then presented along with algorithms which may be used to determine if a given specification is correct i introduction this paper describes some of our recent work in the area of automatic programming while this area has been defined in many ways we view it as a collection of tools methods and techniques for fast production of reliable software automatic programming attempts to put more of the burden of software production and reliability upon the machine or software production system and less upon the programmer or user these are similar to those that led to the development of high level programming languages as a replacement for assembly languages then as now the is to produce software which does as much work as possible for the programmer we are specifically concerned with developing approaches and techniques that advance toward the goal of constructing general purpose automatic programming systems here we begin work on some of this goal through the construction of such a system for a specific problem domain the value of this effort is in addition to examining and directions for eventual more general systems we have constructed an operational system for a nontrivial problem domain thus we present an existence proof that many of the problems can be simplified and by a choice of problem domain and by careful system design the problem domain chosen is the synchronization of systems of concurrent processes conventional approaches have made the description and solution of such problems quite difficult our system these difficulties by synchronization at a level close to a human conceptual model of such problems the design and construction of the system involves three areas of automatic programming very high level languages program synthesis and program verification traditionally the main efforts in automatic programming have been in the area of verification automatic or formulate and prove theorems about logical formulae which are assertions or verification conditions about programs from the resulting proofs programs can be extracted to satisfy the theorems proven thus synthesis of programs was originally based on verification approaches synthesis and verification as separate issues a very high level specification language is formulated in which synchronization problems can be described in a highlevel formal yet way is an extension of the language using data operator and control extension facilities is itself written in as well it is this research was supported in part by the advanced research projects under contract fc and by ibm under an ibm grant current address ibm research laboratory san california current address computer science division university of california at berkeley berkeley california this specification language together with knowledge which provides sufficient information to facilitate the synthesis and verification of solutions to the described problems the synthesis and verification can be done independently synthesis therefore is from its dependence on verification and from the limitations of theorem provers in this paper we will be concerned primarily with the verification phase of however we must first provide both context and motivation for the verification techniques in sections and we discuss the nature of synchronization problems and previous techniques for their description and solution sections and give an overview of and a brief discussion of the points of the specification language sections and define specification verification section discusses the algorithms used by the verification phase section discusses extensions to these techniques synchronization problems the basic unit of in synchronization problems is the process et al describe a process as the smallest entity that can be scheduled for independent execution one can a process as a program plus a data environment and a control environment together with enough status information eg a program counter a set of interrupts enabled or etc so that the process can be executed a processor is the active agent it executes a process throughout this paper it is assumed that there exist a fixed number of processors available for the simultaneous evaluation of processes the processors are over the processes in order to that each process receives some share of processor time however no assumptions are made about the allocation of processor time because the is transparent to the processes in any given process an arbitrary amount of time may pass between the execution of one instruction and the next consequently without some mechanism for coordination communication between processes such as sharing a resource would be quite the possibility of interference between systems of concurrent processes characterizes what we call synchronization problems such systems are characterized by two or more processes running concurrently on the same or different machines which share some data or resources these processes are mainly asynchronous usually they are operating independently on their own computations however they need to access shared data or resources or to make with each other we can describe several typical kinds of synchronization problems i mutual exclusion problems these problems occur when processes want exclusive access to a resource examples of such resources are line or disk files needed for output the concept of processes mutually each other from resource access extends to program code as well it is the case that processes have sections of code called critical sections which contain operations on shared data which are to be performed without interference from other processes that is these critical sections must be evaluated with respect to other processes consequently no more than one process at a time should be evaluating its critical section shared access mutual exclusion problems generalize to requests for multiple yet still restricted access in this type of problem resource access is not restricted to one process at a time instead several processes of special types or in limited numbers may be permitted simultaneous access an example of such a case is a file which can be accessed by any number of processes which access it on a readonly basis however processes which write on the file are still problems type synchronization problems occur when a process requires simultaneous access to two or more resources these resources cannot in general be acquired one by one and kept until they are all because if the number of resources is limited they may be before any process has filled its requirements thus all processes may be waiting for additional resources none may be able to proceed this situation is known as total deadlock b one way of avoiding this situation is for a process to acquire all its needed resources simultaneously or else wait none of them our knowledge of synchronization problems is quite informal we know that processes generally acquire and release resources one by one or if they acquire several at a time they generally later release the same number in a system of synchronous processes processes generally come to some section of code which they must not enter before making some with other processes this code uses resources and the are in the form of obtaining exclusive access waiting for sufficient resources and so on at the end of this section of code processes generally other processes that the restricted access has been lifted before entering this critical section of code a process either obtains access and proceeds or until access can be obtained a process in a synchronous system never interrupts another process and causes it to wait it is characteristic of synchronization problems that if a process can either wait or continue upon to enter a critical section then that waiting is transparent to the process once inside the critical section the state of the world from the viewpoint is the same whether it was delayed and then or whether it directly we call this the delay principle solving synchronization problems many primitive operations have been to implement solutions to synchronization problems one of the original synchronization primitives is semaphore operations which we will consider as a representative example simply a semaphore counts the resource usage its initial value is the initial number of available resources when its value is zero no resources are available and processes resources have to wait the p operation on a semaphore requests the resource the v operation it semaphore operations are ideal for describing very simple synchronization problems they are not however easily to situations of shared data access where for example one type of process has priority over another nor are they easy to use for type synchronization problems par many of the more complex synchronization problems are of these latter two types and other similar types of synchronization primitives do not provide a natural model for human of these kinds of problems it is our view that the human conceptual model of synchronization problems is a person to think not about each of the individual processes but about what happens in the system of processes as a whole the human problem focuses on how the resource be it critical section code disk buffer etc may be accessed this about synchronization problems in terms of states of the entire system with respect to resource access specification of synchronization problems in terms of their solutions with semaphore operations or other lowlevel primitives is inconsistent with such a representation the knowledge about synchronization among the various processes while the human mind of this e in a way in addition are very the gap between the conceptual model in terms of states and the solution in terms of p and v operations in each process is substantial the problem solutions bear little to the problem description in hence in coding solutions to these problems there is a difficult transformation from the human problem to the code these solutions are also difficult to change if an incremental change is made in the problem description such as giving one type of process priority but keeping the rest of the problem the same there is often a change in the p and v solution to the problem this does not reflect our intuition that the translation between and the problem specification and solution should be a continuous function in addition p and v solutions are cast at too low a level for a programmer to all the possible interactions between processes he has difficulty all the possible orderings of events this makes it difficult to write programs to solve synchronization problems and further to prove that such a system of synchronous processes is correct the verification techniques we present are related to those of and and their techniques in turn are based on work by manna and and manna manna formalizes properties of programs executed by a single processor he introduces the choice point which corresponds to the set of instructions from which the processor may select at that point correctness of nondeterministic programs is related to the set of all possible executions of the program on a given input manna and formalize properties of parallel programs in a similar manner a parallel program can be transformed into an equivalent program which when executed chooses one particular interleaving of instructions of the parallel programs from the set of all possible because of the of choice points and thus the number of assertions as well the concept of protected bodies of code those containing no choice points and therefore executed with respect to other processes is introduced extends the and manna techniques he the notion of protected bodies of code and in addition to the choice node he introduces a split node to split a control path previously executed by one processor into two or more paths each executed by its own processor as with the techniques for sequential programs control paths into fragments of code bounded by assertions and proves each piece separately thus the synchronization may be proven correct in the same way as and at the same time as the asynchronous code and present a formal specification approach in which the code involved with synchronization is separated from the asynchronous programs high level abstract entities control access to critical sections of code proving the synchronization correct in this context means proving that these protect critical sections in the desired manner with respect to global however the verification technique is not easily mechanized in addition no implementation of is suggested overview of the system these difficulties have led us to propose an automatic programming approach to solving synchronization problems using this approach a programmer can present his problem description in the way in which he of it he is provided with a very high level specification language synchronization assertion language which provides a natural for describing synchronization problems thus problem specifications can be easily read modified and to others this is not necessarily the case for semaphore solutions of synchronization problems because is a high level for the description of synchronization problems the choice of primitives in which to implement the specifications is from the problem itself this enables such problems to be stated more clearly and the solutions from restrictions the power of allows incremental changes in the problem to be reflected by incremental local changes to the problem description in addition the specifications are formal enough to permit synthesis and verification of programs which solve the specified problem a specification is in the form of an abstract program specification for each type of process in the system this abstract program specification contains a skeleton of program code including calls upon one or more synch functions these synch functions the code for which will be synthesized by provide the only means by which processes may communicate synch functions may be either monitor procedures hoare calls on control interpreter or procedures p and v operations steele both and the verification technique are independent of the choice of synchronization primitives used ie can synthesize synch functions which any of these various sets of lower level primitives synch function calls are with respect to other synch function calls ie all such calls are ordered linearly in time the code for the synch functions is completely independent of the code for the asynchronous computations of the processes we believe that this is a desirable feature for communicating processes it avoids or otherwise arising from processes knowing too much about each others internal computations this kind of and minimization of knowledge follows naturally from the principles of structured programming where procedural encapsulation is intended to minimize the assumptions one component makes about another if we consider the system of processes to be in one of several distinct global states and synch functions are the only means of communication between processes then only execution of synch functions may cause a change of state for synchronization problems there is usually only a small number of states that the set of communicating processes can be in these global states are most often related to which processes are executing their critical sections provides facilities for describing these global states and for specifying the transitions between these states made by the synch functions the former is achieved using state definition statements the latter is achieved by placing assertions before and after each synch function call invariant assertions which are placed before calls to synch functions consist of a union of global states these states are the ones which are when the process is executing in the code section preceding the call result assertions which are placed after synch function calls specify the effects of the call upon the global state of the system and upon other processes ie indicate the impact of a between processes upon the entire system however the global state resulting from an must be consistent with the following as well as for all other code sections executed concurrently hence restrict the impact of other during the execution of asynchronous code when a synchronization problem description including definition of global states and abstract program skeletons for the process types is input to the system will synthesize code for the synch functions and then apply a verification technique to the to prove them correct the correctness of the code generated for the synch functions follows from the correctness of the synthesizer this may be achieved using standard techniques and will not be discussed further here we are concerned with the verification techniques which are applied to the specifications verifying that a specification is correct means proving that the invariant and result assertions are all mutually consistent if i the system of processes is initially in a state which is consistent with the for the initial code section for all processes and ii there exists no sequence of synch function calls such that the system is put into a is inconsistent with the of the code sections being evaluated concurrently then no will ever be violated since the in essence describe the synchronization desired the specifications have been shown to be correct the specification language the first portion of a problem specification is a set of state definitions of the form name is conjunction of boolean relations on state variables for example null is and o the rest of the specification consists of one or more process type definitions of the form process name does asynchronous code with synch function calls synch function calls occur at the points of with other processes and are intended to provide the appropriate synchronization between processes assertions must be provided before and after each synch function call to describe the actions or the impact that the user expects of these synch functions provides two types of assertions invariant assertions and result assertions which act as pre and postconditions respectively assertions are specified to hold for entire sections of asynchronous code the section preceding the call and they indicate what global states may hold upon the of the call follow each call and indicate the effect on the entire set of processes of having performed that call the effect of a call may be to change the global state of the system and to make processes wait or to cause previously waiting processes to continue when one proves entire sequential programs correct an output assertion is associated with the halting point of the program it is often characteristic of synchronization problems that there is no such halt and corresponding output assertion consequently assertions do not behave as inputoutput assertions for a synch function call we emphasize that assertions are not like hoare assertions hoare in this respect an describes the state of the system after the evaluation of the associated synch function call regardless of whether or not the calling process continues execution to facilitate the presentation of syntax as well as the verification technique we will introduce an example the first readers and writers problem there is a table of data access to which is shared by all processes some processes are writers who require exclusive access to the table others are readers accessing the table on a readonly basis any number of readers may access the table at a time readers may not access the table while a writer has access and vice versa neither type of process has priority when the table becomes available we require two integer state variables the number of readers accessing the table the number of writers accessing the table there are three states of the system null is and writing is and i reading is gt and there are two types of processes readers and writers readers perform the synch functions followed by while writers perform the synch functions then we can now discuss the syntax of invariant and result assertions invariant assertions immediately each synch function call and describe the state of the entire system of processes throughout the evaluation of the preceding code section up to the start of the evaluation of the synch function call the syntax of an invariant assertion is sn where are names of states already defined by the specification the system may be in only one state at a time hence the state definitions are disjoint exactly one of the boolean expressions defining the states is true at a time the meaning of an assertion then is that throughout the asynchronous code preceding the synch function call the state of the system is a member of the specified set of states in our example see appendix the invariant assertion holds throughout the readers critical section while the invariant assertion for the sections is writing reading ie all the states the syntax of result assertions is much richer than that of invariant assertions we will give only a brief description of the syntax here the reader is referred to for greater detail and a more complete description of result assertions are placed immediately after every synch function call they specify the transitions between states of the system to be by the preceding synch function call result assertions consist of a series of separated by the basic format of a result assertion is cond where each is a conditional whose syntax is of the form possible current state next state and control actions we call the possible current state on the left hand side of ÷ the initial state of the conditional we call the next state on the right hand side the final state the semantics of an individual conditional in a result assertion are that if the system state is the initial state the synch function should change the system to the final state performing the control actions specified on the right hand side of the conditional the conditionals of a result assertion are to be considered in order of as in a lisp conditional if the state of the system is not the initial state of then consider cond etc the union of the initial states of the conditionals of a result assertion is equal to the set of states listed in the preceding invariant assertion the control conjuncts wait and proceed on the right hand side of a result assertion conditional are possible control actions which may be specified by a result assertion they indicate whether or not control is to be back to the process performing the synch function call immediately after the call terminates the conjunct proceed may be omitted if wait is not specified proceed is assumed in the last conditional of a result assertion permits the else operator to replace the initial state and then ÷ as syntactic sugar for all the remaining states of the preceding invariant assertion not already explicitly listed in any other conditional in the case that there is only one conditional in the result assertion else may be replaced by always for readability boolean expressions involving the variables of the invariant states may appear on the left hand side of an example is reading and i ÷ null we now present a brief discussion of several other control conjuncts that may appear on the right hand side of a result assertion conditional we define sets of processes called which contain those processes which are required to wait a process may belong to at most one at a time there are three control conjuncts on the right hand side of result assertion conditionals which describe and operations upon them wait in name enters the process performing the synch function call as a member of the set name and prevents it from execution corresponding to this is the conjunct all process type name specifies that all of type process type are to be removed from the name and scheduled for execution execution will begin with the next statement in the waiting process after the synch function call if the in name or name are omitted the name is assumed to be the same as the process type name the third control conjunct related to is all process type name removes all processes of type process type from the name and allows them to their synch function note that does not necessarily cause a process to continue execution beyond the synch function call as the process may again be blocked the purpose of is to make a clear distinction between the actions of the process performing the and the actions of the process being if is used to up a waiting process the process will begin execution at the statement following its synch function call thereby having no to make any changes in the system state or perform any control actions hence any such actions must be performed by the process performing the in general the use of in this fashion would require distribution of a copy of a process result assertion into every conditional where a process of that type might be achieves an equivalent effect in a more modular fashion in that it in effect generates a call on the synch function as a subroutine thus knowledge about the actions of a synch function is and the entire specification becomes easier to write and more concise the result assertion may itself contain conjuncts and nesting of may continue to arbitrary depth in this case or when a sequence of occurs on the right hand side of a conditional a chain of states is created each successive takes as its initial state the state resulting from the previous for some states several actions might be taken with different the conditional specifying this uses the try conjunct or priority set the priority set begins with the keyword try and consists of one try clause followed by an arbitrary number of next clauses each of the try or next clauses will be called a branch of the priority set each branch is considered in turn the branches are listed in order of priority from to lowest the format of a priority set is lhs ÷ right hand side then try if possible next if actions possible next if possible each branch consists of a set of control conjuncts at least one of which is by the words if possible the if possible brackets the control operations which may not necessarily be possible the priority branch found to be possible is the one chosen an example of the use of the priority set would be in the second readers and writers problem where when the table becomes available we grant the use of it to a waiting writer if any if there are no waiting writers then all waiting readers are granted the table thus writers have priority over readers it is sometimes the case that several alternatives for a result assertion conditional are desired with equal priority an example is the first readers and writers problem described above when the table becomes available either one waiting writer or all waiting readers may be granted access and we explicitly do not wish to either process type the conjunct which permits one to specify this is an or conjunct the format of an or conjunct is either or actions or or all branches of an or conjunct are assumed to be possible when an or conjunct is contained in a branch of a priority set however this is no longer true within a priority set all the branches of an or conjunct must be considered and rejected before the next branch of the priority set can be considered informal description of the verification the verification that a given specification is correct is by induction we will explain the proof technique using the first readers and writers problem as an example the specification contains a of the states of the system it also provides a process type description with the order of synch function calls for each type of process which will be in the system of concurrent processes each synch function call is by an invariant assertion and followed by a result assertion since a synch function is in essence defined by these assertions if a synch function is used more than once it must have the same assertions associated with it for each process type definition the verifier constructs an abstract program for each synch function call the abstract program contains four items of information i a code index number representing the asynchronous code preceding the synch function call the set of states specified by the invariant assertion the name of the synch function the result assertion in an internal form we will use the names ci ai fi and r i to refer to the above items respectively the verifier gives the code following the last synch function call in each process description the same index as the code preceding the first synch function call in that description the purpose of this is to help simulate the effect of more than one process of each type running concurrently the first readers and writers problem has the following abstract programs the complete specification appears in the appendix reader ci al null writing reading ri result assertion for c a reading r result assertion for ci writer c a null writing reading r result assertion for c a writing r result assertion for c one may the effect of synch function call as causing a transition from a code section ci to zero or more result code sections depending upon whether the process proceeds or and whether any other processes are or caused to similarly these synch functions make transitions from one state of the system to one of a set of several possible result states depending upon the initial and final states of the conditionals of the corresponding result assertions we can represent these transitions among states and among code sections as a transition table with transitions between ordered pairs of the form state set of code sections the transition table for the first readers and writers problem is given below if the system is currently performing the synch function fi and the state of the system is sj then the resulting transition is one of the ones listed for the ordered pair sj ci there may be several transitions possible depending on which branches of a priority set or or conjunct are used as well as the truth value of the boolean expressions which may occur on the left hand side of a conditional synch function current pair set of result pairs null cl reading c reading cl reading c writing cl empty reading c reading cl null cl null c writing cl c writing e writing c empty reading c empty writing c writing c c reading c c null c a transition table like this may be constructed mechanically from the result assertions corresponding to each synch function call the transition table specifies how each synch function call changes the state of the system and what code sections control will enter as a result of each call if waiting processes become as a result of a or specified by a call then several code sections may be entered simultaneously this is the case for when the system is in state reading and then not only does the reader process continue code c i is entered but a writer is thus the entry in the transition table is writing cl c in a later section we will provide an algorithm for constructing the transition table we will refer to the set of result pairs in the transition table which correspond to a given current ordered pair as the any individual ordered pair in the entry set will be called an entry the first element of an entry will be referred to as while the second will be referred to as in general when control is simultaneously in code sections a state s of the system is if and only if s is a member of the intersection alan where the are the sets of states listed in the invariant assertions corresponding to the code sections c i if this is not true then an invariant assertion has been violated ie control is in some cj but the state of the system s is not a member of aj it is required therefore that for each entry in each of the transition table must be an state for this requirement can easily be checked mechanically this will guarantee that the performance of a synch function call does not immediately change the state of the system to a state which is not in order to show that no result assertions violate any invariant assertions we must prove the following for any situation where a synch function is called the state of the system does not violate the invariant assertion of any code section in which control these code sections include the sections resulting from the transition as well as sections evaluated concurrently with the synch function call thus the state of the system must be for the set of simultaneous code sections this is not the only criterion which must be satisfied however implicit in the assertions are bounds on the number of processes which may be executing a code section concurrently we define a function b on the set of states such that bs returns a set of code sections which may be executed by no more than one process at a time while the system is in state s for the first readers and writers problem the function b is as follows c ie only one writer may access the table at a time we refer to the state of the system plus the set of code sections being evaluated as a system descriptor which we will write s where s is the state and is the set of simultaneous code sections we define a system descriptor s to be legal if and only if i s is an state for this also implies that the intersection of the corresponding to the cs in is nonempty if any c i in bs is also in then no more than one process is evaluating the code section ci in the next section we will present a better representation for system descriptors and describe the induction which will prove that a specification is correct formal description of the verification we now present the formal description of the induction proof necessary to prove that a specification is correct the proof technique is similar to computation induction this induction proves that if the system does not violate any assertions initially then there is no sequence of subsequent synch function calls which will violate any invariant assertions in this section we describe the induction formally and indicate how it also proves that a specification is ie total deadlock as defined by where all processes are blocked we do not detect except by inspection in individual cases whether a given process becomes we first make a number of definitions let c be the set of all code sections c i in a specification let nc denote the cardinality of c the total number of code sections let c denote any arbitrary member of c let s be the all states of the system let s denote any arbitrary member of s let s be a function defined on any code section whose range is an element of the power set of s such that ai m returns the set of states specified by the invariant assertion associated with the code section c i let n denote the set of natural numbers i let f denote the set of functions f such that then fc is a nonnegative integer for any f and any c fc will be used to count the number of processes evaluating c let be the set let sf denote an arbitrary member of we call an element of a system descriptor as noted in the previous section there are certain code sections which may be evaluated by no more than one process at a time these restrictions depend on the state of the system we define a function bs c such that for a given s bs is the set of all code sections which no more than one process at a time may evaluate when the system is in state s we define a set d which is a subset of such that sf is in d if and only if i s is in fc c in bs implies fc s i this set d is a representation of all the legal system descriptors the base step the base step of the induction can now be described let initial be the subset of which consists of all the possible initial system descriptors ie the configurations before any synch function calls are made then the base step of the induction is simply to show that initial is a subset of d the induction step for each c in c we define a function c which describes the actions made by the synch function call following code section c for every c in c d ÷ c where c sf is empty if and only if fc so c is totally defined on d as explained in the previous section a synch function call for a given state s may result in different actions depending on which branch of a try or either clause was performed etc so c sf returns an element of this set is always finite however because the number of conditionals in a result assertion and the number of branches of try and either clauses are always finite now we can define a function such that c in c for a given sf is the set of all possible system descriptors which might result from the occurrence of any synch function call that could be performed at that point in the computation the induction step is to show that sf in d implies is a subset of d we define sf to be a descendant of sf if sf sf or sf is in for some descendant sf of sf if the base step and the induction step are proven then we may infer that if sf is in initial then every descendant sf of sf is in d hence from any initial configuration of the system there is no sequence of synch function calls which causes any invariant assertion to be violated d is constructed from the invariant assertions of the specification together with information about how many processes may be executing a code section at a time ie the definition of the function b the function is constructed from the individual which are constructed from the result assertions the implementation it remains now to show how the sets initial and d can be obtained and how to construct each function the function m and the function b initial can be obtained from the set of states s and the abstract programs for each process type in the system at system initialization the initial state of the system is the null or default state where no resources are in use usually this state is named null then for each process type p some number np of processes of type p are started up by inspection of the abstract program for processes of type p it can be determined which code section cp is the first code section for processes of type p let z denote the set for all such c p then initial p for all cp in z fc for c in cz for the moment let us assume that the function b is supplied by the user as additional information later we will indicate how the verification system can help with the construction of b the definition of the function m is clear for each code section ci mc i returns ai the set of states specified by the invariant assertion which holds for c i from these sets and functions d can be constructed actually d is almost always an infinite set even with the restrictions on f made by b because for cs not contained in bs for any s fc can be any nonnegative integer thus there are an infinite set of such fs for each unrestricted c consequently the set d cannot be in a finite number of steps if d were finite then we could take each element sf in d and check if is a subset of d then the induction step of the verification would be proven and would terminate in a finite number of steps by the construction of the set d and the definition of each it is clear that the relevant values of any fc are i and or more i fc this corresponds to no processes evaluating code section c this corresponds to exactly one process evaluating code section e fc this corresponds to two or more processes evaluating code section c this the definition of three equivalence classes of the values of fc for each c in c we define the relation c as follows sf sf if and only if ss and c where gn n is a function such that go o g gn for n we can now define the equivalence relation such that sf sf if and only if for all c in c sf c sf with this equivalence relation d is partitioned into a finite number of elements thus the induction step of the verification can be proven by examining only the elements of the partition of d induced by there are at most such elements of the partition where nc is the cardinality of c and ns is the cardinality of s this is a finite set and hence the induction step of the verification can be proven in a finite number of steps with this technique deadlock can also easily be detected by the definition of d there are no elements sf of d such that f is zero this is because sf in d implies s in which is empty if fc for every c consequently if every descendant of any element f c of d is also in d the solution is free from total deadlock in order to compute for any sf in d we need to compute for each c in c c is determined from the transition table which is constructed from the result assertions of the specification we now present the algorithm for constructing the transition table then we will describe how to construct each c from the table the transition table the transition table describes for each code section c in c and for each state s in s how the synch function call following code section c affects both the state of the system and the set of simultaneous code sections the transition table is constructed from the result assertions of the specification together with the abstract program produced for each process type an abstract program is constructed for each process type from the specification code of the form asynchronous code assert synch function call assert every piece of is abstracted to a code index ci a set of states for the invariant assertion ai a synch function fi and a result assertion r i the entries in the transition table are formed from of the conditionals of each result assertion one row in the table is constructed for each sci pair where s ranges over all the states in the corresponding a i for every state s in ai the result column of the transition table represents all the actions specified by all the conditionals whose initial state is s in the result assertion r i sometimes there are several such conditionals in ri each with different boolean expressions thus there may be multiple entries for each sci line in the table in addition each branch of a try or either clause causes another entry to the sci line in the table for example sl ÷ s then try b next b next bn creates n entries in the transition table one for each of the branches bj either constructs are treated similarly each individual result pair in the consists of two parts i a state which the system may be in after the completion of the synch function call a list of code sections where control will be as a result of the synch function call this is empty when the process performing the synch function call must and no other processes are or caused to although the system is actually in only one state at a time it may not be decidable when constructing the transition table which state this is for example for code section ci if the result assertion is and ki ÷ si and k ÷ the part of the transition table has two entries c and c actually the system will be either in state or in state depending upon the value of k when the synch function call is made statically however the only information that can be is the entries c and c so if for a given c i the result assertion r i has multiple conditionals for a given state s then the line of the table consists of one entry for each conditional with initial state s let us now consider how to construct an individual entry for a given c i and s and a given set of branches of try and either clauses this the set of conjuncts to be considered on the rhs of a conditional to be rhs state and proceed initially and are both empty if the conditional proceeds ie does not wait then the next code index in the list of abstract program code described above for that process should be included in let us refer to this index as cj in most cases if the conditional remains unchanged if there are no conjuncts on the right hand side of the conditional then is the rhs state of the conditional for example if the conditional is s s and proceed n the entry is sn cj where cj is the next code section index in the abstract program if one or more conjuncts appear on the right hand side of the conditional one code index for each conjunct is added to this is the code index which follows the synch function call which caused a process of that type to wait the remaining conjunct to consider is this affects both parts of a transition table entry recall that a process the synch function which caused it to wait the process takes as its initial state the final state of the conditional specifying consequently the state of the system upon completion of the synch function call may not necessarily be that final state in addition if the process eventually proceeds the code section following the synch function call which caused the process to wait should be added to to construct an entry for sc i when one of the conditionals conjuncts is a one first constructs the entry for that conditional without considering any this results in a set of one or more result pair entries then for each such entry e apply the following procedure to the synch function of the process let c denote the code section which corresponds to the synch function of the process replace e by the obtained by for each entry e from the result pairs to i let be let be this results in some new set of sci entries if there is another in the sci conditional above then this procedure is applied to each entry e in this new set of sci entries for the synch function which caused this next process to wait in general a process may in turn another process and so on this creates a transitive closure problem of the chain of references to sc i entries if this chain of references has a minimal element one which does not make a further reference then the corresponding transition table entries can be completed otherwise the chain of references is strongly connected tarjan describes an algorithm which detects if the chain of is strongly connected then this means a process eventually tries to itself or a process identical to itself in these cases another method must be found for the transition table after which this verification technique may be applied once the transition table entries have been completed by performing the transitive closure of all chains of we can construct the functions c the construction of the transition table from the result assertions is completely with the exception of the transition table in the case of a strongly connected chain of the function once the transition table is completed it is easy to construct each and therefore the function as well the transition table contains entries for each c in c and each s in mc the transition table may have several entries for each such c and s and each entry has two parts and then for each c and each sf in d c sf is empty if fc otherwise fc i for all entries e in the transition table for sc where fe is the function in f such that i and for each c i in fc i i example the first readers and writers problem s c cl c c c synch function current pair null ci reading cl writing cl reading c null c writing c reading c writing c set of result pairs reading c reading c empty reading cl null ci writing cl c writing c empty empty writing c c reading c c null c the function b supplied to the verifier is as follows and c c elements of the partition of d dl d d d d d d d d dl dll d d d d null null null reading reading reading reading reading reading reading reading writing writing writing writing fc i ge i ge ge ge ge i ge fc i ge ge ge ge fc ge i ge i ge i ge ge ge fc i i i i notice that we have this partition for ci and c because the classes i and ge behave equivalently base step initial null ge null ge i null ge i ge clearly initial is a subset of d induction step d dt d d d d dt dl dll d d d all d d all d dl dl we have taken advantage of an optimization here which is described in the following section therefore it was not necessary to apply to a representative element of each equivalence class in the partition of d extensions the verification technique presented above is easily mechanized as it consists of through an enumeration of a finite set the partition of d and applying the function to each representative element of that partition in addition the function b may be generalized in most synchronization problems either an unbounded number of processes are permitted to evaluate a critical section simultaneously or at most one process may be evaluating it a problem could be formulated however in which at most some bounded number greater than i say n processes are permitted to evaluate a critical section simultaneously then b would have to be generalized such that c in bs the verification technique can accommodate this generalization of b without difficulty since n is finite the number of equivalence classes in the partition of d is also finite and thus the verification may be accomplished as above this verification technique can be optimized to avoid having to apply to every representative element of the partition of d let us define a less than relation on functions such that f f if and only if there exists a cl such that and fc fc for then clearly f f implies is a subset of since is a subset of c in c c in c thus for any two representative elements of the partition sf and sf if ff then only sf need be considered i conclusion the verification technique presented here is based on the existence of synch functions to achieve synchronization among concurrent processes synch functions are separate from the asynchronous code of a program this simplifies the correctness proofs of both the synchronization and the asynchronous code because the proofs can be done independently consequently the explosion of program paths to be proven as in the approach is reduced this is achieved without making assumptions that some bodies of code are protected furthermore our technique is easily and is suitable for in an automatic programming system in addition we have several implementations for synch functions including control interpreter monitors and p and v operations this flexibility is achieved because both and the verification technique we use are at a sufficiently high level so as to be independent of the implementation appendix the following is the specification of the first readers and writers problem null is and writing is and reading is gt and reader does begin ÷ else wait code for reading and gt reading if not last reader just continue reading and null then try if possible if last reader waiting writer if any end writer does begin else if table free then go else wait code for writing assert always null then try either if possible or if reader possible exit letting writer or all readers go if any end references e and manna z formalization of properties of parallel programs machine vol e a proving assertions about parallel programs j comp and sys sci i pp w h sequential processes deadlocks and semaphore phd thesis university august p j et al concurrent control with readers i and writers comm acm vol no i october pp dijkstra e w sequential processes in programming languages f ed academic press new york pp r w assigning meanings to programs in mathematical aspects of computer science j t schwartz ed vol math island p a system for the automatic synthesis and verification of synchronous processes proceedings acm p an automatic system for the synthesis and verification of synchronous processes phd thesis university june p a very high level specification language proceedings international symposium on proving and improving programs july hoare hoare c a r an axiomatic basis for computer programming comm acm vol no i october hoare hoare c a r monitors an operating system structuring concept comm acm vol no i october pp r c on deadlock in computer systems phd thesis cornell university january r c some deadlock properties of computer systems symp on sys principles palo alto october karl n the application of techniques to the verification of n processes fall joint computer conference pp manna z the correctness of programs journal of computer and system sciences manna z the correctness of nondeterministic programs artificial intelligence i pp manna z ness s and j inductive methods for proving properties of programs computer science department stanford university p proof of algorithms by general bit pp par d l on a solution to the problem without conditional statements comm acm vol no march pp c j control structures for programming languages phd thesis university may c j extensible control structures sigplan notices vol no pp september l and r c formal specifications for solutions to synchronization problems computer science group park california steele steele g l generation of optimized semaphore synchronization code thesis university may tarjan r depthfirst search and linear graph algorithms siam j comput vol i no june b studies in extensible programming languages phd thesis university may b et al manual ctr for research in comp tech university tr w et al the of a multiprocessor operating system comm acm vol no june pp s procedural encapsulation a protection technique sigplan notices vol no september pp 
threshold evaluation and the semantics of call by value assignment and generic procedures lang france abstract we use the concept of evaluation up to a given threshold of information to generalize the seman tics of call by value and assignment to domains and to define a formal semantics for procedures we then prove the correctness of transformation of iterative programs in to recursive ones provided the same threshold is used for assignment and parameter passing motivation and previous work transformation p se of this work was to establish way when the transformation program recursive one is ie the two programs are strongly the original in a of an strongly correct equivalent a characteristic of this transformation is that it changes assignment into parameter passing since assignment requires evaluation of the expression assigned the parameter passing mechanism has to do the same with the expression passed this usually corresponds to the concept of call by value so a key concept in our work is that of an by considering the partial evaluation of an expression up to a given threshold of information we will generalize the usual concepts of assignment and call by value we will then establish the cor of transformation provided the same threshold is used to evaluate actual parameters and assigned expressions previous work on transformation using call by value was done by strong syntactic approach is limited to dis interpretations ie interpretations in which values are either completely defined or com undefined by interpretations we mean domains with partially defined values eg a pair having only one component defined it is not clear how approach could be to this case more recently ness of the transformation value but for a class of as to be of limited proved the correct using call by interpretations so res practical interest only the programs semantics of call by value we follow here fixed point approach to the semantics of as introduced by scott and developed by many authors use of this type tions imply the mechanism r however the most natural of semantics for recursive use of call by name as parameter the semantics of call in two different by value has so far ways been a the first approach is due to park and re presents functions by their graphs this leads to a fixed point semantics of call by value as naturally as the more direct approach leads to call by name however this representation of functions seems un practical author and defining call by name in this manner is rather complicated de e furthermore this semantics allows only for discrete domains b the second by some extension this was done by only for discrete approach is to define call of the usual call by name de and domains by value approach but domains although the data do used in most languages are te recent developments in research lead more and more to the consideration of domains a higher order languages lisp algol el pop f use functional domains that are not discrete in fact call by value as defined by for lambdacalculus has been given a mathematical semantics by plotkin this work done for functional domains seems ble with ours which is limited to first order but considers arbitrary domains b recent work extending the delay rule of and has led to new lazy interpreters f typically these inter can deal with data structures that are only partially defined thus belonging to a domain c as defined by kahn and macqueen use domains which are sets of possible histories for the communication channels in a mechanism for computing on real num with arbitrary precision is based on the same principles finally the model theory of the pro gramming language deals with infinite car products of discrete domains hence with non discrete domains without to those more advanced con we have simple examples of interesting use of domains such as passing a pair by value for its first component and by name for its second one general notations if a is a set we note o a an and a an the cardinality is the identity a to b is noted of a is noted map on a the ab we note the function set of functions n i a from if x cn then xn e m if f is a function or a function symbol pf is the arity of f number of o the composition of relations then pf or simply arguments we note if is a relation on a then we note la un nl s u in the following or x a set f will generally denote a fi set of function symbols fi and of variable symbols x n vector notation let a be a set we denote by an ith component a function or of a and a function we a an symbol then note if f f a its is an abbreviation for if k is a unary function then is an abbreviation for lan similarly the order relation in a cpo dl is extended as iff however a derivation to aq differently relation on a is ex iff and al by a we denote such that aa jj the ai a closure as defined and not the in l vector of the extension vector relation of the derivation re between single elements of a the substitution is noted r see below orders a partial is a dc where s is an order relation reflexive transitive on the set d let a be a subset of d an of a is an element d of d such that ad two elements d and d of d are noted dd iff dd has no upper bound if a has a least it is noted a or when add a partial order cd is complete iff every subset of d has a least up a subset is iff i a and ii aa has an in a a partial order c is inductive iff i there is a least element noted in d such that ld and ii every directed subset of d has a least the inductive partial order dl an element is iff is noted for every directed complete subset implies we call in short a partial order that is both complete and tive let function d and d s be two partial is monotonic iff orders a when the two orders are inductive continuous iff for every directed subset i the image fa of a by f is a directed subset of d and ii f pa the set of continuous function from d to d is noted implies an order dg is discrete iff i there is a least element in d and ii a discrete order is a cpo a special role will be in this paper by the cpo o lemma let d note a l be a the function cpo in and for every subset d defined by a f ax t if a is a set sa is continuous if otherwise ax of isolated elements of d then or let f n be a finite set of function symbols let d be a set and i a mapping in that preserves we call i an interpretation of f on d we note and f the df is cal led an a morphism of is a mapping from df to which preserves the functions fl ie vf cl the free on a set a is the set of well formed with respect to terms on f and a it is such that for any df any mapping extends uniquely to a morphism noted iv in we call v a and iv a interpretation the interpretation iv associates an element of d to every term in as follows i t ii t f e any g f tions in d d resp d all d of ia ments in d to be considered as an interpretation resp a valuation of lemma d be a cpo and then lt is a continuous functional d from a substitution o is a morphism between two free and since o is ly determined by its value on a we note o sion of those elements s in a for allowing the which u is the the height a term by i or is defined ii tf l compatible derivation derivation relation over is compatible iff relations a a free algebra pf ff lemma if the relation is compatible then i the relations k and are too ii t l generic schemes and programs in order to have a uniform treatment of and rewriting rules in our operational se see we are led to consider a more general concept than that of recursive procedures namely that of generic procedures these are procedures with many bodies the choice of the body at each call depending on some predicate over the parameters usually involving their type eg can be integer addition boolean disjunction or set union depending on arguments types this con was introduced in programming languages such as algol and is by in independently burstall and have developed for their program transformation system a new representation of recursive programs that is similar to the concept of generic program presented here our calling mechanism for a generic procedure includes a set of threshold points in the arguments domain this set is partitioned into subsets each corresponding to a different procedure body actual arguments have to be evaluated up to some hold point before the procedure is called the body chosen is then the one corresponding to the tion that contains the threshold point reached by the partially evaluated arguments generic rewriting systems the concept of generic system introduced will be used later to define the operational here seman tics of generic programs generic systems are a refinement of term systems for every rewriting rule there is an applicability condition val depending on the arguments of the rewritten function symbol this will correspond to the mechanism eg by name by value furthermore the replace ment term of a rule is also on those ar this will correspond to the generic aspect of the programs we want to define this section is systems and the proof property slightly generalized is inspired from defining a notion of parallel it to have the same transitive derivation and proving the for parallel derivation to the definition of ge of their churchrosser the proof and consists in derivation showing closure as the usual churchrosser property definitions a generic systems let d be a set f a finite set of function symbols x a set of va symbols x we define a generic r val where rewriting system as a i ii and such that the axioms ar and ai given below are satisfied for all f in f we abbreviate as pf f as we call writing val and t respectively functions threshold and re b derivation given and af we define derive by a into the above generic system r over the relation noted as the compatible relation such that f c axioms the generic as system axioms can now be ex ar ar those axioms will be by derivation that no performing possible first derivation an inner d parallel derivation given the generic r and we define over the relation parallel by a noted as the relation such that n notation when af we note and respectively and t or properties we now give a few technical lemmas relating and results and which property and in section tion rules are used here to prove the church for generic systems theorem to study the need for in the following a generic over is understood system r proof by induction lemma proof by induction t on lemma t t tt proof by induction on the length from the axioms of parallel wt corollary of the proof derivation of t v tt lemma extension of the axioms to parallel w derivation proof by induction tion on the length k of the lemma proof proofs by induction of tt on the sum of the length and tt corollary of the va t t j proof by induction on ij theorem generic systems are churchrosser t t t t i t t jn proof by generic programs syntax let fn be a set of unknown symbols function x be a set of dummy symbols variable f be a finite set of base function symbols q be a finite symbols set of threshold function a generic scheme g on equations of the form lie pi ei is a set of n sin where p note that at least one symbol is needed in q function e lj x pi the terms p as of the ith generic snd e will be interpreted partition and procedure defined interpretation d lz be a let sd be the set of sets of sequences in d let i he a mapping in we note and the restrictions if and iq of i to f and q are extended into and we define i to be an interpretation for a ge scheme on iff the following two axioms hold ai a j j is a set of jj implies the functions in f and q are respectively base and threshold functions a generic program and i are respectively interpretation to the associate two mappings is a gi where g a generic scheme and an generic program gi we now noted val and t for we define the indexing function qi j where means the unique if it exists and l otherwise j such that p holds note that axiom ai the the function uniqueness ji is of j is guaranteed pi in d rq by the functions and are defined as fo i t if l if ti if i l if we note again val and t for val and t continuity of val t proof axiom ai a function cpo i and lemma imply pi from d to the lemma is an that ji discrete immediate is co intuitively interpretation in order is to evaluate a vector of iz in expressions the passed as has to be first evaluated up to the threshold defined by the points in u i p ij j ie until we have an approximation of the of the arguments such that we then choose the body e iff lj the threshold has been passed at a point a belonging to the threshold set ip from now on we assume given a generic pro gram gi where g is a generic scheme on and i is an interpretation actually we will only use val and without referring tic definition of g on the cpo the associated to d mappings the we will define for a notion of operational a notion of denotational gi semantics semantics and we will then prove their equivalence s operational semantics to the generic program gi we will associate a generic system r on thus de a notion of computation of a term by mean of the derivations in r for every symbol in and t will be first function defined on ip then extended to the mappings parts val and t are built from two a the first in f it i a part corresponds is not constructed machinery that to the base functions from gi but is is provided together with i in order to compute on schemes by i this machinery is of two map and there is of course a requirement that this be coherent with i expressed by the fol axiom as as b the second part is it is the map val and t associated to the generic pro gram gi as defined in s those two parts are merged into and one mapping one mapping in order to get the generic we must now extend val and tv for every to b to we introduce of direct r system r in the concept the direct ut of a term is the best approximation of the tion of t in the interpretation i when the generic scheme g is ignored formally it is the interpretation a where l denotes the function recall xj in rd lo that to may be considered n as a mapping o to we will often note at for at the generic system t associated now defined as i where val above defined extended as to gi and t are follows is the val to t we still have to verify that the axioms and ar are satisfied this lemma and the following is a consequence lemma of lemma a t bt ts at proof by induction on using axiom as we now proceed to define the operational d of he generic program g se definition at at t lemma proof immediate property at is directed from lemma and the church of generic systems therefore can define the for value every term t in t we for every t we define finally we associate to every the func tion the operational value t of a term t is thus defined as the limit ie least of a directed set at unless this limit is ie contained in at no finite tion will ever reach it thus in some sense we are considering infinite computations this is one way to deal with such machines as lazy interpreters that compute possibly te values by computing more tion about them eg the successive elements of a list without ever producing them fully when they are infinite eg infinite lists finite values correspond to isolated points which can only be trivial limits of the domain and are thus always computed in finite time in particular and are always reached in finite are finite values time if at all b simplifications the derivation of a term ft such that is called are in because they correspond to the operation of an actual computing machine for base functions a similar concept be found in one reason to introduce the generic concept is that it can deal with simplifications ie com of base functions as well as with rules corresponding to the evaluation of programs for example the most common base function corresponds to the following tions true t t and we have val t q iff g true tt x and tt x however the use of simplifications that are gi in addition to the interpretation rather than being constructed from it is not very satisfactory we will now show that simplifications are not corollary of lemma a t l at cat b t t t at lemma te proof by induction on the sum of the length two parallel derivation proofs of the lemma tt proof by induction on k using lemma and lemma t t proof by induction on the length k of the tion tt lemma and corollary theorem t t proof by lemma t and c tl and for every term t in we define at t from theorem we see that been using therefore the operational equivalently defined without only derivation on unknown semantics could have simplifications function symbols intuitively simplifications are redundant with the use of direct see lemma however the elimination of direct in of simplifications would not work without let us say that direct are more powerful because they allow us to der incremental increases of information during com and thus to compute infinite values as limits of finite ones denotational semantics we will now use fixedpoint techniques to de fine a denotational semantics for generic programs we refer the reader to for more details about and fixedpoint semantics this type of semantics is usually more tractable in proofs about programs be the ve on given a vec tor j of functions in d d such that and a vector d is ed p since the interpretation i on fixed we can define in a standard way a interpretation p for the terms in we will often abbreviate p even v g when x p to to every i in o we associate the functional pi d defined by if lemma val dl i then t t i else l the proof ai is continuous relies on lemmas and we note thus by lemma we have has a least fixedpoint noted y in the denotational semantics tion symbol ie is then defined of y n v il as tie of a for every term t in ut we define we now prove the equivalence semantics the of operational theorem lemma proof by induction t gk on tt lemma t induction and lemma lemma v proof by lemma and continuity of lemma j rd t t aa t lt proof remark by induction on k ltl this crucial lemma is better understood of the comments at the end of lemma bt tl in lemma such that proof by induction on lemma kl proof by induction on k corollary theorem applications a tf a function has only one body ei and ip l then it is a usual func call by name b if i has one body e and ip il is the set l of of maximal elements in d then we have a recursive call by value function with the usual c we can consider intermediate cases some parameters can be called by name and others by value ­ a parameter can be called ie be required to to some point ple we can have an array only the first two evaluated before passing partially by va be evaluated up in d for exam argument and re elements to be the actual array d with appropriate interpretations see e we a semantics for generic procedure with the possibility of calling the parameters by na me for some bodies and by value for others a problem left open generic considered to call its arguments in in the case of earlier we may wish it by name when it is the boolean disjunction the integer addition and by value when it is e to enable the threshold to perform type checking we can include types in the do main of interpretation eg true false ll i integer boolean list example we consider an interpretation the interpretation of tion symbol is a function set of isolated maximal points point in s then t in the above the threshold func s is the greater than some i integer i ex is interpreted as a generic e g its argument almost we require it to be at least function where by name almost an integer the body because e gets its argument by to be a nonatomic must have value and e requires j list in which only been evaluated its argument the first and transformation in we use threshold evaluation to the concept of assignment in did call by value in recursive programs the of transformation is then in we flowchart programs the defined here are composed of assignment and branching statements and of exit statements returning the results of computations sequencing is done exclusively through labels it is never implicit we will and program define in a standard way the the operational semantics of the original aspect is that in specifies a set el of isolated hold points in the domain d of interpretation can be performed only when the expression has been evaluated up to some point in assigned threshold the threshold set el actually determines the semantics of assignment if o is the set of maximal points in d we have the usual concept of assignment thus corresponding to call by value which requires evaluated the assigned expression for other to be the expression is not always required evaluated when the assignment in particular when q have an to be executed assignment by name as we might want it in a lazy interpreter the port this assignment by name is very assignment used in f to build similar to coroutine networks note that we simplify the following tion by considering just one flowchart rather than a set of flowchart procedures calling each other recursively thus expressions or rather terms are built only from base functions without recursive calls to other procedures flowchart schemes let and f he three finite sets whose ele ments are respectively noted i lin and f and are called and base symbols x registers we define the sets i as is the set of assignments noted ii is the set of branching noted ta iii is the set of exits noted return t iv is the set of statements in the above ment of definitions t denotes some ele we define a mapping d scheme on lx f as a p interpretations let be a ci containing three isolated elements and maximal noted tt ff and that are those elements stand for the boolean values true and false and a special value corresponding to error messages in real computations let i be a mapping in and el a set of isolated elements of d we define the to be an tation for flowchart schemes on the set o is called the set to the set g we associate d defined by a continuous map a then t else l operational semantics from now on we implicitly consider a flow program i composed of a flowchart scheme on lx f and an interpretation p on the domain above d l with the function val as a state is a where v is a va of the registers in x ie a mapping in or equivalently up t isomorphism tor and is in this context let a label be the called set of program states a a register valuation a v together with i iv of the terms in a derivation between states relation as follows noted is i if then vb vl where ie register v is equal to v except for the ith which has taken the value it ii if then v cv that for every state state such that computations ti there is at most one we have deterministic we now define a mapping result as follows ad called i vt if d return t if bt and l otherwise note that if a state is derivable then the result is meaning error when a test is applied to a value for state let an be the set by the above remarks that contains at most to on derivations one element not we see equal so we can define the value flowchart program for some initial computed by the state as note that this limit is always trivial which means that only finite elements of i can be assuming finite of the in n and that base functions give a finite result for finite non termination of computation arguments if the result is it is obtained after a finite derivation steps not num finally to every label our operational in l a function al associates in as fol defining a fixedpoint semantics for flow programs see for example and giving an theorem would be much easier than for ge programs but without real interest for the present work transformation we now study that into an equivalent here the transformation due transforms a flowchart recursive one or to program one we will have to consider only generic func tions with a unique body thus we will ignore the threshold feature that generalizes call by value consequently we will abbreviate the notation of ge equations in schemes by writing simply i ie without the second index cor to different possible bodies the essential point in our presentation of the transformation is that it uses the same hold for the flowchart program and its generic trans form with the usual semantics of assignment this amounts to requiring the use of call by value for the transform vector in this x x section p x will the transformation always denote the given the flowchart program as de in we build a generic program as follows i let i be the set of unknown function symbols ii let be the set of base function sym iii let q be the set of threshold function symbols containing only the symbol n with the arity p iv let the generic scheme g on be the equations such that a n e b k c note that the threshold for all equations term is the v let i be the mapping on defined by a b ix c x lt x if x if otherwise and we define the the transform di generic to be of the flowchart program correctness an operational semantics is defined both the flowchart program and its transform gi that associates for func tions in to every label fl tion symbol co strong correctness formation can thus be expressed by or unknown the trans n achieve however we will not be able to completely this goal indeed for any and if there is an index such that j and but the same hypothesis do not generally imply that b ie the nontermination of the flow computation the reason for this is that a generic function in its actual arguments whereas the flowchart ment for the initial the transform always to be above the does not have this content of registers requires threshold require we could deal with this problem by p times each unknown function with a threshold for each copy to met all initial cases of arguments above or below the threshold this would in general require np unknown function symbols in the generic transform instead of n in practice we may consider that the flowchart is the body of some procedure which is called only if its arguments ie the initial values of the registers are above the threshold hence we will restrict our strong correct ness requirement to the domain the the flowchart each other following lemmas and its generic the correctness and transform theorem show that can simulate follows lemma d vi k implies either tj with and i fj ­ or il and proof by induction on k with and proof with of a is done by induction and on k theorem strong correctness on do cd d we have defined tion in following points a concept of threshold domains and applied it to the uniform treatment name generalizing to the other of call both into by value and call by a from one similar generalization also in a from assignment by name of assignment resulting the usual assignment to an analysis of transformation that rela assignment and parameter passing we showed in particular that as originally described it is on ly weakly correct when applied to the flowchart bo dy of a procedure calling its arguments by name formalization of the concept of generic proce uniform treatment using the generic mechanism of recursive rewriting rules and of simplifications of base functions in the operational semantics of recursive here generic programs the proofs of the lemmas and theorems in this paper will be published in i wish g kahn and sions jj support and to thank my g g huet d for many helpful for constant technical and c le for her typing references d r i a basis for a mathematical of computation in computer formal systems and north holland amsterdam theory and ed r strong translating recursion equations into flow journal of computer and system sciences june b in personal form communication to ap r r no r r r rl r r d scott outline of computation n of a mathematical theory programming research group oxford university z manna and j fix point to the theory of computation of the acm j syntax et language de sim ple these de de paris vii paris see also implementation of recursion in a simple programming language proc th annual acm symposium on computing m on the interpretation of schemes mathematical v xv di italy pp d park fixpoint program properties eds b edinburgh induction and proofs of machine and d edinburgh press pp wp de recursion and an axiomatic approach in automata languages and cd j pp lecture notes in com science vol springerverlag berlin etc de least fixed of symposium on acalculus and science theory pp g des schemas de seman de par cycle paris vii j et al mit e lisp cambridge a van on the algorithmic acts informatica et al language revised algol fast report b et al the programmers manual university center for research in computing technology rn burstall js and rj programming in edinburgh edinburgh university pop press pj expressions the mechanical evaluation computer journal vol of n gd plotkin callbyname callbyvalue and the j cp semantics and pragmatic the lambdacalculus university of oxford of rd pp and j morris jr acm a lazy of prog dp friedman and js not evaluate its arguments on automata languages ming edinburgh cons should proc of rd and program r r r g kahn and d works of parallel publication and net processes submitted for e mit nr and proving programs without improving symp on proving and and kahn ed r r r r r r r ph contributions ment des extensible et au de sa on generic directions in functions languages in new r burstall grams proc and j some trans for recursive pro on cal hp barendregt some extensional term mo for combinatory logics and phd thesis university of jm tial functions phd thesis definitions of par and their computations stanford jn r on transformations j comput system of programs b lang transformations s cycle paris to appear vt 
quantitative abstraction refinement c thomas a henzinger abstract we propose a general framework for abstraction with respect to quantitative properties such as worstcase execution time or power consumption our framework provides a systematic way for counterexample abstraction refinement for quantitative properties the aspect of the framework is that it allows verification that is verification algorithms that can be at any time for example due to of memory and report approximations that improve when the algorithms are given more time we instantiate the framework with a number of quantitative abstractions and refinement schemes which differ in terms of how much quantitative information they keep from the original system we introduce both statebased and quantitative abstractions and we describe conditions that define classes of quantitative properties for which the abstractions provide we give algorithms for evaluating the quantitative properties on the abstract systems we present algorithms for counterexample based refinements for quantitative properties for both statebased and abstractions we perform a case study on worstcase execution time of to evaluate the verification aspect and the quantitative abstractions we proposed categories and subject descriptors d verification general terms theory verification keywords abstraction refinement quantitative analysis introduction the quantitative analysis of systems is importance due to the of embedded systems with requirements on resource consumption and of response quantitative analyses have been proposed for properties such as worstcase execution time see for a survey power consumption in and prediction of cache behavior for timing analysis see for example algorithms see are algorithms that generate answers quickly and proceed to construct better this research was supported in part by the european research advanced grant and by the science project sn permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january Г italy copyright c acm approximate solutions over time eventually finding the correct so algorithms are useful in verification as they of a way to deal with the explosion problem if the algorithm is terminated early for example due to memory ex it is still able to report an approximation of the desired result the term verification has been proposed re in the context of verifying boolean properties as a way to get better on whether a property holds for a system the concept however is particularly well suited in the context of quantitative verification in this context abstraction gives a quantitative overapproximation of the tive answer to a verification question and it is natural to require the property the more time the verification run is given the better the overapproximation of the correct answer should be we implement this property for quantitative verification through an abstraction refinement scheme that improves the answer for instance abstraction refinement may compute better approximations of power con of a system we propose a framework for abstraction and abstraction refine ment for quantitative properties that is suitable for tion we explain the motivation and intuition behind the framework using the following example motivating example consider the problem of int input v the worstcase if v execution time of for iii the program in figure else we assume an for iii situation where the if i mod is affected mostly else by the cache behavior let for iii each program statement if i mod have a cost depending on whether it accesses only the cache or no memory figure example at all for a cost of or main memory for a cost of we assume that the program variables are mapped to different cache entries while b and c are mapped to the same entry different from the entries for the other variables we consider abstractions that abstract only the cache not the program the cache is abstracted by an abstract cache with a smaller number of entries accesses to the entries not tracked in the abstract cache are always considered to be a cache miss let us start the analysis with an abstract cache of size which caches variables i and v in the abstract system ie the original program composed with the abstract cache the worstcase trace has v equal to and the program accesses the variable a times the analysis then uses this trace to refine the abstraction the refinement extends the cache to include the cache entry for a the worstcase execution then has v equal to and it has accesses to b the analysis now refines the abstraction by extending the cache with an entry for b the estimate is thus until either the trace corresponds to a real execution and thus the estimate is precise or the analysis runs out of resources and reports the computed overapproximation abstraction for quantitative properties our model of systems is weighted transition systems we provide a way of formalizing quantitative properties of systems which capture important properties studied in literature including and boolean properties such as safety and liveness the framework makes it possible to investigate quantitative versions of the boolean properties for instance for safety one could ask not only if an error state is reached but also how often it is reached we focus on properties that admit a linear trace that or the value of the quantitative property such a trace is called the trace for short we present two types of quantitative abstraction schemes the first is statebased that is the elements of the abstract domain correspond to sets of states the second is that is the elements of the abstract domain correspond to sets of trace segments statebased quantitative abstractions the abstraction scheme is statebased it is a direct extension of predicate abstraction where each abstract state corresponds to an equivalence class of concrete states in addition with each abstract state stores the maximum weight of the corresponding concrete states we give conditions for the class of quantitative properties for which is a monotonic overapproximation that is it provides better as the underlying equivalence relation on states is refined this class includes all the quantitative properties mentioned above however we show that there are naturally defined properties for which is not a monotonic overapproximation this is in contrast to the abstraction refinement of boolean properties in the boolean case we do not get less precise invariants if we add more predicates quantitative abstractions we introduce a number of abstraction schemes a segment is a finite or infinite sequence of states that is a consecutive subsequence of an execution trace as the quantitative properties we consider along infinite traces it is natural and to consider abstract domains whose elements correspond to sets of segments not sets of states this is similar to termination and liveness analysis using transition predicates and their to segment covers we build upon these approaches to develop our quantitative abstractions the abstraction scheme stores with each abstract state t representing a set of segments i the length of a shortest finite segment in t ii the length of the longest finite segment in t iii a bit that is true if t contains a segment of infinite length and iv val t a summary value of the weights of the states defining val t as the maximal weight of a state occurring in one of the segments in t makes a sound overapproximation for a general class of quantitative properties to get better approximations for particular quantitative properties val t can be a different summary of the weights for instance we specialized to limit average by storing not the maximal occurring value but the maximal average of values along a segment in order to compare statebased and abstractions let us consider the property applied to a program with a simple for loop for which the loop bound is statically known to be let us assume that the cost of the operations inside the loop is much greater than the cost of the operations outside the loop now consider the statebased abstraction with an abstract state t that groups together all states whose control location is in the for loop in the abstraction this abstract state has a analyzing the abstract system would conclude that the trace is the one which loops forever in t this would be a very result as the concrete traces all leave the loop after iterations to correct for this the loop would have to be times using counterexampleguided refinement steps on the other hand consider the abstraction with an abstract state t representing all the segments in the loop for t is false and allowing immediately for more precise the abstraction scheme is a sound abstraction in the sense that the quantitative value we obtain by analyzing the abstract system the value for the concrete system as in this holds for a large class of quantitative properties however we show that is not a monotonic overapproximation even for standard quantitative properties such as the property in the sense that after refinement of the abstract states we may get worse we therefore present a hierarchical generalization of called in each abstract state represents a set of segments and stores some quantitative characteristics such as of that set in order to compute better of these quantitative characteristics one can perform another level of refinement within abstract states this leads to the idea of a hierarchical abstraction it is particularly useful for software which already has a hierarchical structure in many cases eg nested loops function calls this approach corresponds to the abstract inductive segment cover of section refinement of statebased abstractions for quantitative properties for the statebased abstraction scheme we give an algorithm for counterexampleguided abstraction refinement cegar for quantitative properties the algorithm is based on the classical cegar algorithm which we extend to the quantitative case in the classical cegar loop the counterexample to be examined is chosen using heuristics for quantitative properties it is clear that an counterexample trace the should be chosen for refinement the reason is that if the does not correspond to a real trace then a refinement which does not eliminate this trace would have the same value as the previous abstract system refinement of abstractions for quantitative properties we propose a refinement algorithm for the abstraction we chose because as discussed above it is particularly suitable for software and it is a monotonic overapproximation for a large set of quantitative properties an abstract counterexample for is a hierarchical trace given an abstract counterexample which does not correspond to a concrete counterexample the abstract counterexample is traversed similarly as in the classical cegar algorithm until an abstract segment that provides values that are too pessimistic eg and val values which cannot be achieved in the concrete system by a concretization of the abstract counterexample is found this abstract segment is then refined note that the fact that the counterexample is gives freedom to the traversal algorithm at each step it can decide whether or not to one level lower and to find a between a concrete and abstract execution there experimental results in order to evaluate the proposed abstraction schemes both statebased and we performed a case study on worstcase execution time analysis of x we focused on one aspect the cache behavior analysis and in particular on the rate of cache misses over the course of the worstcase execution in order to abstract the cache we used the abstractions introduced in to the best of our knowledge this is the first work on automated refinement for these abstractions we implemented two abstraction schemes the statebased and the we performed the case study on our own small examples and on some of the benchmarks collected in the experiments show that we obtain more precise quantitative results as the abstraction is refined for example by having a larger abstract cache furthermore we show that using the abstraction enables scaling up this is due to the fact that in the presence of loops the abstraction can quickly obtain good if it can statically loop bounds whereas the abstraction would have to the loop many times to get comparable results similarly to the case the experiments show that we obtain more precise quantitative results as the abstraction is refined by computing better for loop bounds the running time of the analysis was under seconds in all cases related work the theory of abstractions for programs was introduced in we build on the transition predicates of and segment covers of to construct our quantitative abstractions the cegar algorithm was introduced in and is widely used automated abstraction refinement for transition predicates was presented in to the best of our knowledge algorithms for quantitative properties have not yet been studied however quantitative abstractions and refinements have been introduced for stochastic systems where the need for quantitative reasoning arises because of they are mainly directed towards the of expected values and the algorithms reflect this fact the probabilistic work does not aim at handling properties like the property abstractions but not algorithms have been proposed for certain quantitative properties of systems such as cache abstractions for analysis analysis using interval abstraction was performed in the power consumption analysis of software based on the costs of single instructions were presented in our analysis of based on quantitative abstraction refinement could be adapted for power consumption analysis using these models quantitative properties a weighted transition system is defined by a tuple s q q with a finite or infinite set of states q a transition set q О q weight function q r and an initial state q q let s denote the set of all and let sq s be the set of all with a set of states q such that q q we assume that q q q q q system s in figure is an example of a a trace of a s is an infinite sequence qq with q q and i qi qi the set of all traces of s is denoted by s we extend the weight function to traces as qq rr r where ri qi and to sets of traces as t w t w a trace qq is if for all i j we have qi qj qi qj for instance system s in figure has two traces a trace with and a trace with a quantitative property f s r is defined using two functions a trace value function ft and a system value function fs the trace value function ft r r summarizes a single trace of the system the system value functions fs r r summarizes the set of ft values of all traces of the system we then have f s figure system s s r we extend ft to r by letting r t hence we have that f s s we present a number of common quantitative properties below we also model some classical boolean properties in our framework first we give examples of trace value functions the trace value function measures the maximal average weight over a trace the func tion r r is defined by i и i k rk for the trace of s the value the trace value function the weights over a trace where weights occurring further along the trace are by a factor formally the func tion i i и ri safety and quantitative safety the classical safety property is de by a set of unsafe states u and a trace is safe if it never a state in u to model a safety property we assign the weight to each state in u and the weight to all other states the safety trace value function is defined as sup ri now for any trace we have safety if and only if is safe note that this modeling of safety is still boolean because the trace value can only be either or in some applications a more quantitative view might be useful consider safety defined by n k k и rk sum of the number of s in the run for a safe trace we still have that safety however for an unsafe trace safety gives a more finegrained picture it measures how early and often the bad states are visited liveness and quantitative liveness the liveness property is defined by a set of buеchi live states l and a trace is live if it states in l infinitely often to model a liveness property we assign weight to each state in l and weight to all other states the trace value function ri this function is faithful to the liveness property ie live if and only if the trace is live as in the safety case we can get a view of liveness by how often states in l are visited we do it by letting live r r i и i k ri second we give examples of standard system value functions и and intuitively the and functions measure the worstcase and traces in the system и threshold the threshold function checks if any of the values in the given set are above or below given formally threshold ur if r r r u and threshold ur otherwise any combination of a trace value function and a system value function defines a quantitative property in this paper we implicitly assume that the system value function for any quantitative property is sup unless otherwise mentioned a trace is an counterexample trace or for short if f s we restrict ourselves to a class of quantitative properties that admit traces ie every system s has a counterexample trace that is formally f is if and only if s s s f s note that all properties mentioned above are statebased quantitative abstractions a quantitative abstraction c sc f c c is triple consisting of a set of abstract systems sc an abstract quantitative property f c sc r and an abstraction function c s sc a quantitative abstraction c is an overapproximation of f if for all s s f c c s f s abstraction in this section we present a quantitative abstraction technique based on state abstractions in this case the abstract system is a whose states are sets of states of the concrete systems in particular our abstraction scheme is a direct extension of the classical predicate abstraction compared to predicate abstraction additionally stores with each abstract state the maximum weight occurring in the set of corresponding concrete states the name refers to transitions abstracted existentially and that the weights abstracted by is a state based abstraction scheme a family of quantitative abstractions parameterized by equivalence relations on q given an equivalence relation q О q the quantitative abstraction sem f em em has a sem sq ie abstract states are set of concrete states b f em f as the abstract quantitative property and c for a s q q we have that the abstract system em s is a sem em em tem where и are equivalence classes of that contain states from q и t t em q t q t q q и t q t q d and и tem is the equivalence class in that contains q intuitively em s is an existential abstraction and em maps an abstract state to the maximum weight of the corresponding concrete state example consider again the system s from figure and the equivalence relation whose two equivalence classes indicated by the dashed shapes are shown in the upper part of figure the abstract system sem em s is in the lower part of figure we have em sem due to a on the abstract node with weight overapproximation and monotonicity we characterize the quantitative properties for which is an over approximation and for which of refinements holds ie where refinement of the abstraction leads to approximations of the s system value we the classical notion of refinement for abstractions an em s relation is a refinement of an equivalence relation if and only if every equivalence class of is a sub fig abs set of an equivalence class of we define the following и let p r О r be defined by rr p rr if and only if i ri ri and и let r О r be defined by for u u r we have u u iff sup u sup u a quantitative property f is p monotonic if r r r r p r and u u r u u is a monotonic overapproximation for a quantitative property f if a is an overapproximation for f and b if for all s sq and for all equivalence relations and on q such that is a refinement of we have that f em em s f em em s theorem if f is p monotonic quantitative property then is a monotonic overapproximation of f proof we first prove the monotonicity property of the overapproximation property follows naturally as follows for any system s we have s s where id is the identity relation as id is a refinement of any equivalence relation by monotonicity it follows that f s f em s f em em s let s be a system in sq and let and be equivalence relations on q let s q q and s q q be abstractions of s where is a refinement of furthermore let f defined by ft and fs be p monotonic for each equivalence class t of let t be the unique equivalence class of for which t t the class t is guaranteed to exist as is a refinement of furthermore by the definition of we have that a t t and b t t t t therefore for any trace tt of s there exists a trace tt of s such that t t p t t by of ft we get ft ft hence for each w ft s there exists w ft s with w w this in turn gives us ft s ft s hence by monotonicity of fs we get s s or equivalently f s f s this proves the required theorem as f f em it is easy to show that safety liveness limit average and sum are p monotonic the following proposition is a direct consequence proposition is a monotonic overapproximation for the safety and liveness properties example we describe a property for which is not a monotonic overapproximation let f be defined by rj and sup u the property f can be used to measure the variance in resource usage where the usage in each step is given by the weight during the execution of a program consider the system in figure and the abstraction with abstract states given by the the nodes outside the dotted boxes are each in a separate singleton equivalence classes property f has value on the abstract system due to the trace a b c having maximal and minimal weights as and under abstract state a b and c have weights and respectively refining the abstraction by completely splitting state b increases f to refining further by splitting both states a and c decreases f to which is the true value of the concrete system the sequence of refinements show that for property f the abstraction is neither an overapproximation as the first abstract system has value which is less than the value of the concrete system nor monotonic as the sequence of values and obtained through subsequent refinements first increase and then decrease evaluating quantitative properties on abstractions recall f em f for abstractions to evaluate f em and obtain an for refinement any algorithm for finding for the quantitative property f suffices standard algorithms exist when f is one of safety liveness and properties for we use the classical policy iteration quantitative abstractions in this section we present quantitative abstractions where elements of the abstract domain correspond to sets of trace segments segments a segment is a finite or infinite sequence of states in q let q be the set of all finite segments q the set of all infinite segments and let q q q be the set of all finite and infinite segments given a segment let denote the length of the segment the range of is thus n given two segments and in q we write for their concatenation with if is in q also we the notation last and first to represent the last state of a finite segment and the first state of a segment we a nonempty set of ments a we define the following operations and relations on and sets of abc и for t and t we have t t if t w x q y q t that is all segments from t occur as of segments in t и for a set of t we define t to be set of segments fig refinements which can be obtained by concatenation of segments con in in t formally t n t t tn i i n i ti t t i i i ti и a set of t covers a t if and only if for all ti t we have ti t and t t note that for a s the set of all its traces s is a we call t a segment cover of a system s if and only if t covers s for example the two t and t in figure form a segment cover of the system in figure it is easy to see that all traces of s are covered by segments in t and t our notion of segment cover corresponds to the inductive trace segment cover from with height the notion of the segment cover plays the same role in abstractions as the equivalence relation on states plays in statebased abstractions abstraction is a abstraction scheme a family of quantitative abstractions parameterized by sets of on q given a set of t the quantitative abstraction t is defined by f pb we now define each element of the triple abstract systems an abstract system in is a tuple r r val r where r is t r is a transition relation and r is the set of initial states the type of val and functions is r r and the type of is r b their intuitive meaning is given below the systems in are called abstraction the partial abstraction function is defined as follows for a s if t is not a segment cover of s then the value is undefined otherwise given s q q let s where pb val and и is t и t t pb if t t such that is a finite segment in q last first и val t max q t and q occurs in ie val t is the maximal weight of a state occurring in one of the segments in t и min t is a finite segment if t con a finite segment and is otherwise и max t is a finite segment if t contains a finite segment and is otherwise и true iff t q ie is true if and only if t contains an infinite segment val false t t val false figure abstraction of s и contains a set t in t iff t contains a segment whose first state is q as t is a segment cover of s we have that is nonempty a of a s is either a a finite sequence tt tn such that t and i i n ti ti pb or b an infinite sequence tt with t and i ti ti pb the set of all of s is denoted by pb s example recall the system s from figure consider a segment cover t t t of s depicted in figure t and t can now act as abstract states with the values val and given in figure abstract quantitative property f pb in order to define the abstract quantitative property f pb we will need the following notions let us fix a system s q q let us also fix a set t of such that t is a segment cover for s let s s pb val be a abstraction of s for t we now define a function b that for a given returns a set of possible sequences of weights that correspond to the function b s r is defined as follows the set b contains a sequence и wn wn wn in r iff is a finite tn such that a i such that i n we have wi val ti and b i such that i n we have ni and ni и wn wn in r iff is an infinite tt pb s such that a i wi val ti and b i ni ni let f be a quantitative property defined by a trace value function ft and a system value function fs we are now able to define the abstract quantitative property f pb by f pb b example recall again the system s from figure and the abstract cover described in example consider the abstraction one s the abstract of the system is depicted in abstract system and figure we have there is only tt let us assume that the quantitative property we are interested in is the limit average quantitative property we get that b we therefore obtain f pb s и и as the maximum value is achieved if the execution at the more costly abstract state t as much as possible times and at the less costly abstract state t as little as possible times overapproximation and monotonicity the following theorem states that the abstraction scheme is an overapproximation for a large class of quantitative properties theorem abstraction scheme is an overapproximation for a quantitative property f if f is p monotonic i val false a s val false i val false b s figure abstractions of system s a set of t refines a set of t iff for all t t there exists a set of t such that t t and t covers t is a monotonic overapproximation for a tive property f if a is an overapproximation for f and b if for all s sq and for all sets t and t of such that a t covers s b t covers s and c t is a refinement of t we have that f pb s f pb s the abstraction is not a monotonic approximation in general even for quantitative properties that are p monotonic we show this by constructing a counterexample see example for which the abstraction is not a monotonic mation for the property induced abstraction given an equivalence relation on states we can define a set of let s q q be a and let be an equivalence relation h on states in q given an equivalence class i e of we can define a corresponding figure system s te as follows first let te be the set of finite or infinite segments such that all states q that occur in are in e now we define te as the set of maximal segments in te a segment is maximal in te iff a is in te b there is a transition qb first such that qb e and c either q or there is a transition last qf such that qf e let t be a set of defined by te e is an equivalence class of example consider again the system s in figure and the equivalence relation on its states given by the dashed shapes in figure the we get from the equivalence classes are given by the nodes t and t in figure the set of these is t as calculated in example the value for the abstract system for the objective given by t is note that this is better more precise than the value given by the abstraction defined by the same equivalence relation as calculated in example the value given by is given an equivalence relation on states the abstraction t gives a better overapproximation for objective than the proposition let f be a p monotonic quantitative prop let be an equivalence relation on q and consider the two abstraction schemes t f pb and sem f em em parameterized by then for all s sq f pb s f em em s we observe that if is a refinement then t is a refinement t however we show an example system where the overapproximation computed using the t abstraction is worse less precise than the overapproximation computed using the t this means that in general is not a monotonic overapproximation for p monotonic quantitative properties example consider the system s in figure consider an equivalence relation on states given by the dotted rectangle in the figure that is all states except the state i are equivalent to each other this equivalence relation defines a set t of the resulting abstract system s is in figure a note that in figure a the node for which the values of etc are given corresponds to the dotted rectangle in figure the other node in the abstract system corresponds to the singleton segment of length one generated from the singleton equivalence class of the node i of system s consider now a refinement of where the equivalence class of the dotted rectangle is split into two classes given by the dashed the new equivalence relation defines a set t of the abstract system in fig b results from a refinement where the equivalence class of the dotted rectangle is split into two equivalence classes given by the dashed the resulting abstract system s is in figure b let us now assume that the abstract quantitative objective is the value we get for system s is ии the value we get for its refinement s is и и и this shows that the estimate is worse less precise for the refinement s than for s specialization of abstraction for the quantitative property we presented a general definition of the abstraction which is an overapproximation for a large class of quantitative properties we now specialize the abstraction for the property by introducing sound optimizations we define the abstraction de noted by scheme as f let s be a system and let s pb val be a abstraction of s furthermore we fix f to be the property ie ft and fs sup for the remainder of this subsection we have that s pb val is a similar to in the abstraction scheme we have the following differences и val t q s s q here we let the value of an abstract t be the of the average weight of the segments in t rather than the maximum weight occurring in t note that if t q we have val t t и the abstract quantitative property f is defined in the same way as f pb at the beginning of section except that the definition of b s r we have that wn wn b if and only if tt with wi val ti ni ni wn wn wn b if and only if i n wi val ti i n ni ni the above differences between the and can be summarized as follows a the value summarization function for each can be average instead of maximum and b more from a practical point of view the evaluation of the abstract property on a can be done by considering only the lengths of the longest and shortest finite paths of an rather than considering all lengths between them this is because is a property the following theorem states that provides a better approximations of the property than theorem given a system s and an segment cover t of s and f being the property we have f s f s f pb s example consider again the system s from figure and the t and t from figure in ab we have val t while the other values for t are as in figure for val t we have val t the value of the system is f t s recall that for abstraction the value f pb for s was calculated in example to be for abstraction we thus get a better mation than in the abstraction evaluating on systems cycle algorithms compute the value for a graph with weights on edges therefore from a we construct a graph which has weights and lengths on edges rather than nodes intuitively we consider the graph with edges of the being the nodes there are two edges between the node t t and t t one of weight О val t and length and another of weight О val t and length the node t t has the of weight val t and length if is true we denote this graph by s policy iteration was extended in to compute the values in graphs where edges have both weight and length as is the case of s policy iteration works by a policy that maps states to successors and improves the policy as long as possible each improvement takes linear time but only an exponential is known on the number of improvements required however a number of reports state that only linear number of improvements are required for most cases in practice of abstractions in this section we present two of the abstraction scheme the first one generalizes by considering different summaries of rather than set of properties val the second one generalizes by allowing inductive fixedpoint style computations of properties generalized abstraction let s be a and let t be a segment over of s in the abstraction from section we used the values of and val to abstract in t the abstract values are in turn used to compute an overapproximation of the property for s in this subsection we provide a generic abstraction scheme for any set of properties more specifically let us assume that we have a set p of quantitative properties a set t of that is a segment cover of a segment set t we provide a generic technique to answer the following question if we know the values of quantitative proper in p on all in t can we compute the values of quantitative properties in p on t we need to extend notation in two ways a we will use properties f defined by ft and fs for both finite and infinite traces the type of ft will thus be r r r and b we will evaluate quantitative properties on a t instead of a by letting f t t fix an arbitrary s q q consider an arbitrary set of t t t tn where all segments are sequences of states from q we define the set of valid segments generated by t as t n j j t j n j j t j where first and last denote the first and last states of a segment intuitively the set t is the set of segments generated by t where the transition relation of the system s holds at the boundaries let t t tn be a cover of the t not necessarily s note that t can be a proper subset of t ie t t but t t we call the t t the strengthening of the t by t and our question thus becomes provided that we know the values of quantitative properties in p on all in t can we compute the values of quantitative properties in p on the strengthening of the t by t and ie on t t abstract and property domains let be the set of all partially ordered by the subset rela tion and let l be a lattice the lattice serves as an ab domain for describing elements of l can be for instance objects such as formulas in a logic let l be a galois connection see we call the domain l the abstract domain and each element l an abstract a property set p is a tuple fl fu where a all are quantitative properties where fs inf and b all are quantitative properties where fs sup we define the corresponding property domain dp rn О rm p to be the abstract domain where al au bl bu if and only if all ail and we write pt for t example the property set val is a property set for example inf t and t where is if and otherwise it is easy to see that a galois connection p p dp p can be defined by letting p t pt and p p t pt p intuitively l ln u un pt represents the largest t that respects the lower and upper bounds placed by p ie li uj we call dp the property bound domain and an individual p dp a property bound let l О dp where is О p be the product of l and dp p we call l О dp the domain of abstract bound pairs and each element written as p an abstract bound pair let l О dp О p be a galois connection naturally defined for the product of abstract domains where t t p t and p p p intuitively the element p represents a that is contained in and respects the property bounds p we identity abstract segments l with the abstract bound pair in where ie there are no bounds on any of the properties in p example let l ie the abstract are the same as concrete note that this assumption is to simplify the example it would be more natural to use objects eg formulas in some logic for l consider for the property bound domain defined in example an example of an element in l О is t where t is from example here represent bounds on values of properties val note that t contains exactly the same information that stores about a evaluating quantitative properties on abstract in what follows we fix a s and a segment cover t t t tt of t s let k be the interval t given an abstract bound pair domain l О dp О p where f is a property in p we can perform the computation of f t t in the abstract domain for this computation the abstract bound pair domain needs to support the following additional operations let p be an abstract bound pair and p t pt be a set of abstract bound pairs the abstract bound pairs domain l О dp О p is an inductive domain if it supports the following operations in addition to the standard lattice operations и transition check this operation checks for two abstract whether a segment from the first can be followed by a segment from the second formally i j is true if and only if there is generated segment ie i i k where ij such that a i i j j and b and are also generated и reduce property bounds given an abstract compute an overapproximation of the property bounds on formally returns p such that p и property computation given only the bounds pi on ab i and the values i j computes an overapproximation of the property bounds on the abstract segment p formally given i j i j true and the values pi for all i the function p pt outputs p such that p i pi i k note that we sometimes the notation and write p t pt instead of p pt i example from example ie l and the system under consideration is s from figure и st t can be as precise as the transition relation of ie t t st t suppose t and t we have that can be followed by if and only if last first this is the condition that defines t t pb и if we take t to be precise and expensive procedure that abstract states it can return t ie it computes an over approximation of the information stored for the particular и t p t p where p and p computes an over approximation of ps by computing on abstract states if is defined using the same approach as the b and f definitions from section it returns here val s is and and are to the largest possible val remark note that in the arguments of we do not require pi to be equal to pi in fact even in the case where pi is a p overapproximation of pi the procedure is required to produce a valid p overapproximation of the p value of i i k we call an abstract bound pair domain effective if a each of the operations and can be computed effectively ie by a terminating procedure and b and are monotonic ie giving more precise inputs produces more precise outputs formally a b i k pi pi i i p t pt p t pt and c p p p p p p p t pt p p t pt we can now generalize abstraction scheme by let the summaries of be the set of values of properties from any effectively inductive quantitative property set intuitively given a s and a property set p the l О dp abstraction stores with each t in the cover of s the values t pt to compute the value of the abstract system the procedures and are used formally l О dp t sl О dp l О dp t f l О dp is defined as и l О dp t s t where a s b i ti and c i j if and only if i j returns true и f l О dp is computed as the value of f in p where p t precise abstractions in the case if the abstraction function does not lose any information ie if the equivalence relation used is the identity relation the abstract system value is the same as the concrete system value we give the conditions when an abstraction does not lose any information either intuitively we want the property computation for a t from a cover t t tn to be accurate when t is exactly covered by t ie t t an quantitative property set is precisely inductive if there ex a procedure which produces the output p when the following hold a pi pi and b i i k example the property is not precisely inductive ie by knowing only the value of the of a segment we cannot estimate the accurately without knowing the length of the however strengthening it to the property set makes it precisely inductive hierarchical abstraction effective abstract bound pair domains allow computation of property bounds for a whole set of properties on a from the property bounds on each element of the cover for example if t covers t the four properties val of in t are used to compute not only the but also the and values of the t too this leads to the possibility of computing these properties hi for a trace segment cover an inductive trace segment cover c is a finite where the nodes are labelled with abstract bound pairs such that for every node labelled with p and p n pn the set of labels of its children p n pn is a segment cover of p an inductive trace segment cover c inductively covers a t if t similarly c inductively covers a system s if s we can now introduce an abstraction scheme l О dp c О dp О dp c f О dp parameterized by an abstract bound pair domain l О dp and an abstract inductive trace segment cover c intuitively stores for each internal node a of c a l О dp t a abstraction t a the abstract trace segment cover t a for this abstraction is the labels of the set abstract hierarchical traces we fix an abstract bound pair domain l О pd an abstract hierarchical trace p p sub consists of a a finite or infinite sequence of abstract bound pairs and b a partial function sub from n to hierarchical traces the concrete traces corresponding to a given abstract trace p p sub are defined as i i i pi i intuitively a concrete trace of an abstract hierarchical trace is made of segments i from i pi with the additional condition that i if is defined given a property set p an effective abstract bound pair domain and an inductive trace segment cover c of system s we inductively compute property bounds and hence abstract system values using algorithm the algorithm is based on the inductive proof method presented in it can be rewritten as a fixedpoint computation in algorithm inductive property computation input s effective abstract bound pair domain l О dp abstract inductive segment cover c labelled from l О dp output abstract bound pair p such that p p p if has no children then return p p else top level subtrees of c return p p c the lattice c l О dp of maps from to l О dp the lattice ordered pointwise by p at the final line in algorithm the value of c will be the least fixedpoint of the function which replaces each node in c with a best approximation obtained from among the current value of the node and a applied on the node if it is a leaf node or b applied on the node and its children if it is an internal node monotonicity we define refinements of abstractions using refinement steps let c be an inductive trace segment cover and let a be a node in c b be its parent ca be the subtree of c rooted at b and p and b p b the labels of a and b a refinement of c is one of the following и refinement let and be such that p p p let a p and a p be the tree ca with p replaced by p and p respectively let the tree c be obtained by ca from p and then a p and a p to p then c is a refinement of c и vertical splitting refinement suppose p n pn cover p and that a does not have any children suppose c is obtained from c by adding the children with labels p n pn to a then c is a vertical splitting refinement of c и vertical joining refinement suppose that b has no and let b p b p and c c c if c is the tree obtained by removing all the children of b in c then c is a vertical joining refinement of c и downward strengthening refinement suppose and b p b p p let c be the tree obtained by replacing ca by a p then c is a downward strengthening refinement of c и upward strengthening refinement suppose that p is such that p bp b if c is obtained from c by replacing b p b with p then c is a upward strengthening refinement of c a cn is a refinement of c if there exists a sequence c c cn such that ci is a refinement of ci for all i such that n i l О dp is monotonic if for all systems s and abstract inductive trace segment covers c and c of s if c is a refinement of c then abstract value f О dp О dp c s f О dp О dp cs theorem if f is a property such that fs sup and the inductive property set p contains f and l О dp is effectively inductive l О dp is monotonic for f intuitively the theorem holds as every refinement preserves the information about the of nodes from the previous iteration for all refinements other than the vertical joining refinements the monotonicity follows from the monotonicity of and for vertical splitting refinements the monotonicity holds as all the information that can be generated from the deleted children is already present in the parent node abstractions for controlflow graphs a controlflow graph of a program written in a highlevel language is contains many structures like loops and function calls the traces of transition systems produced from such programs are structured this the possibility of using hierarchical abstractions to analyze them controlflow graphs and programs following eg we abstract away from the syntax of a concrete programming language and model programs as graphs whose nodes correspond to program locations here we assume simple programs with function calls this implies that there are no recursive functions let v be a set of variables and let dv be the combined range of variables in v a controlflow graph cfg is a tuple of l v dv where l is a finite set of control locations is a transition relation v is a set of variables and is a function from to assertions over program variables v and their versions v the variables v refer to the values of the variables after executing the transition we assume that v contains a special variable wt ranging over r which denotes the weight of a particular state s b f k s j s s j k j s b гb s j b s k k s s гb s figure an example cfg given a cfg c a corresponding transition system can be gen with l О dv in a standard way we add the weight function l d w where w is the value of the special variable wt in d to turn the transition system into a we assume the following about the cfg these assumptions are valid for cfgs generated for programs in most programming languages a in the graph l every maximal strongly connected component has a single entry and exit point ie if g l is a maximal strongly connected component there exists a node lg such that l l l g О g l lg l l g О l g l lg b recursive suppose g l is a maximal strongly connected component the graph g g О g lg is also reducible intuitively the above conditions imply that loops in the cfg are and and that they are nested a hierarchical controlflow graph b false j while j b not b if b j is a graph h h О h hi where each node h h is either a controlflow location or a hierarchical controlflow graph we call the first kind of nodes abstract state nodes and the second kind of nodes subgraph nodes any recursively reducible cfg c can k be converted into a h of a while k k form using a standard algorithm on re graphs in this special form h and figure all occurring in h have the fol property either they are acyclic or they have a single node with a on itself note that each loop of a program will correspond to such in what fol we assume that all our are of this special form example consider the example cfg shown in figure generated from program in figure the equivalent of the special form to this cfg is shown in figure the statements on the transitions in figure are omitted for the sake of clarity each of the dotted boxes represent a intuitively each loop has been separated out into an acyclic cfg containing the loop body and a single cfg inductive trace segment covers can be derived from in particular every h represents a unique inductive trace segment cover ch intuitively the root of the inductive trace segment cover is the set of all traces of h and the children of the root node are either a ch if h is a subgraph node of h and b s if s is a abstract state node of h where s is the containing all segments of length with states in s from now on we use and abstract inductive trace segment covers example consider the program in figure its cfg is in figure and the corresponding is in figure we use regular expressions over control locations as our abstract domain l the regular expressions have their intuitive meaning for example a the expression ss represents all segments qq such that the control location of q resp q is s resp s and b the expression ss represents the set of segments obtained by concatenation of segments from ss the corresponds to the following inductive trace segment cover c of the traces generated by the cfg the root of c is the expression h its only child is f the children of f are cb l cm l where cb l ss cm ss and l ss of these only l and l are nodes having one child each cl ss and cl ss respectively evaluating for abstractions induced by let h be a of a special form we compute the values val and using the technique of computing loop bounds we consider a the domain of abstract bound pairs with elements of the form p as before suppose h is a with a single node and a furthermore let p be the corresponding abstract property bound in ch and let p n pn be its children let segment be in p p n pn let n where n if and only if there exist n such that j ni j i pi let for all such we define the upper loop bound resp lower loop bound denoted by resp as the value sup resp inf note that there exists techniques to compute loop bounds using for example relational abstractions and ranking functions see for example and references now given the values of val and of subgraphs of an h we inductively compute the value of the properties for h as follows и if h is a single node with no ie an abstract state node we have val h h and f и if h is acyclic we construct the following graph h as in section ie edges of h correspond to nodes of h and every node of h corresponds to two edges of weights resp lengths и val h and и val h resp and now and are equal to the length of the longest and shortest paths in h also true if and only if there is a node h in h with the value val h can be evaluated using policy iteration as in section и if h is a single node with a there is only one subgraph of h say h we have и val h val h and thus for such an we can evaluate the value by using the inductive evaluation scheme from section ie using the values val and we can inductively compute the values for an example consider the in figure and its inductive cover c from example we will illustrate a few steps of the inductive computation of the properties on c fix p val let us start for the leaves of c ie cb cm ss cl ss and cl ss now we can compute and for these as the shortest and longest paths in the corresponding furthermore the values for each of these is as all of these cfgs are acyclic the val of cb s s s s s cm s s s s s cl cl s s cl l cl cb l cm l f l f h figure of a program all the leaves except cl is as the weights of all nodes except s are for cl the val can be computed to be therefore cb cm p cl and p cl now the nodes l cl and l cl have the children cl and cl respectively the procedure has to now compute the properties pl using pl however note that the domain l does not give methods to compute see example for a refinement of the domain l which can compute therefore assuming and for the loops are and respectively we get the values pl pl and p l pl similarly we get the for pf pf and p h ph this corresponds to a counterexample that ends with an in finite loop in l that contains the costly operation quantitative refinements in this section we present quantitative refinement algorithms for the statebased and abstraction schemes algorithmic refinement of abstractions for the statebased abstraction scheme we give an algorithm for counterexampleguided abstraction refinement cegar for quantitative properties the algorithm is based on the classical cegar algorithm which we extend to the quantitative case here as in we assume that the concrete system is finitestate and obtain a sound and complete algorithm in the case the algorithm is sound but incomplete let s q q let f be a p monotonic quantitative property that admits counterexamples as stated in section we restrict ourselves to these properties and let be an equivalence relation on q let us further assume that s q q is the result of applying the abstraction parameterized by on s let ext be the counterexample of s which the value f s algorithm is a refinement procedure for abstractions its input consists of the concrete and abstract systems the equivalence relation that the abstraction the quantitative property and the trace ext as the counterexample is it is of the shape h hn the output of the algorithm is either a concrete counterexample if one corresponding to ext exists or a refined equivalence relation which can be used to produce a new abstract system let us consider a set of traces ext of the system s that correspond to an abstract trace ext h hn the first observation is that checking whether a concrete counterexample exists ie whether ext is nonempty can be done by checking whether a finite abstract trace u corresponds to a concrete trace the finite abstract trace u can be obtained by the loop part of ext m number of times where m is the size of the smallest abstract state in the loop part of ext or formally m k i n line this result can easily be adapted from to the quantitative case algorithm refinement for input s q q prop f eq rel abstract s q q abstract counterexample ext h hn output refined eq rel or a concrete m k i n u m k n we have u g r q i while ri i k n k и m do ri gi gi i i if ri then return ri else u s ri s gi ss s s gi return lines to traverse the finite abstract trace u and at each step maintain the set of states that are reachable form the initial state along a path corresponding to u the post operator in line takes as input a set of concrete states l and a weight w and returns all the successors of states in l that have weight w if the traversal because at ith step the set ri is empty then the algorithm refines the equivalence relation by splitting the equivalence class given by gi into u and gi u line the set u contains those states that have a transition corresponding to a transition in u to a state with weight gi the intersection u ri is empty because ri is empty thus separating u leads to eliminating the counterexample from the abstract system if the traversal a pass over the whole trace u it can construct a concrete counterexample using sets of states r ri line we have thus extended the classical cegar algorithm to the quantitative case the extension is simple the main difference is in taking into account the weights in lines and algorithmic refinement of abstractions in this subsection we describe an algorithmic technique for refinement of abstractions we assume that the abstract bound pair domain is precisely inductive we assume that the counterexample from the evaluation of a abstraction is returned as a abstract hierarchical trace p p k pk n pn sub note that we can assume a counterexample due to the property of the quantitative properties we consider furthermore without loss of generality we also assume that every leaf in the abstract trace segment cover is composed of segments of length the basic structure of the refinement algorithm is same as in however the main difference is in the post operator for hierarchical traces we define a nondeterministic post operator in algorithm intuitively the algorithm nondeterministically chooses a level of the hierarchical trace to perform the analysis first given a hierarchical trace of length post operator computes lines and the set p q p q first then it computes the toplevel post set r of states reachable from r using the segments from p now nondeterministically line it chooses whether to into the next level of the hierarchy if it to the set of post states r is computed from the levels below and then the strengthening of r by r ie r r is returned assume that the post computation is done at a particular level ie the level below is not used intuitively this means that all the segments in p are assumed to be valid segments and the property bounds are assumed to be tight ie the part of the counterexample corresponding to p is considered note that in the case where the algorithm always to the lowest level the set returned is exactly the set of states reachable using segments in we also remark that nondeterminism in algorithm can be instantiated in a manner suitable for a particular domain algorithm counterexample analysis for input hierarchical trace p k pk sub concrete set of states r output overapproximation of states reachable through segments in if n then return post p n pn sub post p sub r t p r q qq t q r if then if sub then r r else r r return r r r r let c be the inductive trace segment cover and let p p k pk n pn sub be the abstract trace the abstraction refinement procedure r proceeds similarly to algorithm as follows и the abstract hierarchical trace is m number of times where m pi i k n и let r be the set of concrete initial states for each abstract property pair i pi in the trace we compute ri r r post i pi sub ri и if at any step ri we refine the inductive trace segment cover c using set ri and i sub as i sub explained below otherwise return any concrete counterexample constructed from the set r r we describe the computation of i pi sub when post i sub ri during the computation post i sub ri execution of algorithm we have at least one of the following cases based on the values of r and r first we define tr q rr first i pi and r rr first intuitively tr is the set of concrete segments from r in i pi and is the set of concrete segments from r generated from the hierarchical levels under i pi we have one of the following и r r in this case the refinement returned is sub r ie we run the abstraction refinement procedure on the lower level starting from the concrete set of states r и r in this case we perform a refinement to separate the sets tr and t tr ie the node labelled i pi is split into a p a and b p b where a p ab p b and tr ap pb intuitively we are separating segments in i pi that are from r from those that are not from r и r r r in this case we perform multiple simultaneous refinements the segment sets which need to be distinguished from each other are t tr tr and intuitively we are trying to separate the segments in i pi that a do not start from r ie t tr b those that start from r and are generated from the levels below ie and c those that do start from r and are not generated from the levels below ie tr formally let a p a b p b and c p c be such that t a p a b p b c p c tr a p a a p a b p b tr b p b and tr c p c first we do a refinement splitting the node i pi into a p a b p b and c p c second in the subtree rooted at a p a the levels below contains the information that tr is infeasible but the root does not so we perform upward strengthening refinements the root contains the same information third in the subtree rooted at b p b the root contains the information that is infeasible but the levels below do not so we perform either a downward ing refinements the levels below contain the same tion or b vertical joining refinements there are no levels below note that if one of a p a b p b or b p b is empty we omit it example consider the h and the corresponding abstract trace segment cover c from example we now show some examples of hierarchical counterexample refinements for computing the value we work in a more powerful refined domain than in example one that allows computation of loop bounds let l be the domain of regular expressions over gs along with a relation between the values of the variables in the initial and final states for example the expression ss b гb represents the set of segments which match ss and have the value of b is the last state is negation of the value of b in the first state let us first start with abstract trace segment cover c from a part of the abstract trace generated from c will be l sub where a sub cl sub where b sub i for all i we will illustrate two re steps that might occur и suppose during the refinement process we are computing post l sub r where r is the set of states at location s with j now we can perform the analysis either at the top level or at the lower level at the top level we get the post states to be r where the control location of a state is in s at the lower level we get the post states to be r as the transition from s to s is due to j being therefore we need to refine the abstract ss one possible valid refinement is to the set ss to ss j j j using this set we can compute that the upper and lower loop bounds for l are this leads to a improvement in the value of the system as now there is no infinite path in the high value segment l the new value of the system is и suppose during the refinement process we are computing post l p sub r where p bounds the of segments in l to r is the set of states at location s with b true again performing the analysis at top level produces r s but the lower level produces r where r therefore we can to refine the abstract ss and one possible refinement is a split into b true b f and b f b true performing this refinement reduces the value of l to and hence by upward strength the value of the whole system to case study analysis we present a case study to demonstrate verification and to evaluate and hierarchical abstractions worstcase execution time is an important part of verifying realtime systems we only study one aspect ie cache behavior prediction in a processor clock cycles needed for an instruction can vary by factors of based on cache vs misses assuming the worstcase for all instructions leads to bad abstract domains for cache behavior prediction are well studied eg however we know of no work on automated refinement for these abstractions note that this case study and the implementation is not a complete analysis tool but a prototype used to illustrate the quantitative abstraction refinement approach our intention is just to evaluate the aspect of our approach we estimate using the property intuitively we put the whole program in a nonterminating loop the then corresponds to the average cost of an instruction in the worstcase execution of a loop for a terminating program it is the execution of the artificial outer loop is by the values with an overapproximation of the length of the longest trace we report values instead of the cache model and the abstract domain used are from multiple abstract domains are possible based on the tracked locations if no set is tracked every memory access is a whereas the invariant computation is very expensive in the domain which tracks all here we start from the empty cache and refine by tracking more as necessary implementation details we implemented a analyzer based on the presented techniques in a tool that analyzes x static analysis we analyze the binary and produce the control flow graph instructions in the program may operate on addresses for example array indexing leads to variable offsets from a fixed address however if the exact addresses cannot be computed statically we perform no further analysis and assume that the memory access is a cache miss this restriction comes from the cache abstract domain we use from worstcase computation in the resulting graph we annotate states with invariants from the current cache abstract domain from the invariants we compute costs of each transition we use costs of and cycles for and respectively we then find the worstcase using techniques of section and section to find a the worstcase value furthermore we implemented the extension of the algorithm to graphs with both edge weights and edge lengths refinement we analyze worstcase counterexample ext feasibility analysis we first check if ext is a valid program ex example basic example binary search polynomial eval step value time tracked ms i a b c v m r l s a n a n a n i val x inp inp temp table abstraction results ignoring the cache using a custom symbolic execution computation if ext is not a valid execution we refine the abstract graph using standard cegar techniques cache analysis if ext is valid we compute the concrete cache states for it if the concrete value obtained is the same as that of ext we return the concrete trace refinement heuristic otherwise of all locations accessed in the loop of ext we find the one with most abstract cache misses which are concrete cache the current cache abstract domain is refined by additionally tracking this location refinement if all the locations accessed in ext are already being tracked we use algorithm and the algorithm given by to do the refinement evaluation of abstraction for evaluating the tion and refinement methods we consider inputs for five small c programs in l r n the example from the do tion called basic example in the table the results are in table for each example program the table contains lines with each corresponding to a refinement step for each refinement step we report the current estimate for the value the running time for the m l r am l m else r m r am s sis in and in case the refinement the abstract figure bin cache we also show what new memory search locations correspond to the entries in the abstract cache in each case the value decreases as the tool is given more time binary search we analyze a procedure figure that repeatedly performs binary search for different inputs on a given array we start with the empty abstract cache domain and all behaviors have high values with worstcase value in the variable m accessed times every iteration of the inner loop causes most spurious cache misses using the refinement heuristic we choose the location of m is additionally tracked in the cache abstract domain reducing the value to indices l r and the input s are the next most frequently used and are added subsequently to the cache abstract domain more importantly the most used array elements are added in order during binary search the element at position n is accessed always and the elements at n and n half the times and so on the refinements obtained add these array elements in order this illustrates the aspect refinement can be at any point to obtain an overapproximation of the value evaluation of the hierarchical abstraction for evaluating the abstraction refinement procedure we benchmarks from the collection of benchmarks in these benchmarks were larger than the ones for the evaluation with around lines of code each the benchmarks we included a simple program which scanned a matrix and counted elements matrix multiplication and two versions of transformations mark cnt step value time ms we used the abstraction refinement algorithm ie the algorithm given by we note that we do not perform any cache refinements nevertheless the hierarchical as of hierarchical tion was evaluated as three of the marks contained a number of nested table abstraction results loops the challenge addressed was to obtain good and decreasing on as the abstraction is refined we summarize the results in table for each example pro gram the table contains a number of lines with each line to a refinement step for each refinement step we show the current estimate for the value and the running time for the analysis in as it can be seen the values decrease with longer execution time it should be noted that for most of these programs to obtain similar values with the approach one would need to perform a large number in of counterexample refinements as the nested loops would have to be conclusion summary this paper makes four main contributions first we present a general framework for abstraction and refinement with respect to quantitative system properties refinements for quantitative abstractions have not been studied we propose both statebased and quantitative abstraction schemes quantitative abstractions are entirely novel to the best of our knowledge third we present algorithms for the automated refinement of quantitative abstractions achieving the monotonic overapproximation property that enables verification fourth we implement refinement algorithms for analysis of in order to demonstrate the verification property of our analysis and to investigate tradeoffs between the proposed abstractions future work there are several directions for future work the first is to perform case studies for instance for worstcase execution time analysis with more realistic architecture models second quantitative abstraction can aid synthesis as quantitative reasoning is necessary if the goal is not to synthesize any program but rather the best performing program according to quantitative measures such as performance or furthermore the verification property of the refinements we proposed can lead to synthesis methods that is methods that would synthesize correct programs and refine these into more optimized versions if given more time references m problem solving using dynamic programming in pages Г e clarke o s y lu and h counterexampleguided abstraction refinement for symbolic model checking j acm Г j g s m and jp numerical computation of elements in algebra b cook a podelski and a rybalchenko abstraction refinement for termination in sas pages Г p cousot and r cousot abstract interpretation a unified lattice model for static analysis of programs by construction or approximation of fixpoints in popl pages Г p cousot and r cousot systematic design of program analysis frameworks in popl pages Г p cousot and r cousot an abstract interpretation framework for termination in popl pages Г l de and p abstraction for markov decision processes in cav pages Г c f martin r and m cache behavior prediction by abstract interpretation sci comput program Г s gulwani and f the problem in pldi pages Г j a a and b the benchmarks past present and future in pages Г h b and l probabilistic cegar in cav pages Г m m g and d abstraction refinement for probabilistic software in pages Г a podelski and a rybalchenko transition predicate abstraction and fair termination in popl pages Г a m and j a conceptually new tool for worstcase execution time analysis in n a tool for verification usable verification v s and a power analysis of embedded software a first step towards software power minimization in pages Г r s c d j j b and s static timing analysis for hard realtime systems in pages Г r j a n s d g c r t f i p j and p the worstcase problem overview of methods and survey of tools acm trans embedded comput syst 
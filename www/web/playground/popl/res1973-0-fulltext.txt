deterministic parsing of ambiguous grammars a v aho bell an s c johnson new j d unman princeton university princeton new p abstract we consider methods of describing the syntax of programming that are more flexible and natural than conventional descriptions the use ot ambiguous contextfree grammars together with rules we show how efficient ll and lr parsers can be constructed certain classes of these specifications languages in ways these methods in to resolve syntactic directly from i introduction there has been much work on developing efficient parsing methods see au such as the ll lr and precedence based techniques this work has focused on mechanical ways of deterministic no backtracking for certain classes of context ce one has a grammar in the efficient parser can be constructed automatically unfortunately the most natural grammar describing a language is frequently not in the class of grammars for which we have known how to mechanically construct efficient parsers consequently the grammar must be rewritten by hand to make it fall into the required class while the necessary are not hard to do after some practice they often expand the size of the grammar and introduce nonterminal symbols for example the natural grammar for simple arithmetic expressions in and is gl exp exp pi w i q however g is ambiguous the most natural grammar for this language is g exp term factor exp term term factor i factor exp i id gp can be the introduction of the nonterminals term and factor enforces the here assumption that takes precedence over and that and are each left in eo doing the grammar becomes unambiguous but larger the resulting grammar parsed efficiently by various means such as the simple lr or weak precedence work of this author supported by nsf grants gj and gj despite various facilities which have been created for the automatic generation of parsers from grammars eg we are by m that all compilers in existence use either operator precedence f or recursive descent c tech the latter two methods are not really based so it is often difficult to be sure of what language is being parsed see bu eg for some undecidability results regarding recursive descent parsers nevertheless in recursive descent and operator precedence methods perform and can be quite efficient for example operator precedence parsers can be made to behave as though they are parsing according to the grammar g above while a pure lr parser would have to parse according to g reductions by productions such as exp term which are of time however optimization techniques such as those in au will eliminate such re in this and many other situations it is likely therefore that be widely accepted until they are capable as those produced by like to set down some of the ideas which parser constructors that meet this parsing techniques which have equally well to certain ambiguous ones gramming language constructs we shall mechanical parser generating techniques will never of producing parsers that are as simple and using ad hoc techniques in this paper we would we feel will be useful in the development of criterion we feel that many of the been applied only to unambiguous grammars apply especially to the natural grammars describing pro do three things in this paper we shall give some examples of how in grammars using operator precedence and recursive descent techniques can be naturally resolved we shall grammars consider by using how ll or parsers can be mechanically rules analogous to to resolve built from the same we shall define a generalization of the class of ll grammars that permits cal generation of parsers this class includes some ambiguous grammars including the dangling grammar described below which gave lr problems in their lll based algol compiler treat this paper is intended ambiguous grammars rather to be an informal exploration than a rigorous theoretical of what might be done to treatment of the subject ii contextfree grammars we assume that the contextfree grammar notation aspects of contextfree reader is familiar is explained in grammars here with notation the more hu and au we shall review formal only the definition a contextfree grammar cfg for short consists of a finite set of nonterminals which we denote either in style eg exp or as upper case letters eg ab a finite set of terminals as id etc for which we use ab or certain special symbols such a finite possibly t ion set of productions of the form a a where a is a nonterminal and a is a empty string of terminal and nonterminal symbols we use the to stand for the set of productions a a a a an one nonterminal is distinguished and called the start symbol the nonterminals and terminals of a grammar will be called the grammar symbols factor example and terminals g mentioned previously has nonterminals exp and id the productions are term and exp exp exp term term term term factor factor term factor factor exp id exp is the start symbol although this was not previously indicated define languages by means of of grammar symbols may be replaced by a right is any string of terminal and nonterminal derivations side of symbols any nonterminal one of its productions a and themselves a in a string that is stand for strings is the leftmost possibly empty and a y is a production nonterminal a contains no nonterminals then we write aa then we call this a leftmost if step and write aa similarly if a is the rightmost nonterminal if a aa and call this a rightmost step such that we use a star for example above and to lg rm we write a at if there indicate repeated application is a sequence lp r of proof strings i la ii r a iii for each i pi i the case r in which a at and iii is is not out example a derivation in g is exp exp term term term factor term id term id factor id id thus we may write terminal is replaced exp g term term exp id id rm rightmost derivation exp id so we certain id also at each step by at each steps lm in this derivation above the leftmost step and conclude such as exp non term are not rightmost although this relation happens thus we cannot immediately conclude to be true as one can see from the exp exp exp exp factor exp id term id factor id id id a derivation a form that definition if s is the form if s a or lm the sequence of steps every form string is in the language contains no nonterminals start symbol s g a then m leading to a has a leftmost defined by of a grammar and s u then a is a left right a is from s is called a leftmost and a rightmost derivation a cfg if and only if it is rightmost among a called res others generated than one definition a grammar is unambiguous if and only if by the has more than one leftmost derivation rightmost derivation otherwise the grammar is said no string in the or equivalently to be ambiguous language has more example the two leftmost derivations g is ambiguous for example the string id id id has exp exp exp exp exp exp id exp exp id id exp id id id exp exp exp id exp id exp exp exp id id id or string of call such we can make an ambiguous grammar unambiguous by defining leftmost rightmost derivations of the grammar in such terminals has at most one acceptable leftmost rightmost a function a rule a function a manner derivation that accepts that each we shall in this example for gj and that independently in paper we shall specify we can specify a rule is to have higher precedence than es rules rather informally for that and are to be left some of these ideas were developed defining a language in terms of an ambiguous cfg plus a set of rules offers certain advantages it is possible to define a cfg plus a rule that will define a language that is not contextfree gs however this is not our here we shall use ambiguous and rules to specify traditional programming language constructs more and more clearly than would be possible with an equivalent unambiguous cfg in addition we shall show how we can construct directly from certain ambiguous grammars and rules parsers that are more efficient than those constructed from the equivalent unambiguous one other application of the use of ambiguous grammars is in code optimization we might include productions for certain special subexpressions and statements for which we can construct highly efficient object code our rule here might be to use these special productions possible for example if there is a special ob language instruction to add a constant to an expression we might write the expres sion exp exp constant exp exp exp exp exp exp exp exp exp variable exp constant our production consistent with with production rule in addition to that given for is to be used in preference to productions the rule that takes precedence over would generate the more efficient g above might and the semantic object language also specify that possible action associated instructions iii lll grammars and parsers string called for certain we can find a leftmost derivation left parse in the language by a simple deterministic automaton shown a predictive parser of any in fig input predictive parsing table s pointer stack fig predictive parser there is an input tape upon which is placed the string to be parsed an input pointer indicates the current input symbol initially the input pointer is at the left most symbol of the input string there is a stack which initially contains only the start symbol the unique symbol marks the end of the input and of the stack at every point in time if the input in fig is in the language then x the portion of the input over which the input pointer has moved followed by aa the stack contents will be called the left form form represented parser by the parser in fig note that x is a string is the left of terminals a is the leftmost nonterminal and a is a string of terminals and nonterminals the moves of the parser are of three types if the current input symbol matches the top stack symbol pop the stack and move the input pointer one symbol right this move is made only with a terminal on top of the stack and does not change the left form represented by the parser if there is a nonterminal say a on top of the stack and a is the current input symbol a parsing table to determine a particular production a p with a and a replace a on top of the stack by the string p the input pointer is not advanced this move causes the parser to represent the next left if the current input symbol is and the stack contains halts and accepts the original input only then the parser example consider the cfg aa bb with the start symbol s the appropriate a s ss parsing table is b bb error error error with input aa the parser would the input and stack pointers make the following moves here indicates the location of the symbol is used to mark the end of the input and stack input a za az a aa stack a x left form represented by the parser s aa aa aa aa definition of terminals that can be the rightmost let x be a nonterminal can appear immediately to symbol in a or terminal in a cfg is the set the right of x in a form if x form then we shall include in definition the following a is lll if whenever two conditions hold a a and a are distinct pro there is no terminal a such that both a and p derive a string beginning with a at most one of a and is or derives e the empty string if say a e then there is no terminal a in such that p derives a string beginning with a for an lll we can construct a predictive parser easily for aa in the parsing table is the unique production y for some or y e and a is in a y if it exists if no such y exists not be more than one by the lll definition then the entry for aa is the entry such that and there steps example the sa but bb the other right entry in example is s aa since aa aa in zero side for a does not derive any string beginning with a descent k ls parsing ambiguous lll grammars are a natural class of unambiguous grammars for which recursive parsers which never can be and they have been so studied by w however there are certain ambiguous for which predictive algorithms recursive descent parsers exist and which like all grammars are not lll we now consider one example in detail of the language suppose we have a language such as forms if and also simply with if statement constructions part of the grammar for such a stat boolean exp then stat else stat if boolean c exp then stat i here c stands for other productions for stat such a grammar must be ambiguous to see this let us instead consider the cfg which can be thought of for if boolean a statement form as modeling exp the above and b with s for stat a for else for example models then if b then s else s where b and b are expressions and s and s are statements statement is dangling in the sense that it is not immediately executed when bl is false or when b is false the else in the above clear whether s is to be the string has the following two leftmost derivations s s as the usual solution to this ambiguity is to specify a rule that says an else is to be associated with the previous executed when b is false and only the second of a person writing a recursive descent parser would then in other terms s is two derivations is correct have no implementing this rule in fact it is probably reasonable to claim that only the resolution of the dangling descent parser else ambiguity is easy to implement would if the was by any parsing enough to left method factor the recursive the grammar s as follows given that we need to find a stat then stat on the input search for if boolean exp if succeeds check if the next input symbol is else only if the else is followed by a stat however succeed without looking further if if so succeed if and the next input symbol should of g generated the above strategy not only works not be surprising that we can design even though that grammar may easily by g is not ll the left it never causes backtracking a predictive parser for the left be shown not to be ll indeed version of g is thus it the language form g s as s c s b s i e the predictive parser for g is a s error bc error sc s bs error error s e for example the predictive parser would process as follows input c c c c c stack ss ss ss s s s a question is how the compiler designer is to know that his attempt to resolve the dangling or any other ambiguity works in the sense that he is not changing the language recognized by the compiler when he restricts his parser to throw away certain legal in general one cannot we shall see that g is in a class where the usual effectively resolution decide such but can be shown not to change the language defined by the grammar perhaps the best answer to the question is that in languages were always defined with the parsing method in mind what a recursive descent parser would recognize the standard and were later written to fit the language of course any notions ignore the real problem which is that it is in general impossible to tell whether an ad hoc parser with a language definition iv an extension to the ll class of grammars and also way and we shall now consider two classes of which include the lll grammars some ambiguous ones the grammars for k can be extended in the same the details should be obvious to the reader who is with grammars suppose we are in a situation where we have derived the left form and there are two productions a a and a such that ay and y each derive strings be with the terminal a then clearly we do not have an lll grammar however it is that in every situation where we are with a choice of expanding a by a or f one choice will always enable us to continue the parse to completion derivation or more definition of some steps definition a grammar is left terminal string we say a grammar g is not left recursive recursive if it has a nonterminal a used in the th at a aa for some a in a derivation of one g is in class if let way be a left form suppose a a and a are two productions in g such that a beginning with a terminal a can be derived from both y and y ax implies ay ax for all terminal strings x or ay ax implies jy ax for all terminal strings x condition the rule informally says that a predictive parser may always expand a by the more production on lookahead a condition prevents the parser from getting into a loop and that it will trace out a leftmost derivation of its input clearly every lll is in class since condition is trivially satisfied and no lll grammar is left recursive however certain ambiguous grammars such as g are also in class as we shall see we should observe that it is not immediately apparent if we can effectively determine whether a is in class in fact we shall show that if it is decidable whether a cfg is in class then we can solve the inclusion problem for the languages generated by class grammars we shall therefore progress to a smaller class of grammars which is effective but contains at least g in addition to the lll grammars definition symbols x such that e given an cfg and a nonterminal or terminal such that there the case where y is itself the a define is some left empty string fa to be the set of form is not out productions definition we say a cfg is in class the following two conditions hold if whenever a a and a p are distinct there is no terminal a such that both a and derive a string beginning with a at most one of a and p is or derives e suppose p e and a ax for some terminal a such that a is in then for all x in fa such that x a x does not derive a string beginning with a this rules out the possibility that xa we can can also be shown when condition choice of expanding easily show that that condition of the class a by a or with and imply that there is no left recursion it of the class definition is satisfied in definition and we are presented with a a as the next lookahead symbol we always choose a grammar it is easy to compute is in class fa for each nonterminal a and thus decide whether a grammar example the grammar has productions g the left version of the dangling else we shall show that g is in class and hence in class the lll definition so we certainly get no contradiction the s productions we observe that s bs derives a string also in follows we must therefore check that s is the strings beginning with b the productions for s satisfy of the class condition for beginning with b and b is only symbol in fs that de we note that s is in fs since s lm are no other members of fs so condition of thus on lookahead b we must expand s to bs rather is the one given in section for example the class definition than e the predictive however there is satisfied parser gen terminate example let us consider a block structured language all open blocks the following abstracts this in which situation an end will stat list begin begin c stat list list list end i i stat here c stands for the productions for simple which the productions are is statements the left form of g stat stat list begin list c end e stat list e with end eg violates gg is not end is but end is observation the lll definition for example end in follow stat together with the fact that obviously derives begin e is a string a production begin however gg is in class it is to check that occurs to check condition we find f f we because of the pair of productions does not derive a string beginning with end no violation of condition end e that also because of not a string beginning gg is class ­ with list clearly e we must check that neither of these derivations exist does so the predictive parser for is stat list begin end c j here the numbers refer to the productions in gg left class we would now like to show recursion is easy to demonstrate grammars that whenever a a p e a derives strings beginning that every class and we omit this and a p are two with a and grammar part of productions is in class the absence of the proof we must show for such that a is in s way wy m lm lm then ay ax since the is in class we may assume that does not derive beginning with a and that no symbol but a in fa derives strings beginning with a a string is is in y then the derivation y ax can be written by y xy ax that lm lm lm im y y e and x derives a string beginning with a or x is then x so x s a since x derives a string beginning with a the first step in he x ay must be x a thus there exists another leftmost derivation ay lm lm y y e x e and y derives the string z such that yz x we have z thus way proved we now have the following theorem im theorem every class is in class to skip at this point we directly to section vii the reader who is not interested in the theory of ll grammars v properties of class and grammars let us first normal form where each the form a i aa a only when there observe that every class grammar can be production is of the form a or a e the production a e will be used by the is no production of the form a aa put into a and no two predictive modified productions parser are on look of to put a grammar in this form we observe that for each nonterminal a on top stack the predictive parser on lookahead a will either halt or cause a to be replaced or more steps by some string of the form aa or by the empty string to construct the grammar for each such situation we create the productions a aa or a e respectively new clearly generates the same language as the old and is in the desired form of the in one new the is not on top begin stack halt other example let us consider g from example the only production whose right side empty and does not begin with a is list stat with list of the stack and begin list as the next according input symbol to the parser list is replaced of example with in two steps by c on top of the list is instead replaced by list c other inputs cause the parser to we thus give i c our new grammar the productions for the nonterminal list begin and the list of gg for nonterminals than list we shall state without proof the following theorem mar in parser of the theorem every which every production for the grammar does form a aa class class is either of not on lookahead has an equivalent class the form a aa or a e moreover a expand a by a e unless there class predictive is no production class using theorem we can show that certain rather primitive languages do not have a theorem the language l has no class grammar proof be omitted the proof the one given in ls to show that l is not lll and will a one state which makes in a move a one state pushdown automaton one state on only the current input symbol can is a deterministic and the symbol pushdown automaton on top of the stack replace the symbol on top of the stack by some string of symbols and shift its input head one symbol right or keep it stationary one state have been studied by fi and they are equivalent to the schemas every language that has a predictive parser is also by a one state generated the language i from theorem is by a one state thus by class are a proper subset of the one state languages the languages vi effectiveness of class languages class lie mentioned ie whether earlier that it is not clear if one can decide whether a the class if effective however one can show the following is in ble for theorem two class ii it is decidable whether grammars g and g whether a cfg is a class lg is included grammar in lg then it is proof using whether lg is assume that we shall included in we have construct lg an algorithm an algorithm to determine to decide whether a for class is in class g and g first one may test au for arbitrary g and g whether a lg contains e but lg does not b lg is empty but lg is not c for some terminal string a g generates a string beginning with a but g generates no such we may begin any of them hold then our test for inclusion lg is not included with tests for the above three in lg and our test ends conditions if g and terminal now assume that none of g that g and and be a new a b or c hold g have no nonterminals let s and s be the start symbols of in common let s and s be new non construct a new grammar g with the productions of g and g plus s s i s s and s e now if lg is included in l then the choice of s s s over s s condition of ce definition of class grammar when the nonterminal is s and the terminal is arbitrary also no other violation of the class definition can occur for g since g and g are in class by hypothesis suppose lg is not included in lg then since conditions a c do not hold aw in lg but not in lg and also find ax in l for some x then consideration of aw tells us that s s s does not take priority over s s on lookahead a and consideration of ax tells us neither does s s take priority over s s s this violates the class definition thus g is in if and only if lg is included in lg on the hypothesis that we may test whether g is in class we would have an algorithm to test set inclusion for class grammars to put theorem in perspective class or even class grammars would even for the simple of whether inclusion is decidable we should observe be a powerful result a trivial that decidability recall that it subset of the lll of inclusion ts not known grammars for moreover if we could test inclusion of languages we could clearly test equality of languages since l iq if and only if l is included in l and conversely thus if sion were decidable even for class grammars we would have an extension of the decidability of equivalence for ll grammars rs it should be observed that the proof of decidability of equivalence for ll grammars see au or rs breaks down even for class grammars since the latter may have arbitrarily long strings of those that can derive the empty string in their left forms vii and parsers predictive parser natural we have parsers we cannot grammars seen that the controlled use allow more natural grammars expect to extend the language of ambiguous constructs can give rise to faster and extend the ll language class with an lr class but we can obtain faster parsers for more consider the rightmost derivation exp exp exp exp factor exp term t id id factor id i id id in the grammar g an lr parser the sequence of productions used a right parse would trace out this derivation in reverse in the reverse of a reverse of a rightmost we call derivation for certain grammars we can find a right by a machine shown in fig called an lr parser parse of any string in the language input input pointer parsing table stack pointer fig lr parser an lr parser is similar to a predictive parser in that it has and a stack however unlike the predictive parser the top of the stack instead of the left moreover at every point in time if the input in the language then az the sequence of grammar symbols on the stack the portion of the input not yet used will be called the right represented by the parser in fig is the right form the parser an input tape is at the right in fig is followed by ay form represented by places of the however in addition to putting grammar special symbols called states on the stack stack will be a sequence of the form symbols on the stack an lr parser in fact at all times the contents where each s is by m move is found in goto table the move one a state and each the state on top the parsing table move is determined of four types xi a of the stack which consists by the entry symbol and a of for the next the current two parts sm and a in move of the parser is input symbol this an action table and a the action table the shift s the current input symbol a is s is then placed on top of the stack on to the stack and the state this move has the effect of ad the input pointer one symbol to the right reduce by production a p suppose the right side is of length r then tr are off the stack that is s removed from the stack leaving the nonterminal a is placed on top of the stack the goto table is then and the state in the entry for sm and a is placed on top of the stack when a reduction by the production a is called the stack will for xm the string of grammar match p the right side of the production symbols removed from accept the parser halts and successful completion of parsing error the input string is not in the language to an error recovery routine being parsed the parser trans c e if a shift in a reduce move the right move it does suppose form represented by the parser does not s g m rm rm is a rightmost right the reduction form with derivation in the grammar at hand an lr parser would represent form with af on the stack and ay as the input the after by the production a the parser would represent the right aa on the stack certain example consider the following grammar symbols abbreviated g expression et grammar g which is g with tf f e fa a parsing marker action table for gi is shown below as before represents the right end state o err sh red red err red err err sh red red red il terminal err err sh red err red err err err sh red red sh err err err sh err sh sh err err err err err err red red err red err err sh red red red action table a sh err err err sh err sh sh err err err err t err accept red red err red err e r err red red red in this table by production err stands for error sh i stands i the goto table is for shift i red i stands for reduce state o z z nonterminal et f goto table the above r the entries in the goto table are never action and goto tables parse the string referenced an lr parser a a a in the following stack o oa of t oe oe et et et oe input a a a a a a a a a a a a a right represented by the a aa aa a f a a ta a ea a a ea a ef a et a et a et a elt e form parser using construction of simple parsers grammars construct we shall sketch called the simple an parser a technique that grammars will d produce parsers for a class of let g be a cfg for which we wish to first we augment the grammar with a new starting production of the form items for the state to determine the states of the g an item is a production in how much of the right side associated with that item parser we construct the collection g with a dot in the right will have been recognized when the of sets of side the parser is in we define a function closure on sets of items if i is a set of items is the smallest set of items that contains i and has the property if a is in and b is a production in g then b is in an easy way to compute is to begin with i and continue adding new items the form b to i for each production b in g and item a ab currently in we continue adding items to i until no more new items can be added the resulting is of i set we need to introduce one other function the goto function on sets of items if i is a set of items and x a grammar symbol then j where j is the sure of the set of items a i a ax is in i computing is straightforward we take each item in i with an x immediately to the right of the dot we shift the dot past the x and add the resulting item to j we then compute the sure of j to construct the collection of sets of items for the given grammar g we begin with c a collection of sets of items that initially contains closures s then for each set of items i in c and for each grammar symbol x we compute and add the resulting set of items to c if it is not already there once we cannot add any more sets of items to c we have computed the collection of sets of items for the grammar example the collections of sets of items for g is given below e e et t tf t f e f a e e e et et t tf t f f e e et e t t tf t f f e f a f a et tf e tf e f e e et e et t tf t tf f e struct items parsing given c the collection the action and goto tables in c there will be a state action table entries for of sets of of an let state state i are items for the given grammar g we can con parser for g as follows for each set of i correspond to set of items ii the determined as follows if ii contains an item of the form a aa where a is a terminal then the action of state i is shift j where j is the state associated with the set of items if ii contains the item a u and a is in on input a is reduce by production a a then the action of state i if ii contains the item s s then the action marker is accept of state i on the right end otherwise the action of state s on a is error with the goto table entry for state the set of items i on nonterminal a is simply the state then parser error form if at most one move is defined for each entry the given grammar g is said to be simple it so constructed is a valid parser for g moreover on input a after having scanned x provided there for any z of the parsing can be shown the parser is no string action table that the will in lg of the example the action and goto tables for the collection for g given in example are those in example of sets of items ix parsing action conflicts let us now examine what happens ambiguous grammar let us first consider new nonterminal names when we try to build an parser for an the following grammar g which is g with ee ea the collection of sets of items for g is g e ee e ee e e e a y e e ee e ee e a e a e ee e ee e ee e e e i a ee ee e e e ea ee ee e ee e ee ee i ee ee e e these action by as before we can try to construct the parsing sets of items however sets of items i and table with more than one action these multiply and in the action table shown below action and goto tables from give rise to entries in the defined entries are represented err sh err red err err sh red err sh err red err err sh red action sh err sh err sh sh err err err err table a err err red err err sh red red red sh err sh err sh sh err i err err err goto table err accept err red err err err red red red each of the multiply conflict defined entries in this action table happens to represent conflict conflict conflict conflict between between between between shift shift shift shift and reduce and reduce and reduce and reduce a in the multiply solved will effect defined result the grammar g will permit many different entries in the action table represent in the selection of one of the possible for certain choices which when for a given input strings uniquely re input string parser reduce as an example of these to have state on top of then the input string choices we may observe that the input string the stack if we replace the entry in the a a a will be parsed a a causes action table the by e ea that is shift would be treated as being left associative then the same string would be parsed on the other hand if we replace by ee e e ee e ea e aa a aa here is treated as being right associative we could also by error doing so would make be a v lt in fortran the string a a a would illegal like thus the question of how we should resolve the parsing action is directly connected with the question of the desired associativity conflicts present of the operator in now examine the entry similar reasoning shows that if a a a as a a a ie has higher precedence then should wish a a a to be treated as a a a then should be reduce the option of this input string by replacing by error we wish to be shift again associate if we we also have in the same fashion we may observe that the input string a a causes the parser have state on top of the stack the entry the associativity of the operator and the entry reflects the relative precedence of following to along the following table with a brief description gives several different of the red sh red red red red sh sh red sh error red sh error red sh error red sh error rule used of the ambiguous entries rule the usual interpretation and are left associative and has higher precedence left associative right associative has higher precedence and evaluated left to right and evaluated as right to left precedence specified must be fully by parentheses thus for a grammar like g we can give defined entries in the action table a clear meaning to the of the multiply suppose we resolve the entries of the input string a a a goes as according to the top row of the above table a parse stack o oa oe oe oe input aa a a a a a a a a a ai there is a close correspondence between this parser and the one given for g in example g uses the first four productions to enforce the left associativity of the and operators g also uses two nonterminals e and t to make of higher precedence than however introducing these nonterminals requires the use of the productions et tf to allow a factor to be trivially reduced to a term and a term to be trivially reduced to an expression these productions are called single productions and they serve no other useful syntactic purpose a language may have operators on ten or more different levels so that in parsing expressions a considerable fraction of the time can be spent in making reductions by these single productions in example the lr parser for g made moves parsing the parser above makes only ten moves when we are parsing we can skip the reductions by these single productions we take into account the and precedence levels of the operators in an algorithmic technique for eliminating reductions by single productions of this nature was pre if we apply this technique to the simple parser for g we obtain the parser for gg given above thus by using the ambiguous grammar g and precedence tion to specify the associativity and relative precedence of and we can obtain the reduced parser directly this easier to read can be directly the equivalent is equivalent grammar au direct procedure has several advantages first of all we have a smaller and grammar for our language secondly a more efficient parser with fewer states obtained from the ambiguous grammar and the precedence information than from unambiguous grammar moreover it can be shown that this more efficient parser in a useful sense to the simple lr parser constructed from the unambiguous the work of el should also be mentioned there given any operator precedence grammar one obtains a bottomup parser that works in an style on a grammar see au the method does not unfortunately guarantee that the language parsed is the same as that defined by the original grammar it does however produce the parser of example for g so in at least some cases the language is not changed in fact our analysis of g can be extended to the following class of lower consider a sequence of n left associative precedence than il we ca ambiguous grammar operators and assume i has e e ea when we construct each is of the to reflect the simple resolution the parser for this grammar we find n ambiguous form h state s on input i we may either shift given and precedence levels of the rule if i j shift otherwise reduce entries or reduce operators in the action table by e e e we may it can be shown that when the are resolved in this way the resulting parser analyzes expressions giving the proper and to n the resolution rule can be easily extended to deal with right associative and binary operators as well as several operators at each precedence level for example we can list the operators in order of increasing precedence on line we list all operators that are on precedence level each operator we can specify whether it is left associative binary or right associative on the next line we list all operators on precedence level together with their and so on these ideas have been implemented in a called at bell where the terminals precedence notice that in a scheme grammar is ambiguous such as words scheme of this nature thus there is or parentheses the precedence information is only no need to specify for as one would have to do in a purely operator an analogous technique can be applied to the abstract ifthenelse grammar g s s as s c the collection of sets of items for g is ss t ss s as c s s s s as s s as sc i s c as bs s as s s as sc s the resulting action and goto table are shown below state o z a sh err sh err err sh err terminal b err err err red err red c err err sh err err sh err action table nonterminal err accept err red red err red e goto table since shift last follows b the entry and reduce by s as this b with the last available then for state on input b is a conflict between if we choose to shift on input b then we shall always a this would correspond to associating an else with the let us review the main ideas of this section we have seen that an ambiguous gram mar gives rise to an lr parser with multiply defined entries in its action table if we make each multiply defined entry singlevalued by choosing only one of the possible actions or error in with some rule then we obtain an lr parser that will parse a subset of the language defined by the original grammar the resulting language is a contextfree language and there exists an grammar for it an lr parser simulated by a deterministic pushdown automaton for short moreover for every we can find an that defines the same language as that recognized by the au thus several definitions are possible for the same language we have seen several practical examples where the ambiguous cfg and a rule provides the more natural and description x summary we have seen that by using ambiguous contextfree grammars with some rather simple rules we can obtain definitions of languages that are and easier to than an equivalent definition in terms of an unambiguous grammar moreover if rules are carefully chosen we can often resolve the parsing action conflicts in a straightforward way and obtain a parser equivalent to that constructed from an equivalent unambiguous grammar the a number of open questions remain in rules that reflect current but still formalism for specifying step we would also be interested in knowing to rules should be used to obtain the this paper we have used rather in language design rules would what extent ambiguous description of a language informal dis a more gen be the next and references au au bu cl d ds a v aho and j d unman parsing the theory of parsing translation nj and compiling volume volume compiling a v aho and j d unman june a technique for up lrk parsers siam j com e z manna and a pnueli schemas j acm decidable properties of monadic functional a ieee and j d unman annual symposium parsing algorithms with on switching and automata theory conference record pp of m e design of a compiler comm acm f l simple lrk comm acm o j w de and d scott a theory of programs unpublished manuscript es el fi fl gs hu k ml ls m rs s w j department ambiguity and precedence in syntax of computer science university of technical berkeley report n el extending the lr parsing de technique to some of engineering grammars tr princeton m j fischer some properties theory of computing may of precedence o languages proc acm symposium on r w syntactic analysis s and e h theory and operator precedence control sets on grammars j acm mathematical systems j e hopcroft addisonwesley and j d unman reading mass formal l languages and their relation automata d e knuth topdown syntax analysis acts informatica a j and j e hopcroft simple record of th annual symposium on switching deterministic and automata languages theory ieee conference pp p m lewis and d j an algol compiler the proc symposium on computers and automata ny pp designed using automata institute of p m and r e syntax directed r m an of compiler technology computer conference press nj proc j acm joint w m d j information and j j and control nj and r e d b properties compiler of deterministic generator topdown r e deterministic conference on information topdown parsing sciences and systems proc fifth annual pp princeton d the theory of left and languages computer j 
conference record of the fifth annual acm on principles of programming languages a metalanguage for interactive in m gordon r milner university of l morris university m national university c university of edinburgh introduction for functions is a generating system of an inter active language for in predicate acalculus a deductive calculus suitable for the of reasoning recursively defined functions in particular about the syntax semantics and of many languages is an in respect of type structure and expressive of an extended acalculus due to scott and is fully discussed elsewhere i the of this paper are a to illustrate the features of ml which me it of general interest in language design quite independently of its use for machine formal b to illustrate ml applied to in encoding interesting procedures and c to a methodology for controlled automatic proof we avoid formal we hope that our and discussion will achieve these purposes clearly a description of ml and its use with exists as a the work was of great using lisp on a dec by the science under grant n system of ml and over three years at edinburgh for two years the system has usable and its development is now recently it has been used in various studies concerning formal semantics theorems about data structures recursion direct versus continuation semantics and other topics the need for and design of ml is based on experience with an earlier system at stanford in that system beyond the ability to direct it to execute a basic inference eg beta conversion or transitivity of equivalence the user could a invoke with respect to a set of equivalences specified by b adopt a style by builtin tactics based qn the inference rules and simplification and c use theorems previously proved these facilities were enough to enable several nontrivial case studies to be but further use of the limited by the fixed and rather primitive nature of its of rather like using an interactive language and one without a one is working all feature the t at in at toplevel contained many instances of a few patterns of inference which one would like to express as derived inference style as derived rules or in the tactics or strategies our present point of view is that neither a straightforward checker and ret to use nor an inefficient because of general search is is required is a in which a user can both design his own partial strategies where he can find them and execute single steps of proof where he needs to we believe also that although formal proofs are and should be it is pragmatic more to achieve clear expression of pf which strategy the latter the strategy is built entails that the way in from should be evident in its in other words we re not so concerned with checking or generating as with per forming s we t normally store or display proofs but only the results of them ie theorems these form an abstract type on which the only allowed operations are the inference rules of this ensures that a welltyped perform proofs it may not prove the theorem expected but the result be a theorem if extra security or formal checking is desired full proofs are easily generated only minor changes in the implementation of the abstract t for theorems be required the principal aims then in designing ml were to make it impossible to prove yet easy to strategies for performing a strategy or for proof be thing like induction on f and g f by and doing case analysis all interleaved with this is analysis of what cases what kind of induction etc etc but these in turn may well be given by further still in the style the point is that such strategies appear to be built ones which we call tactics rather than strategies by a number of general operations in fairly regular ways we call these operations by with functional for tactics and and generally for manipulation of pp in f the following in ml were soon found to be almost necessary the ability to handle higher order functions a rigorous but flexible type structure a mechanism for gen and failures and an abstract of the object language acknowledgments we are to for providing a large part of the theoretical basis for to john for the of this project at stanford to richard who greatly to that project to hoare and for help with the notion of abstract s in ml to for help in the final design stages through her experiments to burstall and many in for discussions outline of ml ml is a functional language in the of pop and but differs in its handling of failure and more so of it is an language though expressions may have sideeffects because of the presence of assignment the expression x e has as value the value of e and also gives x this value an expression construct is let x e in e which binds x to the value of e throughout e alternative forms of declaration are let f xy e for def functions letrec f xy e for defining functions recursively x e for and variables and of these forms for declarations another expression construct ie read e or else e whose value is is the value of e unless e generates a failure in which case it is the value of e the generates certain failures and the user may generate his own with the expression fail or the expression e where the value of e is a token which identifies the kind of failure a generalization of the form e e can be used to trap only certain failure tokens kinds of failure the type token is one of basic types tokens are just strings in our current application of ml the use of failure as a dynamic and mechanism a natural style for tactics and strategies which are usually able to certain goals as above if d is a and e an expression then d in e is an expression in interactive which is how are one evaluates a mixed sequence of declarations and expressions separated by ml is a static binding language like and but unlike lisp and a free variable z in the declaration let fx refers to the enclosing declaration of z not to any declaration an example which illustrates most of the features of mt is a generalised scalar product sum the of two vectors which is param on its and functions and on a zero for null vectors two ways the first recursive and the second iterative of writing this in ml with vectors represented as lists and failure for vectors of length are as follows letrec zero u let in xl il l and x l xx x if null then else zero fail let zero u i i zero p in q q j where x and x if else fail notes letrec is equivalent to letrec f similarly let that is scalar prod are defined here as partially functions as is the style in functional the separation of into two groups allows to be partially applied to three to obtain particular scalar functions it also suggests a more efficient recursive definition in which we replace letrec zero kl zero by a form which arguments on only let l n zero t to a token enables its as a infix without the use is the cons function use on the left of a declaration as here binds xl and kl to the head and tail respectively of with failure when u is null the failure of the declaration is null by here is that when one of r l q e e until failure the functions and make se on a wide variety of objects applications of either are welltyped provided their arguments have types which are instances of cl x by y x where a are t variables and then the result is a function which has the corresponding instance of a list x list we say that the type as its type a list x f list is generic for or this means that these functions may be used at any type which is a substitution instance of the generic type in which a are type variables thus since x are arithmetic functions in and using the ml notation for lists we have x x x using its generic t at the instance b of to define a function which given two vectors bl cl cm of truth values will count the number of times that bi and ci are true we may define let where o bl b if bl b then else o using at its t instance and y int we may even define a function of type a list x a list list a list such that xl m using the definition is function the let nil using at its type instance notice then that and a type which contains type variables they are functions the of should not be with the present in the object language we will briefly to the latter in a later section such with respect to program types is possible to a greater or extent in several languages eg which allow procedures to have explicit type parameters ml relies instead on a typechecker which not only checks that functions are used consist at instances of their generic type but can in nearly all practical cases infer the types of all variables without these being supplied explicitly eg it will infer the type above for and thus we close to the discipline which a program will impose in using a language such as lisp it is in interactive to be of the need to specify types with that phrases will be and not evaluated of course for offline program ming it is to specify the types in declarations the types of formal param and we are aware that many prefer to adopt such a discipline for and for to this end ml always the user to his types explicitly if he to write letrec xf y u a list he can do so and the typechecker will check these types for it out that in the presence of essentially the same typechecking is necessary even if type specification is made unless indeed the type of every expression were required which would be able the typechecking method may be illustrated by a consider the following function for mapping a function over a list letrec if then nil else the generic type of map should be y x y list list how may we infer this type the declaration first the generic types of the identifiers occurring free in the declaration are null a list bool nil a list hd tl a list a list and we require that every occurrence of such an identifier is given as type a substitution instance of its may be assigned generic different type different type instances every occurrence of a formal parameter must be the same type and every occurrence in its declaration of a recursively defined must be given the same type third if we denote by uid the type to be given to each in the declaration then besides the above constraints on etc the equations must hold for some types map null f x hd c tl f tt map f t x t t nil each of these equations except the last arises subexpression which is a function application the last arises because a conditional expression is given the type as its two arm and because the and of a declaration are given the same type non if we distinct type variables lt and a list nil for the variables set u null etc the equations tt may be solved and map f using unification it turns out as the reader like to that for distinct pair of variables we obtain g map as expected this then is the generic type map which may be instantiated differently each later occurrence of the identifier of for does not illustrate all the typing constraints there are further rules concerning the instantiation of generic types of variables declared within a function my for example the type of the variable xl in the declaration of is fully determined by the type of the formal parameter l and the rules will demand in this case that xl is given the same type at each occurrence and con the types of variables declared by in particular like formal parameters they must be given the same type at each occurrence for the algorithm and a of its correctness the for a is in fact language see rather straight forward ml also includes a facility for defining abstract types including simultaneous andor recursive andor ones in ml these are not really abstract in the sense of the algebraic abstract types of eg or but rather are analogous to classes clu clusters and forms as the latter are by now wellknown it will be enough to describe briefly our syntax for abstract type declarations and give a simple example the declaration form is with md where the identifiers id are the new ts being declared each is a sequence possibly empty of type variables the formal parameters and each ty is a type express ion the part with has the syntax of a normal declaration but with let replaced by with and defines the operations or other objects ble at the new types the essence of abstraction is that one may get at the represent ation of the new types only in the and this representation is provided by two of the and for each type identifier id between each type and its representation for mutually recursive types one must use in place of we give as an the of the ml type operator list for lists note that the functions are they are a ax a list where the basic type is that by the expression between s is disjoint with just one and the declaration is with and and and and a list a x a list nil xf tl the and functions inl and m d and are left and right projections with failure for arguments in wrong and predicates for disjoint sm types we have types and words in this paper for clarity but our implementation requires no we have it for newly declared types functional types are allowed in abstract type declarations and this yields interesting possibilities a simple is streams a notion of infinite implicit lists due to here is a definition which provides two stream operations one for splitting a into its first and and one for building a stream a function of the numbers a stream a x a stream with a and str a a stream str f f w an aside we can that the of types also gives us the of recursion so that in the presence of the letrec construct is redundant in fact a fixedpoint function fix can be defined so that exact ly equivalent to let f e is f e the reader may like to out how the f does the trick cl with fix f f f where f y y x in ml is discussed in ml via abstract types one for each of its principal syntactic classes s could be adopted for the discussion of any syntactic system within but we have also built in the special ability to discuss h terms of a concrete representation of its syntax this is a necessary convenience to provide concrete syntax for other syntactic systems the user would need to write in a parser and an to map f concrete to abstract syntax and the of are those of a f predicate calculus built by conjunction implication and universal quantification atomic ones formulae are equivalences and ie partial ordering terms of a typed acalculus with a f operator a conditional operator and other constants many of these constants including the two mentioned are as with ml the involves the use of type variables and t instantiation is one of the inference rules of thus is in ml by the three abstract type types form term and objects of are syntactic they are type express ions primitive operations provided at these ml types are constructors and destructors of are token x term a variable consists with a type of a token term a combination application or function term x form to build an formula tem x form the term must be a variable and to each constructor corresponds a destructor etc of inverse functional type destructors fail if their argument is not a or form of the right sort eg will fail concrete syntax is provided via this syntax is what one would expect and allows ts to be mentioned explicitly although the system will often deduce types using a to that in ml here then are two equivalent ml expressions of type form assuming that the user has introduced integer as a type see the later section on x integer x x let x x in integer xx er a device which we call l j allows expressions of appropriate type to so that following is also equivalent to the above the let x in now a of is an object of form list x form is a sequent calculus so a theorem is a which follows the represented by the inference rules as lr on output a theorem is theorems of may not be input but only and for this the and inference rules are provided as primitive objects at the abstract type we give part of the definition of this type the types of the inference rules mentioned are t m thm form list x form with assume w w w and let rw th in if x x e then f gen r infer w w lw infer r i vx w when x is not else r free in r and th and t transitivity of and reduction and and notice that is provided to the user under the to to his theorems syntactically but he is of and thus that all objects of are indeed theorems since he can only make prove them with the inference rules the calculus was discussed in detail in our present provides essentially that calculus but for convenience and efficiency many of the are presented as infer ence rules of there are about than strictly necessary again for goals tactics and as a simple example to illustrate our method consider an obvious fact conditionals for t read if t then x else y i t x y z w tl t i t t tl xz tl the natural way one would prove this strip off tie quantifiers consider informally is any t t w then do case analysis on any term in and do any that are possible so as a tactic for this and many other similar goals we like to write then as a first approximation a tactic should take as argument a goal and produce as result a list of we shall here assume that a goal is a sequent that is go form list x form though we in fact use a slight ramification of this type the idea is that by repeated i e tactic application we shall reach which may be achieved by theorems until no sub goals are left a theorem r iw is said to achieve the goal r w if up to w w and the formulae of r in the goal are to be thought of as assumptions or all of which may be used in proving w but now we can see a in our first to a tactic that a tactic t applied to goal g has generated the list gl gn and that theorems achieving gi s i s n have been found who is to deduce a theorem th achieving g our answer is that it is the job of t to provide a way of performing this deduction to this end we define tactic go goal list x and we call the of a tactics result a validation we a tactic has generated an goal list the valid of the can be to yield a theorem and this validation a function can be generated as part of the of tactics not all tactics will be very useful lie shall call the useful ones valid related but not identical with use of the word t is a valid tactic if whenever tg gi and whenever achieves i s i s n then evaluates successfully to a which achieves g in particular when n o ie t reduces g to an list then p achieves g and we say that t solves g eg the tactic this when tie simplifies to an obvious to illustrate here is a tactic for quantifier yielding one which is inverse to the basic inference rule w where we write in types explicitly as an aid to the reader let rw go let w in let x variant x w r u r goal x o hd s where o is and variant x vars x if necessary to obtain a variable not in the list vars the call of variant in is needed to ensure that it is a valid tactic in this case to prevent possible variable causing the validation function to fail when applied to a singleton theorem list where th achieves the one produced by note that at worst an invalid tactic can fail or prove the wrong theorem it can never produce a false theorem other elementary tactics are also easily defined eg for case analysis on a term three the true false and undefined cases and for induction two ­ the induction basis and the induction step we are mainly interested in valid tactics though one may of a tactic we say that a valid tactic is strongly valid if whenever the goal is by theorem so is each of the one may not always be able to use strongly valid tactics consider for the heuristic tic for proving vn f n gn by finding function h for which w f n hn s gn in particular we find that vh n n true and over the nonnegative integers but vn is false not relevant is that various induction rules in reverse yield tactics which are not strongly valid it is good practice to use strongly valid tactics when and always to use valid tactics are on tactics building simple tactics into ones obvious are binary then apply a tactic to all produced by a first and try one tactic or if it fails try another and a unary one repeat iterate a tactic until defining these and many others in is a straightforward exercise in functional g with lists it is easy to that then and repeat preserve the validity even strong validity of tactics it is worth noting that this style could be adopted in general for problem solving all that is involved is a type goal a type for proposed solutions which might be called and an relation between and goals useful tactics and and them in ml is a of study in the various applications to do with formal which we mentioned in the introduction theories in our discussion of pp we did not suggest the variety of its application in fact just as firstorder predicate calculus or any pure may be extended to an applied calculus by the introduction of constants and non logical so may be extended an part of this extension is the introduction of new types the only nontrivial primitive type available is that of new types may be either introduced independently or defined perhaps recursively in terms of existing a set of types with new constants and is called a and all work with consists in setting up theories extending them or joining them to form larger theories or adding new useful to the list of those proved in an existing theory theories are preserved on files to allow tal working for each t there is a fixed file t with the types and and a file t of useful theorems facts for example one to prove the correctness of a compiling f ran to target language l one will develop first a theory of and a theory of l we give the theories these names then join them and extend the result by adding a constant of type say and an defining this function the resulting theory might be called its parent theories are and l and one of its theor will assert the correctness but itself will be a theory one of its parent theories will be the theory of syntax the types in this will be such as etc the constants will be the abstract syntactic operations such as and the will these operations further and will be concerned with auxiliary syntactic operations eg a predicate for whether an identifier occurs free ie non local in a block the theorems of will be about these purely syntactic may have a parent the theory of integers if for example one of the syntactic operations counts the of free occurrences of an identifiers in a block another parent theory of algol will be this is the theory of d used to specify the semantics of and may in turn have parent theories int real etc to various data types algol itself will be the join of and extended by the definition of the semantic function call it whose type will be perhaps where is the type of machine states introduced in of will have nothing to do with are many interesting for there results to be proved concerning transformations of programs so far we have outlined an g for the theory in mind that the basic is an ancestor of every theory the graph like this all and of course the subgraph for l in particular has not been discussed we refer to for the details of theories here we will by that it appears to exploit the full power of an interactive proof system with out f such as theories provide within which to work relations with other systems there are several dimensions can be with other proof along which systems checking vs proving at one extreme a system just accepts proofs and then simply checks their correctness a sophisticated example of this is the system of de bruijn et al i at the other goals are and an is to achieve them are early resolution theorem proving and the on structural induction between these is a can reduce the of a pure checker by increasing the gap between proof steps these being by eg a simple theorem prover for example the stanford system did simplifications but otherwise the proof had to be provided by the user conversely a pure theorem prover can be made flexible by a user to provide information perhaps to guide the search for a eg this is one of the aims of the project our aim is to construct a system which can be used at any point on this for s problem areas there already exists useful strategies eg moore i for induction on lists for integer arithmetic and we would like to be able to them up straightforwardly in other less explored areas we want to experiment with manual to patterns of inf ex ence once these are they can be as ml tactics security w systems based on general problem solving languages like or there is a that in a wrong may be done this is greatest for systems which are not based on any explicit logic eg for these it is not even always clear what the valid are ever even when an explicit logic is used eg von and which is based on inference system there may still be a that invalid of theorems might this is so if users are allowed to strategies in we give the user the to write his own tactics in ml but the typechecker ensures that these cannot proofs at a tactic can lead to an theorem for which does not achieve the desired goal a of systems are to particular languages thereby enabling efficient special heuristics to be used eg such systems are for reason ing about algorithms encoded in their particular language but cannot perform proofs languages ­ of theorems eg proofs of we have tried to get the best of both heuristics and generality by our system not to any ge eg l pascal etc but to the deductive system and then facilities to enable various particular languages to be as theories efficient special tactics can then be in ml for these theories note however that itself is oriented about of recursively defined objects of various ts viz ins of of computation and so reasoning about other obj may be indirect the stanford ml system of is based on a general and it r to be established whether this extra generality is needed eg for reasoning about applications of programs to the real world there is a off between and specialization is just general enough to handle reasoning the syntax and implementations of programs but is fairly specialized to these l m r the semantics of pascal in ai memo science dept stanford r structural induction phd thesis university of rs more j s proving theorems about lisp function jacm jan bm f m a deductive system for elementary conference edinburgh de bruijn n g a language for t h report of university burstall rm r pop refer ence manual in machine intelligence eds e d new york oj et al the base language centre a a language designed for proc acm rd nat conf systems press princeton n j m milner r c edinburgh b department of science internal university of the specification and ation to of abstract data types phd thesis university of pj of the language university von fn dc for verifying proceedings of the international conference on reliable soft california c a language for manipulating and proving theorems in a ai project mac mit hoare car an axiomatic basis for cacm vo pj languages the next cx acm liskov bh s with abstract data types proc of a on very highlevel languages notices april r implementation and application of logic for functions proc acm conf on proving assertions about programs notices jan milner rr ic for computable functions description of a machine ai memo science department stanford r semantics proof proc course in found of science mathematical centre milner r a methodology for perform ing rigorous proc st ibm on mathematical of science milner r a theory of type g department of science internal university of in milner r fl m a for computable functions with reflexive and polymorphic types proc conf on proving and improving milner r r proving correctness in a logic in machine intelligence ed d edinburgh university press m formal semantics of lisp with applications to correctness phd thesis stanford r er a manual technical note artificial intelligence centre park california reynolds jc a language based on the principle of completeness and the reference concept acm may x ja a logic based on the resolution principle jacm jan scott ds c a math semantics for languages proceedings of the on and automata research institute series institute of g t e ai project mac mit rd a general of pascal tech report university r interactive verification using virtual phd thesis edinburgh rj cr reasoning about artificial vo no rw a users for fol stanford artificial intelligence aim r milner r program and correctness in a proc usa conference ra rl m abstraction and verification in introduction to language and methodology university s algebraic types computation mit specification of data structures group 
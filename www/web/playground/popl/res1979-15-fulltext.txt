an interpreter generator using tree pattern matching m ho michael j university w in abstract equations provide a rich intuitively under notation for describing computing languages such as lisp and in this paper we present techniques for automatically generating interpreters from equations to wellknown techniques for generating parsers from contextfree grammars the interpreters so generated are exactly faithful to the simple traditional mathematical meaning of the equations no or fixpoint ideas are needed to explain the correspondence the main technical problem involved is the extension of efficient practical string matching algorithms to trees we present some new efficient match ing techniques for a large class of trees and point out problems in extending this class we believe that the techniques of this paper form the of a useful discipline of interpreting comparable to the existing dis of parsing introduction languages for computation may be classified into a procedural languages eg algol pascal which directly describe sequences of actions to be performed and b languages eg lisp which allow definitions of objects functions and relations without direct reference to computational techniques since pro languages have the advantage of allowing a programmer to ensure efficiency by specifying a computation in detail they have received much at this research was supported by nsf grant a university xl grant and their implementation may be based on standard techniques for parsing table and code generation the de of an interpreter for a lan guage cannot draw on a comparable body of uniform techniques languages have the potential for extremely simple semantics based on the tional semantics of mathematical expressions carefully exploited such languages could for many applications make up in clarity and ease of what they lose in efficiency john recent turing lecture ba makes a strong case for languages in the past standard interpreters of languages have often this semantic simplicity both by aug such languages with procedural constructs eg assignment and goto and by sometimes fail ing to produce results even when the language semantics an answer for instance car x according to but lisp interpreters fail to discover this when y is we believe that a rigorous approach to de languages may yield efficient inter which precisely satisfy the language specification moreover the difficulty of de such interpreters can be significantly less than that of designing compilers in fact most and in some cases all of the process may be automated for the purposes of this paper the tion of a of expressions allowed language consists of a set i as inputs a subset o of i containing those expressions which are simple enough to be given as output and a set a of axioms which may be used to deduce the equivalence of expressions in i we restrict attention to axioms which may be written as equations goguen g claims that any reasonable computational process can be specified purely whether or not this thesis holds equations provide a starting point which might be extended by further work and which is already capable of expressing general purpose languages such as lisp and an interpreter satisfies a specification of the form i o a above whenever given any expres sion eo in i for which there exists expression e in o the interpreter f an ef for instance lisp might be letting i include all an equivalent produces such specified by ie expres sions formed from atomic symbols cons car cdr atom eq cond and eval o would contain exactly the those using only atomic symbols and cons a would contain the defining equations from h interpreter based on those spec would take an especially one of the form env and return an equivalent if such exists previous work on interpreters for purely de languages includes two types of work theoretical studies of equational definitions all of which lack important implementation details and specific studies of individual including actual languages aw implementations faithful to the precise semantics this paper attempts to maintain the generality of the theoretical studies while providing some of the details needed to build practical implementations using the subtree replacement systems of d and r as theoretical basis we outline the steps necessary to apply that theory to languages and develop algorithms for inter part explains briefly how the theory of subtree replacement systems applies and what restrictions are required by the present theory part a specification language for inter which includes tree replace ments with simple eg arithmetic operations parts and treat the structure of the data and algorithms to be used in an interpreter we have applied the techniques of this paper to implement an interpreter generator and have generated interpreters for several languages in lisp and because of the faithful ness to the mathematical semantics the generator can be used to provide immediate implementations of defined data types from their specifications as suggested by and wa the central issue in interpreter generation is how to extend efficient pattern matching algorithms from strings to trees we outline briefly the technique employed in our present implementation we believe that our ap provides techniques which may form the basis for a discipline of interpreter construction com to the present discipline of compiler con reduction sequences applied to interpreting given i o a as in the introduction a interpreter might work as follows take an expression e and enumerate expressions ef such that e ef until an ef in o is found such a scheme is obviously inefficient unless the e is done in a particularly manner in many cases equations may be ordered so that the righthand side of each equation is in some sense simpler or than the lefthand side and so that expressions in o do not contain lefthand sides as subexpressions in such cases a better interpreter might produce a sequence eo el e of progress simpler expressions by replacing lefthand sides of equations which appear as subexpression in some ei by the corresponding righthand sides until an ef in o is found such re sequences are studied in bl ds r sta vu od in a reduction sequence each occurrence of a lefthand side of an equation is called a redex an expression normal form the sequence which contains and must be the under the no is in last expression in assumptions every expression in o is in normal form since a single expression may contain several different there may be many different reduction sequences starting with the same eo in order to use re sequences for interpreters we must know how to choose an appropriate reduction sequence one that terminates with an e in normal form ever a entails eo ef and one that is nest too long to guarantee such behavior we need a few reasonable restrictions on equations no variable maybe repeated on the le hand side of an equation for instance if x then y else y y is if two different lefthand sides match the same expression then the corresponding right hand sides must be the same so the pair of tions o and is since could be replaced by o or when two not necessarily different lefthand sides match two different parts of the same expression the two parts must not overlap eg the pair of equations and are since the left hand sides overlap in d shows that with these three tions for each expression eo there is at most one normal form ef which eo may be obtained by re any strategy for choosing reduction se which guarantees that every possible out replacement in an expression is eventually done will produce ef in normal form such that a implies that whenever ef exists we can use above to prove that an inter satisfies its specifications strategies for choosing reduction sequences fall into two classes a parallel strategies in which several are reduced simultaneously in practice reductions are scheduled according to some fair discipline b sequential strategies in which a single redex is chosen at each step the most common sequential strategy chooses in preorder ie leftmost outermost first every set of equations satisfying the restrictions above may be handled by a parallel strategy see d and vu for a general discussion of the additional restrictions needed to allow for lisp the leftmost outermost strategy is correct and optimal but for because of the equations strategy is required and a parallel using subtree replacement systems as a model we may the task of implementing an inter into the following steps specify the language to be interpreted in terms of i o a with a in the form of tions convert the equations a into a form sat and the additional three restrictions above pick a data structure to represent ex and an algorithm for performing single reductions pick a strategy for choosing the next redex to be replaced and develop an efficient algorithm to find the redex specified by that strategy step is inherently intuitive but the other steps may be partially or fully automated to step requires further research kb gives automatic techniques which sometimes succeed in eliminating overlap in equations but at present a language designer must usually per form step intuitively section of this paper gives a specification language in which and may be presented and an example of such a presentation sections and discuss two different methods for performing and the interpreter specification language to specify the input expressions one need only list a set of symbols with their the input expressions will be the usual terms composed of the listed symbols most inter languages include large sets of standard symbols such as integer constants to avoid long specifications there are standard primitive sets of symbols which may be specified by a single use the sets integer name in this containing all paper we will integer con as symbols the boolean symbols t and f as well as the binary symbols div mod eq ne lt gt le also use the set unspecified containing ge we as symbols all strings not otherwise ac counted for on which eq and ne are defined those sets of primitive symbols containing con are primitive domains and symbols of higher degree will be called standard functions now a useful subset of may be specified as follows symbols cons car atom eval integer boolean cond cdr pair assoc unspecified quote o atom o eq o cond o car o cdr o cons o label o lambda o many important equations may be given eg x such equations are sufficient to define general purpose programming languages for practical purposes however standard functions such as defined on primitive domains should be computed by program that is the set of equations o is implicitly spec by a program which given that a sion xy where x and y are integer constants is to be reduced replaces it with an integer constant z such that z primitive sets of symbols are introduced in the language tion these programs representing equations ing standard operations are also included one may wish to the effect of these pro grams as specified by such as xy z where xyz in integer the sum of x and y and z is with which is associated some subroutine computing in this case the value of z as the sum of x and y in this view we can implement standard functions by a small extension of the mechanisms needed for user defined reductions it is ing to extend this approach and to allow the user to associate subroutines with reductions in gen analogous to the way in which so called semantic processing is associated with syntactic reduction steps performed by a parser however we wish to limit our device to a few standard functions defined on primitive domains to ensure that the language semantics is correctly specified avoiding tedious separate proofs a syntactic difficulty arises when a large number of equations must mention each expression in a large class for instance one specification of lisp would include a separate equation for each unspecified symbol and each integer con we such sets of equations into one by using a variable restricted to range over a union of primitive domains thus the lisp axioms may be given as follows axioms for all xy x x y y t where x in integer unspecified boolean f u the complete set is given in the appendix a the phrase for all xy indicates that the symbols x and y are to be taken as variables rather than as un specified constants in the axioms the set of output expressions is given im as the set of normal form expressions as determined by the axioms a separate specification of o could lead to a uniform treatment of certain errors see d p but this possibility has not yet been explored reduction with the problem of reducing an expression e to normal form naturally into a finding b choosing the next redex to be replaced c performing a single reduction step finding is essentially a pattern match problem with trees instead of strings the choice of a suitable algorithm is complicated by the fact that each reduction step the expression tree locally it is to the entire structure after each reduction step expressions may be stored as dags in which each node is connected by a circular pointer struc ture to each of its as sketched in this way from any node we can find any son or without sharing we double the pointer space required sharing down on this ie space multiple and may reduce the number of reduction steps needed to reduce eo since the technique for a single reduction step is straightforward we omit discussing it the key idea for identifying is to associate with each node a code indicating which parts of left hand sides of equations match the subtree at that node we compute these up using a match table states giving from the leaves the state at node p as function of the label at p and the states sons in this way all may be lo in eo in time proportional to the size of the dag the problem of matching tree and of generating these tables is studied in detail in h for the purposes of this paper we limit the discussion of the of tree match ing to section when a reduction is performed match states must be computed for any new nodes which have been added and for some of the ancestors of the redex the back pointers make it easy to find all affected ancestors the length of any path along which an update can occur is limited by the maximum depth of equation lefthand sides during this local update new may be discovered given that every node in the dag representing an expression has been assigned the appropriate match state a simple parallel strategy for choosing the next redex would be to keep all in a queue reducing the first redex in it and adding newly discovered at the a standard reference count detects if any redex is from the expression as side effect of a redex pre it in the queue the strategy is correct but not optimal in cases where an a priori sequential order ing of is given an appropriate depthfirst traversal of the dag implements the reduction strategy a single additional bit maintained at each node indicating whether the subexpression rooted at that node is in normal form will prevent useless of the same shared normal form subexpression we have implemented a generator system based on these ideas in pascal the tion effort has been approximately we have generated no interpreters for lisp and the combinator calculus actual tions have been very fast matching tree patterns we wish to generate tables from a set of tree patterns the axiom lhs with which to the linear matching algorithm outlined in section all possible sets of partial matches need to be known since they are used to index into the tables during the matching process during the process of this generation the restrictions on axiom lefthand sides of section will also be checked note that there is a straightforward matching algorithm which works on on m steps where m is the pattern size to be matched in a subject of size n this algorithm requires no preprocessing and works for all patterns the algorithm of section in contrast matches in on steps after suitable tables have been as explained now given a forest f of tree patterns tl tk a ma set m for f is a set of subtrees in f such that there is a subject tree t such that every member of m matches t at the root and every sub tree in f which is not in m does not match t at the root m is thus the set of all partial matches at the root of it a table of match sets may be straightforwardly in time kl s m where s is the number of sets k is the maximum arity of any symbol so the table is size and m is the total size of all we discuss only more efficient methods given distinct patterns t and t two relations t subsumes t t t we define if a match of t always implies a match of tt at the same node for example abc since v matches c does t and t are independent tt if we can find subject trees t t and t such that t matches tl and t at the root but not t whereas t matches tl and t at the root but not thus and acc because of trees abc it is not hard to show that each match set m may be partitioned pairwise independent trees into a ba se set mo of and a set ml of trees each of which is subsumed by some tree in mo because of the transitivity of subsumption each match set is completely determined by its base set using the defined relations h shows that the number of distinct match sets may grow exponentially with the pattern size if there are no subtrees in the pat forest f which are independent then the number of possible match sets is equal to the size of f because of these results we restrict axioms such that their lhs form pattern two subtrees are independent sets in which no such m sets are called simple define immediate subsumption i by i t iff t t forest and there is no subtree tt in the pat f such that t t and t tt the directed g of the immediate tion relation is called the subsumption graph of f for simple h g is a tree shows that the base set of each match set m is a singleton the match set base set t is pre the set of trees on the path from the base set tree t to the root of g s let m be the size of the pattern forest f and d the depth of gs there is a straightforward algorithm for computing the transitive closure of g in m steps using an indexing scheme we can design an md algorithm which is slower in the worst case but can be expected to run sig faster than the m algorithm which is quadratic for all inputs both algorithms at the same time can check that f is simple and that the restrictions of section are satisfied with out the running time the md algorithm is given in appendix b if there are no function symbols with arity computing then there is an algorithm for gs the algorithm can be adapted to per form the actual matching too leading to a matching algorithm of steps in a subject of size n the algorithm can be adapted to compute in the same time bound gs for alphabets of higher but will then be unable to process certain simple the details are covered in h once g has been computed the tables to the on matching algorithm can be constructed easily if k is the arity in the alphabet z then the tables require o mk space and take steps to construct then table generation is the of the preprocessing since the maximum arity k of alphabets affects the size and time of table tion so it is useful to reduce k by introducing a set of pairing functions we have used this technique successfully to speed up the interpreter generation but it should be noted that pairing sometimes simple pattern into in which independence occurs this is also responsible for the failure of the adapted algorithm to process all simple for alphabets of higher since the intermediate graphs constructed by the algorithm conceptually argument pairing although table generation is the of the preprocessing it is well worth while to investigate ways to speed up the computation of gs further because these algorithms can be adapted to perform the actual pattern matching without the need for generating large tables this may best be understood by observing the analogy of tree pattern matching and string pattern matching in the style of and ac consider a string pattern al ak as non branching tree ak a k av the graph for a forest of such trees is pre gs the graph of the failure function of and ac for this note that a subtree of a non branching tree is a pattern prefix now t t for trees t and t if t matches t at the root therefore in the case of trees t is a pattern prefix which is at the same time a suffix of tl thus t i t iff t is the largest proper pattern prefix which is also suffix of t thus it is reasonable to look for matching algorithms which use gs as data struc ture the adaptation of the algorithm is designed in just that way reduction without back pointers up to half the pointers in the implementation of section may be eliminated by representing dags without back pointers at present we do not have a nice algorithm for parallel strategies without back pointers for sequential strategies a simple implementation uses the match states and normal form bit of section a depthfirst is used to find the next redex any subtrees which are marked as being in normal form whenever a node is found whose state or normal form bit may be changed by from its sons the change is propagated but only along the path by which the node was reached this path is known from the standard stack used for the traversal informal development of a more powerful algorithm the simple algorithm outlined above does not address the problem of finding an acceptable tial strategy we have a method which finds optimal sequential strategies automatically in addition this method generalizes a trick applied by friedman and to lisp fw in which portions of an expression which have become stable are output and eliminated to save space a development of the algorithm is being for journal tion with a proof that the method finds a tial strategy whenever such success is possible without considering the right hand sides of t ions the match state idea from section is for a redex once we have scanned the appropriate part of a tree the additional problem is to decide which parts of the tree to scan this decision must account for the possibility that some match states are out of date since a shared subtree may be changed through one path without the change being on other paths the main new concept needed is that of a possibility state the match state mn at a node n represents all partial matches known to hold at n the property guarantees that existing matches at n will never be by reductions at descendants of n but new matches could be created the possibility state pn n represents a set containing all partial matches which might ever hold at n as the result of re at descendants at any given time some matches in may already hold at n due to reductions not yet by n the true set of matches holding at n must always be a superset of mn and a subset of pn to avoid obvious questions pn is computed without edge of equation right hand sides by assuming that a redex be replaced by any tree finally we need one more state called a search state to keep track of those partial matches which might be useful to the reduction match states and possibility states are stored at each node search states s are stored on the traversal stack and contain all partial matches which might make a reduction possible at some node on the path from the root the algorithm is developed from the following observations if mn contains a complete match then a reduction may be performed if s jj then an interesting change has which should be propagated up the tree if then no node on the stack will ever be changed if j but then further processing of descendants is needed and the appropriate son to visit may be recognized by his match state and possibility state a precise statement of the algorithm is attached as appendix c the problem of states for the new algorithm is even than for the old so far we know that in some cases possibility sets are exponential in number even though match sets are very few more study is needed to discover those cases in which the total number of combinations is not too big appendix a lisp equations original lisp equations have several present a correction and reordering of definition apparent axioms for all v w x y z car cons x y x cdr cons x y y atom cons x y f atom x t where x in atom eq cond car cdr cons label lambda cond t cond f eval x z where x in unspecified eval cons x apply where x in eval apply eq cond car cdr cons the following equations re y z x y y v label v z z nil z y y y nil nil cons x x w appendix b pattern preprocessing the preprocessing of simple pattern for generating tables into the of the subsumption graph gs which is a tree for simple and the generation of tables from cs the computation here of gs with also verifies suitable changes not that the presented form a simple forest verifying the property can also be incorporated assume patterns tl tk are given let t denote the set of all subtrees of the ti and denote a directed edge from t to t in gs by ft t ie t directly subsumes t the computation of gs is now as follows algorithm a compute subsumption graph gs for linear forest f input linear forest f of patterns output tree edges pointing to ancestors method order all trees in t by their depth for each t v in t of depth enter ftv comment ft t iff there is a directed edge from t to t for p to in forest do for each tk in t of depth p do begin s ­ v for i to k do begin t while there is no tree t of maximal depth p which is subsumed by t and has t as ith sub tree and t v do t ft for each tree t with t as ith subtree which is subsumed by t and of maximal depth p if tl s then s t enter ft s note that since we process trees ordered by increasing depth the test t subsumes t can be done by verifying for each immediate subtree pair ti and ti that ti subsumes t of both ti and t must be strictly since he depth smaller than p this test involves tracing through the existing portion of gs since there may be in some cases up to om trees t with ith subtree t where m is the of t and since tracing through the existing portion of gs for testing subsumption may involve up to od steps where d is the depth of gs the algorithm requires md steps given gs we can then construct tables in the following manner algorithm b input subsumption graph gs of linear forest f output tables the fast matching algorithm of section method traverse gs in post order for each tree t following tk visited k do the enter t into all portions of the table for a which are by tuples not yet assigned and are indexed t t t where for tt t t i enter v into all table positions in each table for linear it can be proved that algorithm b cannot attempt assigning t to an entry already assigned t unless hence the time bound where k is the occurring arity in x appendix c reduction without let n be any node in a dag representing a tree labels n is the alphabet symbol at n match states mn is the set of all partial matches known to hold for the subtree rooted at n possibility states pn is a set of partial matches which might arise at n as the result of reductions at proper descendants of n pn is a set of partial matches which might arise at n as the result of at n and its descendants c is the set of complete matches of patterns u is the set of all partial matches note that pn pn if pn u if a stack of pairs ns is used to control the traversal the nodes on the stack form a branch from the root the search state s is the set of all partial matches whose occurrence at n could produce a complete match at some node below ns on the stack when t is a set of partial matches is the set of all ith subtrees of roots of members of t is the set of all partial matches whose ith subtrees are in t ua is the set of all partial matches with root labelled a the algorithm initially mn p n for each leaf n mn pn n pn pn for every if pn n c n for every node n the stack initially contains root c while the tree to be reduced has not been split do ns top of stack if n is not a leaf then mn pn p n pn if g u if p end if if p then reduce else if then pop else if o then split else choose i such that push end else end while reduce push and pop have their intuitive meanings split is invoked when the nodes on the stack have all ie future reductions cannot possibly change them split outputs the nodes on the stack them for garbage collection and processing of the remaining subtrees in any order or simultaneously references aw ba bl car ds fa fw fw a and m efficient string matching an aid to search cacm e and w formal system for writing and proving programs siam j on computing j can programming be from the style a functional style and its algebra of programs cacm g and j j minimal and optimal computations of recursive programs th acm symp on popl s j recursive definitions of partial functions and their computations phd comp science dept stanford university t deterministic operational semantics for res cs univ of p and r sethi correct tion rules for recursive languages siam j on computing m correct compilation of a useful subset of phd dept of comp science univ of friedman d and d cons should not evaluate its arguments rd int on automata languages and programming edinburgh friedman d and d output driven interpretation of recursive programs or writing creates and data struc tures inf proc letters g hm h j kb d sta wa r vu j e and d abstract data types and software tion inf sci inst res univ of cal goguen j abstract for abstract data types ifip working conf on formal of concepts j cd northholland p and j h morris a lazy evaluator rd acm symp on popl c matching tree patterns technical dept of comp sci university johnson sd an model for a language based on suspended construction tech dept of comp sci university knuth d and p simple word problems in universal algebras tional problems in abstract algebra j cd press oxford knuth d j morris and v pratt fast pattern matching in strings siam j on computing j recursive functions of symbolic expressions and their tion by machine cacm m computing in systems described by equations springer lecture notes in comp science f j a class of replacement systems with simple optimality theory of the math to appear wand m first order entities as defining language dept of comp science university rosen b k tree manipulation systems and churchrosser theorems j correct and optimal implementations of recursion in a simple programming language 
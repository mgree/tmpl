conference record of the fifth acm on principles of programming languages a compiler extended abstract and l computer science division university of california berkeley california graham abstract an algorithm is given to translate a rela lowlevel intermediate representation of a program into assembly code or machine code for a target computer the algorithm is table driven a construction algorithm is used to produce the table from a functional description of the target machine the method produces high quality code for many available computers by replacing the table it is possible to a compiler for another kind of computer in tion techniques are given to prove the correctness of the translator introduction since the early history of compilers researchers have to and the production of compilers the most suc aspect of this attempt has been syntax it is now to use a syntax analyzer which is automatically constructed from a generalized contextfree grammar specifying the syntax of the source language see for exam ple such an analyzer is easily obtained provably correct and modular attempts have been made to simplify the prod of compilers for a specific source lan guage by compilers so as to specific aspects of the translation it is then possible to the compiler by changing those portions of the compiler which con the architecture of the machine see for example or in this paper we describe a method for generating a for a compiler from a functional description of the machine instructions the technique we use is in certain respects similar to methods used for table driven syntax analysis and has many of the same advantages namely modularity correctness com and ease of use the code generator produces quite good code in particular it is able to detect the instances in which specialized instructions can be used it is possible for the code generator to many kinds of tion information should it be available in research by the national tion under grant science current address general systems division ca addition our methods should prove valuable in designing compilers in the sections that follow we summarize previous work on this topic give our code tion algorithm and our table construction algo rithm explain the way in which this code is incorporated into a compiler and summarize our implementation experience the discussions are necessarily brief because of the length limitation on this summary the reader should be aware that by code generation we mean not the entire the source program but rather the restricted task of choosing a sequence of object code instructions thus such issues as choices of representation storage allocation and are outside the scope of this work background for our purposes previous research in code generation into three classes the first class are attempts to deal with code generation usually in order to produce or code for example significant results have been obtained however research has been with models of computers real computers tend not to have clean instruction sets there are always special instructions that implement certain computations more efficiently thus this approach must be extended for use in production compilers the approach is in certain respects complementary to our techniques and one can be incorporated into the other the other two classes of research to focus on implementation methods for often with loss in efficiency of code have real the second approach to code generation is to provide information about the computer in proce form using special purpose code generation languages and interpreters examples of this approach are the ideas strong the optimizer of and the method developed for and the work of these methods are an improvement over strictly ad hoc techniques but require considerable of tedious low level details making correctness difficult to and a lj the third class of methods and the one into which our work uses information about the target machine supplied in a form or data base the macro approach to code generation into this class as does the tt thesis of and the yale dissertation of our approach to code generation was initially by the work of and and we have built on their ideas the coding algorithm the output of the front end of the compiler is assumed to be a intermediate repre ir of the source program the ir con of a sequence of prefix expressions in such a representation operators are followed by their operands for simplicity we assume in this paper that all operators are unary or binary the techniques we describe are readily extended to nary operators the imple decision concerning representation and storage allocation as well as all but the low level optimization are already incorporated in the ir version of the program each instruction of the computer is described by a prefix expression together with certain semantic information and an assembly or machine language template the examples should make these notions the coding algorithm performs a similar to parsing in which the ir sequence of prefix expressions is translated to a sequence of instructions however the situation differs from syntax analysis in the following respects since most operators can access their operands in a variety of ways the target machine description is normally ambiguous indeed an important factor in code generation is the way in which these are resolved secondly the reduce move of the code generator is considerably more than in syntax analysis since it selects among a variety of instructions or instruction sequences on the basis of both syntactic and seman tic information finally error situations by the code generator always com bugs as an example figure describes a small set of machine instructions notice that in form the instruction descriptions context free r r rl r t kl r r r t k r r r r r r k r k k k r k r r r t k r r k r r r k r t r r kl r k add add add add add add store store store store store load load load load load load r kl rl rl cl r rl kl tl kl rl r r rl rl r kl rl rl kl rl kl r rl r kl rl r kl rl r kl rl r rl rl kl rl kl fig sample instruction set description grammar rules for each instruction a correspond ing assembly language instruction is also given the symbol to the left of the des of the result of the computation the pre fix expression to the right describes the tion computation the parentheses used for readability a left hand side of lambda indicates that there is no resulting ter value ie the instruction is executed for its side effects by convention r a general pose register and k denotes a constant typically an address offset the store operator is and the contents operator is the symbols following the represent semantic the on r and r indicate that they denote possibly distinct registers the of a in an instruction indicates of the same register or constant thus the first add instruction adds the value in the memory location addressed by the first constant plus the first register to the contents of the second register leaving the sum in the second register observe that the commutativity of is indicated explicitly in instruction descriptions rules and for example the addition of semantic restrictions to the instruction description allows a greater number of special instructions to be described it also com the choice of output instructions in the code generation algorithm a single syntactic instruction pattern may correspond to more than one instruction as the introduction of semantic restrictions may require the duplication of some instruction patterns by forcing some com operations to be represented by two patterns eg add and add rr and by allowing one instruction to be specified as a special case of another eg inc r and add r k it also may be that two distinct instructions compute the same expression but leave the result in registers of different classes eg and the ir version of the source language consists of a sequence of prefix expressions composed of the same syntax symbols that are used in the tion of the instruction set however in the ir semantic carry specific information whereas in the machine description they simply operators the translation from source language to ir will in general depend on the seman tics of the source language and the implementation decisions for instance in a language the statement a bc might be ka r kb r kc where a b c constants and r is the local base register thus by inference the base of the data segment containing b is obtained by following a static link a is local and c has an absolute address the overall structure of the algorithm is that of an deterministic parser the language generated by the target machine description productions or rules with lambda replaced by x and the rule s x added the language being analyzed and the ir is the input figure gives the overall code generation algorithm the code generator input action and next functions represented in matrices derived from machine ms description and the ir of a program p being compiled output an assembly language program for p on machine m method perform a parse of the ir input target instructions whenever reductions are performed set the parsers state s and the stack to step set the lookahead symbol u to the next input symbol if all the input has been read set u to the end of input symbol step perform the action in action is u shift push u onto the stack then set s to the value of next s u push s onto the stack and advance the input one symbol go to step reduce r output an instruction from set r or an equivalent sequence of instructions see next section if the rule used is r a then pop the stack al times and set s to the state on the top of the resulting stack if r k then push r onto the stack set s to the value of next sr and push s onto the stack go to step accept error the code generator halts code has been generated for the entire ir input string this can only happen when all of the input has been read ie u is and the stack is empty ie s is qo issue an error message and halt the ir input has no parse using the underlying grammar for ms instruction set r e n then action must be shift fig the code generation algorithm algorithm which is very similar to an except for the special treatment of rules with left part and the semantics of the reduce semantic information is carried along with the state information on the stack for example when a shift is per formed with the input symbol r for a register the specific register represented by that r is also pushed onto the stack then when a reduce is done the semantic information necessary to generate a final instruction can be read off the stack the instruction used when a reduce operation contains more than one instruction is by a simple heuristic instructions are ordered by the table constructor into a best instruction first sequence at code generation time the tions in the set for a specific reduce action are tested in that order until an instruction is found that is semantically compatible with the tion on the top of the stack since all tions in a reduce set have the same instruction pattern the according to some cost criteria instructions are tested first if the length of an object instruction in bits is used as the cost factor a bit long increment instruction will be tested before a bit long add immediate instruction since the basic patterns for brevity we have assumed that the reader is familiar with parsing and its terminology are identical but the cost of the increment instruction is less it is also possible if all the instructions in the set have semantic tions that more than one instruction is generated this situation is discussed in the next section the coding algorithm works in conjunction with a conventional register allocation routine the machine description specifies how many and what kind of registers exist on the target computer and which ones are available to the register allocator each nonterminal in the instruction set description in general represents a logical register or a class of logical registers each logical register is associated with an actual machine register or pair of registers in this way information such as the fact that do is the register pair is included in the machine description register allocation occurs as a to a reduce operation after an instruction pattern has been semantically verified if the result of the instruction is and if the result register is not semantically linked to any other register in the instruction pattern the register allocator provides a free register of the appropriate class after setting its use count to if the result register r is semantically linked to a register in the instruction pattern then r must be used as the target register and its use count set to one since it contains a newly computed value the routine is easily generalized to incorporate mation about reuse of common subexpressions figure contains the move table used by the code generator for the instruction set in figure in the table the action and next functions are represented in the following format columns of the table are by language symbols and rows correspond to parser states an entry in row q column v of the table is of the form ab where a always represents and b is when a is shift and the rule set by which to reduce when a is reduce the action values shift and reduce are abbreviated respectively s and r a the error action using the instruction set of fig we show in fig the sequence of steps taken by the code generator for the ir input expression for each step we indicate the action the resulting stack and the intuitive current state the instruction sequence produced by the algorithm is the reader can observe that other code code generator move table i accept s s s s s s s s s s s s s s s s s s s s s r r r r r r r r r r r r s s s s s s s s r r r r r r s s s s s s s s s s s s l r r r r r r s s s s s s s s s s s s r r r r r r o s s s s r r r r r r q r r r r r r s s s s s s s s s s s s s s s s r r r r r r s s s s r r r r r r s s s s r r r s s s s r r r r r r r r r r r r s s s s s s s s r r r r r r s s s s s s s s o r r r r rr r r r r r r r r r fig code generation table for example input ka r kb r t kc shift stack is i have matched the first symbol of instructions shift p matched first two symbols of rule first of rules shift ka matched first three of rule first two of rule all of rule shift tl matched first four of rule all of rule shift tl first symbol of rules shift r first two of rules and first of rules shift l l matched first three of rule first two of rule first of rules shift r kb matched first four of rule first three of rule first of rule all of rule shift l l kb matched first symbol of rules shift r kb matched all of rule reduce rule assign result to rl emit load shift left side p matched first five symbols of rule all of rules shift l kb r matched first of rules shift l l kb r kc all of rules and reduce rule assign result to r emit load rc shift left side r matched all of rule reduce rule emit shift left side matched all of rule reduce rule emit store stack now contains t if more input the code generator would read the next symbol since there is not the algorithm terminates fig example of code generation sequences eg instructions are possible for this input the table construction algorithm sketched in the next section always produces a table hence the coding algorithm is always the coding algorithm has the following aspects which are not obvious from the small exam ple a reduce action first checks the semantic restrictions ie such as specific constants matching registers of the matched patterns there may be more than one match etc a particular instruction is selected the register allocator is called if a result register left hand side is needed in certain instances sketched in the next section the reduce action more than one instruction typical ly this happens if a long instruction is matched but its semantic constraints are not the seman tic usually arise in conjunction with specialized instructions for example an increment instruction is only applicable if the constant has value the correctness considerations are sketched in the next section the reader can see that among them are the requirement that the ir vocabulary be a subset of the target machine vocabulary and that the operators have the same computational meaning in both the table construction algorithm the table constructor first treats the target machine descriptions as contextfree grammar rules ignoring semantics and constructs the set of lr states in fig r register is the only nonterminal the example generates states there are many states caused by or conflicts most of these conflicts represent for instance in the example rule followed by rule is the equivalent of rule the tion algorithm to resolve these conflicts in of short instruction sequences ble use the approach in for the of these namely shift reduce conflicts are resolved by this heuristic usually causes the use of more power instructions conflicts are often resolved by the semantic restrictions if not the longest instruction is used these are reflected in the example in steps and the initial phase of the table con in which the conflicts are resolved in this way is given in fig in shift reduce conflicts lookahead information is used to that reduce actions are included where needed given a general contextfree grammar the rules would not necessarily yield a recognize for the entire language by the grammar however the construction is for uniform instruction sets a proof is contained in let v be the set of vocabulary symbols for the instruction set description an instruction set is said to be uniform if it satisfies the following condition any left similarly right operand of a binary operator b is a valid left respectively right operand of b expression of v containing b any operand of a unary operator u is a valid operand of u in prefix expression of v containing u an tion set is uniform if its description is uniform the essential idea of is that operands to an operator are valid independent of context we give some examples to this notion consider the instruction set described in fig the operands of are all either registers rule or special cases of registers as by rules and the operands of the leftmost in rules are all either registers rules and or prefix expressions which become registers by rules or since a register is an argument of rule and of rule the arguments of the other occur of and represent special cases ie in summary whenever and t occur their operands are any prefix expressions corresponding to registers note that in this example both and have the same set of left operands as right operands such a situation need not be true in general an example of an instruction uniform is set which is not r kk r kk a r in this example k is a valid first operand of only if the second operand is k and ei ek be a prefix expression where k as is well known the prefix to a unique binary tree with nodes label led by the where el labels the root and nodes are labelled by opera the subtrees rooted by children of an opera tor node represent its operands see for example for example hand side of the first instruction in fig corresponds to the tree i k r in order to check that an instruction set is uni form we define the relations which are of the usual string relation follow using these tree relations we obtain a simple test for which is incorporated in the table constructor the definitions are presented with respect to a particular instruction description g recall that v is the set of operator and operand symbols used in the instruction description the binary operators let u v be the unary opera define the relation left on as b left v iff an instruction r where r may be a similarly define the relation right on as b right v iff an instruction r for some prefix expression bk where r may be a clearly b left v if v is the leftmost symbol of a left operand of b in some instruction and b right v if v is the leftmost symbol of a right operand of b in some instruction by convention unary opera have left operands to extend these notions from operands in the same instruction to all operands we need the usual leftmost and rightmost algorithm ­ the initial code generator constructor input a instruction set description for machine m output the initial action and next functions represented in matrices for a code generator for machine m an error message if the instruction set is not uniform method construct a set of states for the context free grammar underlying the given instructions as it is being done fill in the next and action values to produce the code generator conflicts test each state for appropriate left first and right first actions procedure begin qo close i i i k t cd k o n o i state number i while k n do begin f with qk bl then action qk vi shift q up f if gj v qj else n n qn q v e qn else if i s qk with i x a then r xa v e a i qk i xa both and v action qk v reduce r else action qk vi check for qk the form ra v qk ax do begin x v if then d left first begin if action qk u error then output not uniform end else x b and v begins the second operand v right first begin if action qk u error then else output not uniform end end advance to next state end action qo accept end such that function begin repeat qq x all q does not change return q end close bp x xa fig initial table constructor relations define the relation first on as u first v iff a derivation u va for some uv u v where derivations are defined usual way in the thus u first v if there is some derivation in g from u that yields v as the leftmost symbol similarly define last on as u last v iff a derivation u av for some uv by the usual product of relations b left first v iff v can appear as the first symbol in the left operand to b in a derivation in g and b right first v iff v can appear as the first symbol in the right operand to b in a derivation in g using these definitions we obtain the following theorem a more formal statement of the theorem and a proof appear in theorem let g be an instruction set description let the code generator tables be computed by the algorithm in fig and let q be the corresponding set of states the following conditions are equivalent g is a uniform instruction set a for all u v in v if u left first v then for every state in q containing an item for some r a x b where u is the parent of x in the tree corresponding to and x is the left child of u it is the case that shift b for all u v in v if u right first v then for every state in q containing an item for some r a x b where u is the parent of x in the tree corresponding to x is the right child of u it is the case that c shift reduce r in other words the theorem says that if the grammar is uniform then if a left respectively right operand of an operator u is expected in a given context then the first symbol of any ble left respectively right operand of u is legal and conversely it is the test suggested by this theorem that is incorporated in the table constructor in that test returns the parent of v in the tree corresponding to the prefix expression the predicate returns true if v is the left child of its parent in the tree to the prefix expression uv and false otherwise that it suffices to check for error because only state q can have an accept action also note that the possibility of a reduce in a is out by the form of the instruction descriptions ie u must be an operator and must be the last symbol in a and no right hand side of an instruction description can end in an operator since it is the relations left first and right first which characterize uniform instruction sets the reader may why the table constructor instead uses the string relation computing action and next the reason is that the use of considerably simpler computationally and yields tables which are equivalent except for deferred error detection see for a proof since errors er bugs delayed error detection for instruction set descriptions for let only from acceptable we can define some where r may be a x last and y let ui instruction a v and x last u for some it is easily shown that consists only of operand symbols then for u v u if u operators if u g the operators are those which occur as leftmost operators of instructions with destination a using the notion of shown that it can be theorem let g be an instruction tion then algorithm declares error if and only if g is not uniform if g is uniform then algorithm using the tables generated by algorithm but semantic fails to reach the accept state and to generate code for an input ir only if the code generator loops the input ir is not syntactically within the sequence of prefix expressions described by the instruction set it remains to eliminate the possibility of looping to give sufficient conditions for the ir input and to deal with the semantic issues we consider these topics in turn since the prefix expression describing an instruction at least one symbol looping could occur only because of a sequence of chain reductions corresponding to moves the possibility of potential looping is easily detected each potential loop is then broken by a kind of of some of the states computed by algorithm details are contained in as previously described the reduce action generates code by checking the semantic tions of the matched instruction pattern against the semantic indicated on the stack if the set of instructions associated with a given reduce action are all semantically con it is possible that none of the tions will be compatible with the semantics on the stack in this case the code generator would semantically block semantic blocking can be avoided by the use of a default list of instructions that contain no semantic restrictions and together compute the desired expression con the add instruction a a kk the basic instruction pattern is kk k if this pattern occurs in the ir but the constants associated with each of the three ks are distinct then the instruction cannot be used if there are instructions with the patterns r k r k r and a k r then they could be simulating a memory add instruction and the code generation could proceed from there as though the longer instruction had been default instruction lists for all reduce r actions having no semantically unrestricted instructions are constructed by the table con the lists are obtained by simulating the action of the as input the right hand side of the semantically restricted tion and using only those instructions that are than the one under consideration the construction in effect builds a code generator for the subset of instruction patterns and generates code for the restricted instruction cf algorithm of in the presence of semantically restricted instruction patterns the code generation algorithm will choose from a list of tions in step when a reduce action is performed assuming that this list has already been sorted by the table constructor the instructions must be tested sequentially until one is found that is semantically compatible in the event that no instruction is acceptable the default list of instructions is used to implement that computation there are several classes of semantic tions that may have to be satisfied constants in the ir input may have to be equal to specific values such as in an increment instruction and logical registers may have to be equivalent to specific actual multiple occurrences of a symbol in may refer to the same actual value or register if the result is to appear in a register then there must not be any references to the value in that register out side of that instruction such references could exist only if some of common sion elimination has been done finally any additional semantic restrictions required to properly describe a particular target computer may be added to the code generator the proof of correctness only requires that a default tion or list of instructions be available for each restricted instruction so that it will always be possible to generate code if two instructions have the same instruction pattern but different result locations the actual instruction used is arbitrary to the condition that the will still accept the input regardless of the choice made the item will not be included in a state of a uniform instruction set unless a tion using it on a valid input is still valid for practical reasons one may preorder the instructions by cost by the instruction that leaves the result in a register class with more actual registers in an attempt to avoid having to save registers in temporaries or by any other ordering desired and the will still func tion correctly it is also possible to examine the operator for which the register is an operand to determine the instruction that leaves the result in a location that is closer to a valid operand to that operator thus possibly avoiding a subsequent register move instruction it is shown in that if looping and semantic blocking are eliminated by the sions to the table constructor sketched above and if the instruction description accurately describes the target machine then the code generator pro correct code for all wellformed input the input ir is wellformed if the input is a sequence of prefix expressions the operators and operands of the ir are from the same set as the operators and operands of the instructions and have the same meaning the sequence of prefix expressions is valid that is it is in the language generated or described by the instruction set condition must of course be checked by the the either can prove that the routines generating the ir ie the front end of the compiler meet specification or can provide a simple routine to test the input to the code generator fortunately if the instruction set is uniform condition is also relatively easy to check let and be the rela tions satisfied by the ir let and be the relations of a uniform tion description described previously then an intermediate representation ir is valid for a code generator cg provided that and since the compiler probably cannot generate all ir expressions generated ie computed by a uniform instruction set the inclusion might be proper in some instances it is the of the or of some other part of a sys to specify and first however specifying these relations is considerably simpler than characterizing the set of strings that are possible ir expressions how the code into a compiler it should be clear to the reader that the code generator is not a separate pass in a compiler but is conceptually a coroutine the purpose of the code generator is to and the lowlevel decisions of instruction selection as far as compilers are con the does not all of the aspects of a compiler however many of the remaining factors word size number and of registers etc are relatively easily specified via a and a compiler designed to be can be using the larger information for example in a language one might use a display in registers if there were many registers and a linked list otherwise the choice depends on a simple consideration and for a given source language few possibilities exist by a kind of conditional compilation of the compiler one can choose the alternative for a given target machine these issues are discussed further in most code optimization can also be done at a stage prior to generation of the ir input par if an is used for example reordering of expression trees to evaluate more arguments to a binary opera tor first recognition of common subexpressions etc can all be done earlier hence in a portable fashion by semantic information to the operands in the ir usage information can be used to guide the register allocator a slight addition to the ir and the register allocation scheme is required to common subexpression cse information a binary opera tor o is added to the ir that takes an integer constant as its first operand and an arbitrary expression as its second the meaning of this operator is that the second operand is a common subexpression to be used the number of times specified by its first operand each occur of the operator o ie each of an expression as a cse is implicitly sequentially from as it is read the first place that a cse is used is where it is computed as an ordinary operand subsequent uses are by a use cse operator which is a unary operator taking a constant as its operand which cse it represents for example the two statements abc would have an ir representation of upon a define cse operator the code generator sets the use count of the register containing the value to the number of times that it will be used thus that value will be preserved until its final use because that register will remain this is equivalent to adding a special grammar rule r o for each logical register class to the machine description with the semantics that the use count for register r is set to k the mechanism does not have to actually be implemented in this manner it is simpler to it into the code generator likewise when a use cse operator is encountered the actual register that contains that value is substituted into the ir stream equivalent to a grammar rule of the form r k with the associated semantics of using the actual register that contains cse number k for as usual optimization can also be done see for example et al easy change of the target code is possible only if the if remains mostly unchanged in this case one need only run a new machine description through the table constructor and change the tables since the set of inputs must be a subset of the language generated by each target machine description our approach does not work well for different architectures it appears that one ir can be used with most general register machines of the ibm variety but that a different ir might be appropriate for true stack machines since most of the machines in use are general register machines this does not seem to be a serious it appears that this approach to code tion is useful even in a compiler that is not to be by incorporated the decision logic in the coding algorithm and the machine description in a table the size of the synthesis phase of the compiler should be reduced in addition we con that a compiler organized in this fashion will be easier to modify and maintain experimental results a code generator and table constructor were implemented in pascal several target computer descriptions including the ibm and the pop were input to the table constructor our first experiments were for the the change to the required little more than a new description like that of fig and took about one pascal source programs were into ir and input to the code generator although our experiments to date have not been extensive it appears that the quality of the resulting code is very good the code generator produces code that is with the compiler for c the unix systems programming language it does this without any kind of prior optimization of the ir input while its primary task is code generation is not intended to be an the code generator is particularly good at finding specialized instruction patterns such as increment or add to memory in the ir since our pop code generator produces assembly code as do most unix compilers the short jump instructions etc of the unix as well as the optimizer used by the c compiler can also be exploited similar remarks apply to the code generator for the ibm references aho av johnson sc unman jd parsing of ambiguous grammars cacm august aho av johnson sc optimal code generation for expression trees jacm july aho av unman jd principles of corn design reading ma mk an to the automatic tion of code generators phd thesis rice university texas may m st code generation techniques for ibm sys a algorithm for code generation and its use in ble compilers phd thesis computer science division university of california berkeley november mj linear representations of tree struc ture a mathematical theory of free notations technical report computer science department stanford university palo alto ca july pl automatic creation of a code tor from a machine description technical report mac tr project mac mit cambridge ma may pool p c portable and compilers in compiler construction an advanced course g j notes in computer science vol springerverlag new york c reference manual bell hill nj april tb jr a first version of strong j et al the problem of programming com with changing machines a proposed solution august sw an efficient and systematic method of compiler code generation phd thesis yale university new ct j c a pascal compiler for series computer software practice and experience tr generating machine code for high level programming languages technical report department of computer science cornell university ny september et al the design of an compiler co inc new york 
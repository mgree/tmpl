t tradeoffs for linear recursion science laboratory and department of engineering university of illinois illinois usa john program in computer science and division of engineering island usa abstract a linear recursive procedure is one in which a procedural call can at most one other pro call when linear recursion cannot be re placed by iteration it is usually implemented with a stack of size proportional to the depth of re of linear in this recursion paper we analyze implementations which permit large reductions in storage space at the of a small increase in computation time for example if the depth of recursion is n storage space can be reduced at the cost of a constant factor in run time the problem is treated by abstracting linear recursion into the pebbling of a simple graph and for this abstraction we exhibit the optimal tradeoffs introduction many highlevel languages permit the use of recursion and hence allow linear recursion in which a procedural call can at most one other procedural call linear recursion is usually implemented with a stack when a compiler either cannot or does not replace it with iteration the size of such a stack will grow linearly with the depth of recursion and may in fact much more storage space than the procedure itself in this paper we investigate a general method to re the storage space required to implement lin recursion at the of computation time our approach to this tradeoff issue is one intro by and and further analyzed by a schema for linear recursion is given below which f is the procedure variable p is a unary predicate h and f are unary functions g is a binary function and each is uninterpreted in fy q py then hy else gy fi the semantics of such an expression are well under f calls itself until the predicate is true and the call sequence is then and f is computed from inside out we present a simple linear recursion graph model of this sequence of steps and show that execution of linear recursion with limited storage space can be abstracted as a pebble game on this graph the pebble game models this work was supported science foundation under in part by the national register or allocation and the placement of a pebble on a node indicates that the value of the function at that node has been computed and placed in a register or memory location we find the optimal tradeoff for of the linear recursion graph and state in an easily form for example if the depth of recursion is n and p pebbles are used the number of moves required has the following behavior for large n d i p n i k n n p p k p here k is a function of k thus if p is on the order of nk remains linear in n which implies that a large decrease in space can be achieved at the of a small increase in run time we also exhibit the class of algorithms which achieve these optimal and show that at least one of these is easily implemented in the next section we develop the model for linear recursion and section section we derive the optimal algorithms and the statement of exchange in section we present a program implementation algorithms u for linear recursion of partial section stack is concerned with two implementation issues one of which is the determination of the amount of age space that needs to be allocated to achieve a user or compiler exchange and introduced the pebble game and demonstrated linear recursion that for fixed temporary storage k time grows as n demonstrated that the time must grow at least this under these conditions even if counters are also available he also gave some algorithms for linear recursion which use small and large amounts of space our contribution is to simplify the analysis determine the full class of optimal algorithms derive in simple terms the tradeoffs and show that they can be achieved with some simple algorithms we also observe that the problem studied by and us is really that of replacing stacks by partial stacks in which missing stack elements are for this reason the techniques of this paper are also applicable to some forms of recursion which are not strictly linear the pebble game has been investigated by several authors hopcroft paul and have studied the pebble game on a graph on n nodes and show that they can be using space where the constant of depends on the maximum of nodes paul tarjan and have shown the existence of large graphs for which every pebbling strategy uses space and has a graph nodes for which the time t and space s satisfy n log o so that more than linear time in n is necessary to pebble the graph with space paul and tarjan have shown the existence of graphs on n nodes such that reduction in s by a constant factor causes t to expand from on to and have derived tight upper and lower bounds to the for the algorithm on n inputs which show that the product is about n these results are derived for of specific graphs however has de lower bounds to the product st for n x n matrix multiplication modulo and for tion of polynomials which are and qn respectively and which apply to any algorithms for these problems has similar results for which include algorithms for and matrix multiplication for special matrices for and for the discrete transform a graph model for linear recursion given input a where n a linear as defined the depth recursive procedure above f calls of recursion is f and an itself n times the smallest integer such that pf na y and for it follows that n is true here ff ff na and in general for o s r n in a stack implementation is determined by the depth of recursion calling f until the predicate stack for p is true and os r n f ra onto the when f is an invertible function we can compute from f by f f so that linear recursion can be replaced tion as indicated below y a while py true do y fy od by z hy while y a fa z thus if f is invertible as example then linear recursion a fixed amount of space z in the following can be realized in if n o then else n x however f may not be invertible difficult to or it may not be clear to a compiler or compiler writer that it is invertible we note that every partial recursive function can be realized by algollike programs which use linear recursion and elementary functions we consider methods for space for time that do not depend upon the specific inter given to p h g and f thus these methods will compute functions defined by linear recursive procedures by simulating perhaps with the computations carried out in a stack implementation figure shows a very simple directed acyclic graph ln called a chain which is the basis recursion for describing the simulation of linear node r s r s n corresponds to by application of the function f as in by the directed edge from node r to node rl in linear recursion the object is to compute the items represented by the nodes in reverse order namely in the order f na f a fa in a stack implementation these items are stored in ing order as they are computed so they can be directly however if too much space used by a stack a partial stack can be is in which intermediate stack results are saved requires the of results that have been discarded we call such algorithms as partial stack algorithms this the tradeoff problem is now abstracted as a pebble game on the chain l of n figure it is assumed that the depth of sion n is known this is easily determined in fixed space as indicated above for the case of an invertible function f in the pebble game pebbles are placed and removed on the nodes of the graph according to certain rules and when a node is this indicates that the function associated with that node has been computed and the result has been placed in a register or memory location any input node can be at any time and a node can be only when all nodes which have edges directed into that node have been pebbles can be removed at any time we count only the moves made to place pebbles on nodes an optimal pebbling strategy the problem of computing a function defined by a linear recursive procedure with depth of sion n has been reduced to the pebbling of the nodes of the graph ln of figure in the order n n n while the dependencies indicated by the directed edges if p pebbles are allowed pebbles we let t n denote p are placed on nodes the number to complete of times this task pebble are not counted we note that if node r has a pebble on it when it is to be visited the is not counted in the number of steps to visit np as well as pebble is no more than consider pebble ln the case in which one pebble is used this pebble must be placed to on nodes n done the problem of l in reverse n to pebble node n once this is is reduced to pebbling the nodes order thus n and since this reduces to the case in which two pebbles interesting and indicates how should be as two ln there will be several points are used is more the general case pebbles advance into in time at which one pebble is on a node i and another on node j where j il that is there is a gap between them if the pebble on is removed before it could be used to make another advance the graph then the pebbling is non optimal because over some portion of the graph the algorithm will have made use of only one of the two pebbles this same argument applies to two adjacent pebbles on ln when there are more than two pebbles namely in an optimal algorithm the pebble on the lower index is not removed after a gap between them until it is used to make a subsequent advance with consider a pebbling of ln with p pebbles p n there will be a point in time at which p pebbles are on ln and such that the pebble on the node of lowest index say r will be held in place while the remaining p pebbles are used to pebble the subgraph of nodes n in reverse order since the pebble on node r is used for this advance the problem is equivalent to pebbling with p pebbles after nodes n n rl and r are are used to pebble nodes order since r is chosen the p pebbles in reverse we have l min r since r moves are necessary to bring a pebble node r we call this node a splitting node because it the pebbling problem into to two to solve this recurrence we introduce a number system p to be interpreted given later a positive integer as the number of pebbles for each positive integer n there are unique nonnegative integers m and a such that ns where ti s qm the uniqueness monotonicity identity of these integers follows from of s with m and the following the s s s qm the number system which is important can be extended to the case pl below if we set sl m then when pl we have eo and mn als s p pl so if p have ml and theorem for all p the of pebbles required ln of n nodes with at most minimum number of the chain p pebbles satisfies where unique integers such s that are the ns e pm proof the proof is by m n and p basis the case of pl tn namely has been established above which with b for p n ln can be completely in n moves so n ml and the basis jn states in this case which with expressions for on those boundaries which are shown in figure inductive if is given by for when pp then p and is also given by figure also shows the order in which the induction sequence is carried out we now state the conditions under which the minimum of equation is achieved let gr r t then gr l r consider the forward difference gr gr vt then the minimum r such that evaluate in is achieved at a value therefore we further of since r and p we invoke the inductive hypothesis and use to evaluate the forward differences in to do this we let where u o h and vi where v i sv be the unique pairs of integers such that clearly from rs nr s pv we have h li s s s pv hi which will be used later the forward difference is easily seen to be u when h and r k and can also be shown manipulation equal to u when of is equal to h o by straightforward coefficients similarly v we have u hs v we will also and vt the forward differences and we have u ho u ho vt vl b is is as a direct consequence of the above analysis from these and we have that and since t lo we have uv uv ho ho ho ho is is is is ha as indicated above the set of integers r which minimize the optimal splitting nodes satisfy although not all such integers minimize this expression we consider two classes of integers which minimize and name ly a b s the integers for which z do not minimize while those and o fall and for which into a consider lo r e a such that o then from or v u we have from and the identity s j hi and since os his sp s s pu we conclude that u m v m consider next the case of r e b here we have uv o and and the only case for both conditions hold is this which uv and from and we have s s s pu s from which it follows that u m v m j s l thus if j there is exactly one value for r while value that gr namely r of r satisfies s pm then the s it remains to use the values for r in to show that the minimum is indeed this task is left to the reader u we extract theorem that partial stack some additional will facilitate algorithm for information the construction linear recursion from this of a corollary it satisfies case a for if r is a splitting node the following conditions s ns of l n then s pm s o s nr s s pm p ml case b if n then o and ro we now identify integer of l n r which a single simply computed is the label of a splitting node lemma the integer rl defined by ns satisfies the conditions of the above corollary proof stated the conditions as bounds on as shown below of the r when o s pm corollary can be ns it is easy ns to demonstrate pm that rl the larger of the two lower bounds satisfies both when n s ns s s which is the optimizing in this case upper value we now examine a number of implementation bounds so that of r o u issues partial stack algorithms the exchange that will be obtained from a partial stack algorithm will be determined by the number of temporary stack locations p available and the depth of recursion n we post until another section a discussion of this exchange and present here a program for the realization of an optimal partial stack algorithm our program will use the rule given in lemma for the selection of a splitting node the recurrence of equation defines a partial consists a pebble pebbling stack algorithm when s p n it of pebbling up to a splitting node r with being left on this node followed by a of nodes n in reverse order with p pebbles and then a pebbling of nodes lr with p pebbles if p the single pebble strategy is in reverse order algorithm is optimal used to pebble nodes if p n a standard n stack the partial stack algorithm that uses rl as a splitting node where pm ns is given below in the determination of p the size of the partial stack and the of integers m and are discussed in the next section observe that once the depth of re available to the n is known f na and hf na so the problem reduces to computing a in reverse order or pebbling of comments are shown in brackets determine the depth of and com hf na y a no while do hy d p compute d ss y fy n m and nl od such that observe that use the single pebble strategy if pl a full pd and stack algorithm otherwise pl then call a f d then cm a f fi fi procedure computes f with one procedure w i d za while z i f end procedure complete stack procedure i while j fz j j od i f computes f with a l i d z a while i o do z fz i i od z fz i d f while i z pop f i il q f end s d if single pebble algorithm if p then call is optimal return fi if ml then s and s lp p p and the full stack algorithm then call return so is used fi the splitting s is i then s node when m ­ pm pm ds i if rs pm then and if rs pm in either case s p m m s pm mp we use the s and s then sr rl u du pebble up to the splitting node while i o do rl by nodes rl ii od unless followed rl l call z m su pu f if then else call a ml s p f fi end the number of times a function f ra for that this algorithm computes some l rn is because each of portion the first loop these functions of the program that computes n computes once and the remaining pebbles the graph to the functions f la fa a since f n a and a are com by the first loop for each computation of bound for some there on the number of additional is a fixed upper functions that are computed assignments that are made and tests that are performed in the next section of on p and n we examine the dependence we also examine ways to compute m j and s can be used to compute defined criteria from n this information p based upon user or com implementation issues the number of moves required to pebble ln with p pebbles is given in theorem and is seen to be a linear n between s we have of for ml a pl n for values of n and n for large n and also when n m for large n if m the of n is in to and p is reduced to about these results demonstrate the strong reduction in space that can be achieved at the of a small in in running time from it is clear that the size determines the gap between n and of m largely since lies between and when p if m is to be bounded from above thus p if n is known on the other hand we may wish to bound p at the of m or perhaps attempt to achieve a balance between p and m thus we explore the relationships between m p and the function mp n is symmetric in p and in both thus it is following inequalities smaller of p and m p m and monotone increasing easy to show from the p that the is no larger than when n here here function n and hx is the entropy hx x log x since n is one term mp we have n in the mp expansion of or that the sum mp is at least log n more from if m and p ae comparable in size and n is large it follows that they are both comparable to log n thus we consider three cases when n is large mp s m and pm p p comparable and examine to m we have n which is also this implies p m p a good approximation when p m and by the symmetry of n in m lm pl and p we have which is a good approximation when m p working this equation we have re ml gm gn and the approximation m p if p holds when m p since note that we have v pl p n l p p p in the remaining case when p is proportional we use to approximate n if to for and if n is large we have then taking mp hl p which then when implies that p is proportional lh hh n log n p hk gn to the expressions figure and are shown in we find that grows as pn for p small n p for p and as n if k is neither nor lm p that is the three different zero p m for p proportional to of growth of with n can be selected by choosing p as a function of n which grows more than such as such or a constant as more or which than grows in to respectively the actual value limit of p may also be determined on temporary storage space by an upper once p is chosen the next step is to determine m and s such that s ns ­ by a previous is no larger argument the smaller than for n can be computed in at most of p and m hence s or expressions from one of the following two s p m mp m in fact many fewer may suffice if either p or m are very small to compute m start m at n note that s m and use binary om search by m until is satisfied this will take steps so the entire process can be done in steps conclusions linear recursion has been modeled as a pebble game on graph which is chain of n nodes n the depth of recursion we have the class of optimal algorithms for this pebbling problem and have derived simple explicit expressions for the tradeoff for linear recursion we have also given a simple program for implementing an optimal partial stack algorithm and we have studied the asymptotic be of the tradeoff function for the purpose of providing rules for selection of the amount of space that should be used to achieve various of performance while linear recursion occurs frequently in practice other forms of recursion do also for example if h is a procedure defined by linear recursion and f is the procedure defined below then f is not linear fy if py then hy else however the partial stack algorithm described above can be used to realize h and f if individual stacks are used for each also the same could be said of other forms of recursion it is not known however whether this approach will yield optimal or optimal programs references m s and c e proj mac conf on concurrent systems and parallel computation hole ma pp june a k efficient compilation of recursive programs ibm research rc pp august and the pro of the on switching and automata annual theory symp pp october hopcroft j e w j paul and l g on time versus space jacm vol nc pp paul w j r e tarjan and j r space bounds for a game on graphs ann symp on theory of computing pa pp may n a tradeoff may to appear in jacm ibm paul w j and r e tarjan in a pebble game may and fourth colloquium on automata languages programming g and j e and s tradeoffs on the to appear in the sept issue of the ieee transactions on mation theory d an application of and independence notions for proving lower bounds of circuit complexity scientific math notes inst of branch vol pp m tradeoffs for computing functions using properties of their circuits proceedings of the symp on theory of may r g information theory and reliable communications john and sons new york a j recursively de functions in fortran intl journal of computer and sciences vol no fig i the chain lo for n p ii ii n i fig boundaries and induction sequence for theorem i i c iii o fig the functions and i a 
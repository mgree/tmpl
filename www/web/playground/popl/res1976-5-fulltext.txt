techniques for the of data structures james low and paul computer science department university of new york we are a l l aware of the development of i n c r e a s i n g l y s o p h i s t i c a t e d elaborate and expensive computer programs particularly in the fields of a r t i f i c i a l i n t e l l i g e n c e data base management and i n t e l l i g e n t systems the need f o r techniques to deal with such complexity has i n t e r e s t in programming language research recent work on structured programming compilers automatic program generation and v e r i f i c a t i o n and h i g h l e v e l o p t i m i z a t i o n has r e s u l t e d a pattern of approach similar to that of i e r research on programming languages is the work n a t u r a l l y i n t o two parts the search f o r good l i n g u i s t i c t o o l s f o r expressing algorithms and data and the development of i c a l methods f o r t r a n s l a t i n g these to working computer programs our in t h i s paper is in the latter for programs that are i n h e r e n t l y complex and expensive the choice of representations for highlevel data is a central problem this paper contains a discussion of several powerful techniques for such i n t e l l i g e n t choices for a given program flow analysis execution monitoring and i n t e r a c t i v e sessions about the c h a r a c t e r i s t i c s of the problem are considered builtin knowledge f o r a c o l l e c t i o n of data s t r u c t u r e s is assumed for each data s t r u c t u r e t h i s includes rules about i t s a p p l i c a b i l i t y and formulas f o r i t s memory space and execution time requirements as functions o f the properties of the data and the operations of the program the context f o r the discussion is an experimental system low which chooses data s t r u c t u r e s and algorithms f o r sets l i s t s and in the algol based programming language a b r i e f r i p t i o n of is contained in appendix i s i m i l a r abstract data s t r u c t u r e s are to be found in other experimental programming languages i n c l u d i n g setl schwartz and this paper is organized in two parts the f i r s t an i n t r o d u c t i o n to our methods and an overview of the s e l e c t i o n system the second contains a discussion of our recent work on s e l e c t i o n of a s s o c i a t i v e data s t r u c t u r e s an appendix contains detailed examples of t h i s work system overview the s e l e c t i o n system i s based on the premise t h a t there are many d i f f e r e n t ways o f representing the sets l i s t s and t r i p l e s of a users program a fixed l i b r a r y of such representations is b u i l t into the system a compiler with help from selects representations which will tend to minimize some cost f u n c t i o n such as amount of cpu time f o r the e n t i r e program i t does t h i s by the costs of using the various applicable representations for the users abstract data s t r u c t u r e s then i t chooses those representations which seem to minimize the cost f i r s t i t selects representations by a c t i n g as i f the choices for the various abstract structures were independent later i t considers how these representations i n t e r a c t for example one cost f u n c t i o n is the space time product i f the program has two abstract data s t r u c t u r e s the compiler has to consider the cost component of the space by each data s t r u c t u r e m u l t i p l i e d by the time of execution of operations on the other the compiler may change i t s choice i f these i n t e r actions so d i c t a t e the amount of storage needed f o r the representation will influence the total cost of a representation the cost f o r a representation is u s u a l l y q u i t e easy to estimate consider the representation of a set by a binary tree we estimate the number of storage c e l l s needed by a set of n elements by simply adding the amount of storage needed by a header node to n times the number of storage c e l l s needed f o r each node o f the binary tree a header might consist of two c e l l s a count of the number of elements in the set and a p o i n t e r to the root node of the t r e e each node of the tree contains three memory c e l l s one f o r the element of the set and one each f o r the r i g h t and l e f t l i n k s the storage by a set of four elements would be memory c e l l s two f o r the header and three each f o r the nodes containing the elements of the set note t h a t t h i s notion of storage cost is an approximation a more precise system would have to include such f a c t o r s as the storage a l l o c a t i o n algorithm i n a system we might be able to only a l l o c a t e blocks which are of two and thus each node in the tree above would require four c e l l s instead o f t h r e e whether some form o f v i r t u a l memory such as paging or segmentation was being used and whether there are more than one kind o f local storage such as a fast memory and a slower extended core storage the time cost o f a representation is somewhat harder to estimate the time cost o f a representation is the sum o f the costs o f the i n d i v i d u a l p r i m i t i v e operations used in a given program the time cost of a p r i m i t i v e operation may be by looking at the r o u t i n e which implements i t we count the number o f machine i n s t r u c t i o n s weighted by t h e i r i n d i v i d u a l execution times which w i l l be executed this w i l l be a function o f a number o f relevant parameters of the abstract structure consider the following routine for determining i f an item is an element o f a set which is represented by an l i n k e d l i s t terminated by a nil p o i n t e r a item being b p t r to the f i r s t node o f the linked list c compare p t r to nil and d equal f a l s e e to the data part o f the node pointed to by p t r f i f equal true g p t r from the l i n k f i e l d of the current node h c the execution times o f the i n s t r u c t i o n s are loads take two time units compares take three time u n i t s takes f o r a load and a jump three time u n i t s and jumps take one time u n i t we analyze the r o u ti n e to see how many times each of i t s statements w i l l be executed parts a and b w i l l be executed once independent o f the size o f the set i f the item is in the set then part c w i l l be executed from i to n times i t w i l l be executed ni times i f the item is not in the set part d w i l l be executed no times i f the item is in the set and once i f the item is not in the set part e w i l l be executed from i to n times i f the item is in the set and n times i f the item is not in the set part f w i l l be executed once i f the item is in the set and no times i f the item is not in the set parts g and h w i l l be executed from zero to ni times i f the item is in the set and n times i f the item is not in the set we assume that i f an item is in the set i t is e q u a l l y l i k e l y to be in any node o the l i s t we thus estimate the average frequency o f s t a t e ments c and e when the item is an element o f the set as ni the frequency o f g and h is s i m i l a r l y as n i thus there are only two important parameters a f f e c t the execution time of this routine n the size of the set and p the p r o b a b i l i t y t h a t the desired item is actually in the set the t o t a l time cost o f the r o u t i n e is derived by the weighted i n s t r u c t i o n times we repeated t h i s type of analysis f o r each o f the primitive operations implemented for representation in our l i b r a r y see table i f o r an example set o f time cost functions table i put set i n s e r t item in set h of time item already in the set average size of set m maximum size o f set representation set empty set nonempty linked list tree bit array fm hash t a b le h with linked list fm i attribute bit sorted length array h our system has a l i b r a r y of representations f o r sets sequences and t r i p l e s and a l i b r a r y of corresponding space and time cost functions before the compiler attempts to choose representations f o r a given program i t must obtain information about the use o f the abstract data structures w i t h i n the program this information is obtained in three ways s t a t i c a n a l y s i s monitoring and user the s t a t i c analysis phase constructs a flow graph o f the program and does a symbolic e v a l u a t i o n of the graph this gives a model of the potential contents o f a l l the set and l i s t variables and the store of t r i p l e s in terms of both items and dynamically created items by flow a n a l y s i s we can u s prove t h a t variables w i l l never cont a i n c e r t a i n items and t h a t the a s s o c i a t i v e store will never contain certain triples of items static analysis is also used to obtain a p a r t i t i o n o f v a r ia b le s i n t o classes which should be considered as units when choices o f representation are made there is usually no inherent reason why any two sets o f a program need to be represented in the same way however t r a n s l a t i o n o f representation is u s q u i t e expensive and in general should be avoided our s t a t i c analysis determines which v a r ia b le s are used in the same expressions eg union and i n t e r s e c t i o n or are involved in the same assignment statements such v a r i a b l e s w i l l be represented in the same way the p a r t i t i o n i n g also finds which operations are performed on members o f each representation class this i o n is used to e l i m i n a t e c e r t a i n representations as candidates f o r a class because they d o n t provide all the required primitives monitoring sample executions of the program with user supplied data sets and d i r e c t i n t e r of the user provide the frequency of each p r i m i t i v e operation as well as the parameters to the time and space f u n c t i o n s in the current implementation monitoring is used to determine the frequency of the various statements of the program the compiler the user the values of such things as the average size of a set at a given p o i n t in a program amount of overlap between sets involved in a union or intersection and so f o r t h thus the system can make reasonable of the values of the cost f u n c t i o n s the f i n a l s e l e c t i o n is done by choosing those representations which minimize the total expected cost of a program product based on the information above interactions between choices are considered in the analysis of the t r a d e o f f s of space and time f o r representations of individual abstract data structures selection of associative data structures the s e l e c t i o n system provides a general framework in which to study data structure design a large part of our recent e f f o r t has been d i r e c t e d towards the extension of the system to the selection of associative data structures in we are looking at several a l t e r n a t e data s t r u c tures f o r the store of t r i p l e s in see append i x i i these s t r u c t u r e s consist of v a r i a t i o n s and combinations of four basic types records hash t a b l e s property l i s t s and f i l e s there are many d i f f e r e n t a s s o c i a t i v e data s t r u c tures we have chosen a representative c o l l e c t i o n of s t r u c t u r e s to analyze see appendix i i we chose enough s t r u c t u r e s to require the development of methods f o r explosion in the selection process a real s e l e c t i o n system would be impossible w i t h o u t such methods in addition the collection of structures is r i c h enough to allow the system to consider the issue of sharing vs redundancy as i t selects a data structure an analysis of these s t r u c t u r e s to y i e l d rules f o r t h e i r a p p l i c a b i l i t y and formulas f o r t h e i r space and time costs is complete a d e t a i l e d example of these formulas is contained in appendix ii as in the case of sets and l i s t s s e l e c t i o n of a data s t r u c t u r e f o r t r i p l e s is based on the applicability of the structure to the operations of the program and on o f program execution time and storage requirements these are derived from a static analysis of the program from monitoring example executions and from i o n s of the programmer appendix i i contains examples of such questions the associative model as the system analyzes a program i t b u i l d s a model of the store of t r i p l e s and the operations t h a t are performed on i t the model of the store of t r i p l e s r e f l e c t s the use of these operations by the program the set of make operations is divided i n t o classes two make operations are put i n t o the same class i f there is an erase or search operation t h a t could match t r i p l e s created by both for each class the associated erase and search operations are listed this partitioning reduces the problem of analyzing the entire store of triples for data structure selection to several smaller problems no operation e f f e c t s more than one class within a class the search and erase operations are by t h e i r form this is determined by the arguments to the operation whether they are given items bound variables or any there are xx forms candidate data structures the system uses the s t r u c t u r e i n h e r e n t in a set of associative operations to identify candidate data structures for the class of triples for example assume t h a t the form of a l l search and erase operations is such t h a t the a t t r i b u t e and object p o s i t i o n s are always s p e c i f i e d and there are a f i x e d number of items known at compile time that could appear in the attribute position each such item could be used to s e l e c t a f i x e d f i e l d of the given object in which to find a value moreover i f there w i l l be only one value f o r a given a t t r i b u t e o b j e c t p a i r then there is no need to allow for a set of values this data structure is a f i e l d selection record a similar e c t i o n of such rules is associated w i t h each data structure that the system knows about one of the problems a r i s i n g from our decision to deal with a large library of data structures is explosion in the selection process much of our e f f o r t was spent in methods to t h i s in a d d i t i o n to the e a r l y use of app l i c a b i l i t y r u l e s the system computes and stores useful information about each operation to avoid i t as each data s t r u c t u r e candidate is considered also sets of candidates which d i f f e r in minor ways are treated as u n i t s whenever possible for instance in the previous example i f there is more than one choice f o r which component of the triple form to consider the attribute the candidate structure is not split into separate candidates f o r each choice unless a p r e l i m i n a r y cost analysis indicates that different costs are associated with the d i f f e r e n t choices i f one choice is worse than some other in both space and time it is eliminated the proposal of candidate s t r u c t u r e s proceeds in three phases f i r s t each search and each erase operation is analyzed to determine the set of app l i c a b l e a s s o c i a t i v e r e t r i e v a l techniques these include the s e l e c t i o n of a f i e l d of an object record hash t a b l e lookup property l i s t search and searching various types o f l i s t s of t r i p l e s next each data s t r u c t u r e is considered in a process of matching if the associative techniques provided by the s t r u c t u r e r e a l i z e the needs of the set of operations and the a p p l i c a b i l i t y rules of the structure are satisfied then the s t r u c t u r e is proposed as a candidate f o r the set of operations i t should be noted t h a t each such candidate might represent several instances of a more general s t r u c t u r e for each candidate the process of matching identifies the associative r e t r i e v a l technique to be used f o r each operation and the set of choices f o r r e a l i z i n g each operation the t h i r d phase is the proposal of candidate s t r u c t u r e s t h a t e x h i b i t redundancy the set of a s s o c i a t i v e operations might be more e f f i c i e n t l y r e a l i z e d as two or more subsets each dealing with a data structure that is to its operations the in time may the cost of s t o r i n g more than one copy o f the set of t r i p l e s one problem in t h i s phase is o r i c explosion o f the number o f candidates heuristics are required for selecting only partitions of the set of associative operations the present system is working through phase two of candidate structure proposal a detailed example of i t s output is contained in appendix i i the immediate next steps in the research are to experiment with methods f o r phase three and push through more examples the task of f i n i s h i n g the code which implements the cost formulas and does f i n a l s e l e c t i o n is s t r a i g h t f o r w a r d and w i l l proceed in p a r a l l e l summary our system demonstrates the f e a s i b i l i t y of the automatic selection of highlevel data structures such as the sets l i s t s and t r i p l e s o f in combination the techniques o f analysis and i n have been s u c c e s s f u l l y applied programs t h a t use sets and l i s t s our preliminary analysis of the problem of selecting representations for triples shows that there is much s t r u c t u r e in a store of t r i p l e s and in the a s s o c i a t i v e operations of a program our current research is an attempt to understand how t h i s s t r u c t u r e should be used with the other techniques to select associative data structures appendix i b r i e f description of is an algol based a r t i f i c i a l i n t e l language the abstract data s t r u c t u r e s of include items sets of items lists sequences of items and triples of items an item is e s s e n t i a l l y a reference to a variable allocated from a heap items are normally used to represent abstract and the names of binary r e l a t i o n s a set is an unordered c o l l e c t i o n of d i s t i n c t items a set v a r i a b l e is declared in the same way as any a r i t h m e t i c v a r i a b l e set expressions i n the union o f sets i n t e r s e c t i o n of sets and e x p l i c i t sets eg a b c where a b and c are items a list is an ordered c o l l e c t i o n of items an item may appear in a l i s t more than once l i s t operations include concatenation extract i o n and s u b s c r i p t i n g the triple is used f o r general mappings between items triples consist of three items in order a t t r i b u t e object and value the f i r s t item the a t t r i b u t e is often used as the name of a binary r e l a t i o n between an object and a set of values the store of t r i p l e s and the operations on i t are f u l l y however the language imposes no c o n s t r a i n t s on the i n t e r p r e t a t i o n of the p o s i t i o n of an item in a t r i p l e the syntax for t r i p l e forms is there are three kinds of operations on t r i p l e s in i make which adds a given t r i p l e to the store of triples erase which removes s p e c i f i e d t r i p l e s from the store of triples each of the three arguments to the erase operator is either an item or the keyword any the arguments to erase are treated as a p a t t e r s which is matched against the store of t r i p l e s where any is used any item w i l l match t r i p l e s which match are removed from the store of t r i p l e s search which s p e c i f i e d t r i p l e s in the store of t r i p l e s as f o r erase the three arguments to search are treated as a pattern which is matched against the store of triples in addition to items and the keyword any an argument to search can be a bound v a r i a b l e i f the arguments are all items or any then search behaves l i k e a function returning true if the pattern matches false otherwise if there are any arguments which are bound variables then search behaves l i k e a generator the triples that are found to match the pattern as each t r i p l e is found the bound variables in the pattern w i l l be assigned the corresponding items of the matching triple appendix i i selection of associative data structures examples this appendix contains several of detail from the experimental selection system it has f i v e parts a a description of the data structures which are considered by the system b time and space formulas f o r one of them c examples of questions which the system the programmer d p a r t i a l r e s u l t s of the systems analysis of an example program e the example program l i s t i n g a the associative data structures known to the system the candidate a s s o c i a t i v e data s t r u c t u r e s cons i s t of v a r i a t i o n s and combinations of four basic types records property lists files and hash tables from the many p o s s i b i l i t i e s we have chosen a representative c o l l e c t i o n o f structures to analyze these are l i s t e d and described below in the discussion the three positions of the t r i p l e form are i d e n ti fi e d with particular roles in the various data structures this is done f o r reasons the system and p o s i t i o n s o f the t r i p l e form when appropriate i fi e l d selection records a f i e l d selection record is a block of storage c e l l s the address of the block is from one of the three items of the triple the object another of the items the attribute determines a storage cell w i t h i n the record and a f i e l d o f t h i s c e l l the t h i r d item o f the t r i p l e the value is stored in the specified f i e l d are convenient f o r a s s o c i a t i v e searches in which two o f the three items are given and the a t t r i b u t e is from a fixed set of items are y o f memory space compared to hash tables or files unless there is at l e a s t one value f o r most a t t r i b u t e s o f most objects most of the time there are three types of a one b i t is s u f f i c i e n t to represent the value b the binary r e l a t i o n is singlevalued c there can be more than one value property l i s t this data structure associates a set of a t t r i b u t e v a l u e pairs with each object the address of a l i s t of elements is obtained from the objects record each element contains an a t t r i b u t e and an ordered l i s t of values the l i s t of elements is ordered by a t t r i b u t e property l i s t s are to hash tables where space is at a and the number o f t r i p l e s widely with time they are to when space is at a and most a t t r i b u t e s do not have values most o f the time files an i n v e r t e d f i l e is a l i s t o f t r i p l e s each t r i p l e is represented as a block o f storage cells which contains the three items o f the t r i p l e the l i s t threads a l l blocks that have a p a r t i c u l a r item in a given position there are two types of files a simple a l i s t of t r i p l e s for one p o s i t i o n perhaps ordered by the items in another position b complex m u l t i p l y t h r e a d e d t r i p l e s each t r i p l e block is an element in several l i s t s each l i s t can be ordered and e i t h e r or files are convenient for i v e searches in which only one item is given they are also useful f o r stores o f t r i p l e s t h a t vary widely in size and in place of f o r cases where the set of a t t r i b u t e s is not f i x e d before program they are of processing time for associative searches in which more than one item is given hash tables a hash t a b l e is a block of s t o r age c e l l s a f u n c t i o n which maps t r i p l e s to c e l l addresses w i t h i n t h i s block is used both to i n s e r t new t r i p l e s and f o r a s s o c i a t i v e each cell contains a pointer to the l i s t o f t r i p l e s which map to the c e l l associative r e t r i e v a l via hash tables requires a combination of address computation and searching care is required to match the design o f the function to the properties of the set of triples to avoid large in the length of lists hash tables are convenient for associative searches in which more than one item is given or the set o f a t t r i b u t e s is not f i x e d and computation time is at a hash tables are not convenient when space is at and the size of the store o f t r i p l e s widely as the program runs there are two classes o f hash t a b l e s a all three items are hash operands there are four types of data structure here simple each c o n f l i c t l i s t element contains the three items o f the triple pointers to triple blocks each contains a p o i n t e r to a t r i p l e block this allows sharing with file structures single link each contains a p o i n t e r to a t r i p l e block and is in a file this allows more sharing multiple links each contains a pointer to a triple block and is in one or more f i l e s b two items are hash operands there are types of data structure here l simple each contains the two hash operands a t t r i b u t e and object and a p o i n t e r to a l i s t o f values triple blocks each contains a p o i n t e r to a l i s t o f pointers to triple blocks this replaces the pointer to a list of values as f o r i above each represents a p a r t i c u l a r a t t r i b u t e o b j e c t p a i r and each entry of the l i s t one triple having that pair single link each contains the two hash operands and is in a f i l e the key f o r the f i l e must be one o f the hash operands each contains a p o i n t e r to a l i s t of values single link with triple blocks combination o f and above multiple links each contains the two hash operands and is in one or more f i l e s the keys f o r the f i l e s must be from the two hash operands each contains a pointer to a list of values with pointers to triple blocks combination o f and above the remaining s i x types of data s tr u c t ur e through are v a r i a t i o n s o f l to above each entry on e i t h e r the l i s t of values or the l i s t of pointers to t r i p l e blocks is in a f i l e the key f o r t h i s f i l e is the value b example o f time and space formulas f i e l d selection records io b i t memory c e l l s where na the number o f a t t r i b u t e s no the number o f objects x the average number of values f o r a given a t t r i b u t e and object time make mc erase items given ec value any find items given co value any value a v a r i a b l e where co time to compare two pointers ci time to s e l e c t a given f i e l d of a given object record and pick up its contents c time to i n s e r t an element at a given position in a list c time to remove a given element o f a list c time to pick up the p o i n t e r to the next element o f a l i s t and jump m the f r a c t i o n o f make operations which create new t r i p l e s q the f r a c t i o n of make operations t h a t f i n d a s i m i l a r t r i p l e r the f r a c t i o n of erase operations that f i n d a s i m i l a r t r i p l e e the f r a c t i o n of erase operations that find a triple to erase z the fraction of fully specified find operations that f i n d a s i m i l a r triple v the f r a c t i o n o f find operations f o r t h a t f i n d answers the time to a l i s t of length x the time to generate elements from a l i s t of length x c example questions by the system about the store of triples i for a given a t t r i b u t e and object what is the average size of the set of values for a given object how many a t t r i b u t e s on average w i l l have at l e a s t one value what f r a c t i o n o f questions would f i n d answers i f they were questions how many t r i p l e s on average w i l l have a given value what f r a c t i o n o f questions have answers on average what f r a c t i o n o f make operation executions would create a t r i p l e that already exists what f r a c t i o n o f make operation executions would f i n d a t r i p l e which has the same a t t r i b u t e and object what o f erase executions find to erase d analysis this section contains partial results of the systems analysis of an example program these consist of a c o l l e c t i o n of candidate representations f o r subsequent cost analysis and f i n a l selection after a brief introduction to the example program the candidate representations are described each candidate is listed with a reference to the description of i t s prototype in section a of this appendix the attached t e s t program constructs the minimal spanning tree f o r a given graph and p r i n t s out information about i t s c o s t the algorithm deals w i t h d i s j o i n t sets of nodes and selects edges w i t h the smallest cost which connect nodes from d i f f e r e n t sets each time an edge is found the two sets are merged the r e s u l t is a set of edges which form the minimum cost tree which the graph a set of nodes is represented by a single valued binary relation of the following form node set the p r i m i t i v e a s s o c i a t i v e operations of the program are i make three given items erase given item any given i t e m item given item v a r i a b l e item v a r i a b l e given item the system finds t h a t most of the a s s o c i a t i v e r e t r i e v a l techniques are applicable to each of the search operations but only six candidate representations to propose for the operations taken together i triple blocks ab each t r i p l e is represented as a block of storage cells having two threads each thread is associated with a position in the t r i p l e and is part of a l i s t of t r i p l e s t h a t have the indicated item in the indicated p o s i t i o n the f i r s t thread is in e i t h e r the a t t r i b u t e p o s i t i o n or the object p o s i t i o n and is used by operation the second thread is in either the attribute or the value position and is shared by operations and the first thread is to the removal of t r i p l e s which are to be erased both threads are ordered in this example the first thread represents either a list of all t r i p l e s ordered by nodes or the one t r i p l e which identifies the set containing a given node the second thread represents e i t h e r a l i s t of all t r i p l e s ordered by sets or a l i s t of t r i p l e s which i d e n t i f y nodes belonging to a given set hash table entries ab in t h i s case operations and share a hash table to f i n d a l i s t of objects given the a t t r i b u t e and value in the example t h i s is a l i s t o f nodes which are in a given set each object is in a l i s t of entries for the object operation uses t h i s l i s t to find the set for a given node hash table entries ab this is a v a r i a t i o n on candidate i o n uses the hash table to f i n d a l i s t of values given the a t t r i b u t e and object in the example t h i s l i s t would have one e n t r y the set which contains a given node operations and share the thread through values the thread represents a l i s t of nodes f o r a given set hash table entries ab this is similar to candidate except that operations and share a thread through attributes in the example this thread represents a list of all triples for valued r e l a t i o n s each element of the thread would represent the collection of triples that have a p a r t i c u l a r a t t r i b u t e and a p a r t i c u l a r object hash table and t r i p l e in t h i s case operations and share a hash table to f i n d a l i s t of objects given the a t t r i b u t e and value as f o r candidate t h i s is a l i s t of nodes which are in a given set the d i f f e r e n c e is t h a t hash table e n t r i e s are pointers to triple blocks which are either in the attribute position or the object p o s i t i o n operation uses t h i s thread the thread is to by operation a t t r i b u t e hash table and triple blocks ab this candidate provides a hash table for operation an a t t r i b u t e thread f o r operation and a t r i p l e block thread f o r operation we would expect the p r e l i m i n a r y cost analysis to reject it in of other candidates as the system analyzes i t s model i t questions of the user when i t needs to do so for this example i t two questions i for a given a t t r i b u t e and object is there only one value for a given a t t r i b u t e and value is there only one object i f operation were not present in the example the system would have proposed a candidate representation when provides a l i s t of nodes f o r each set each value would be represented by a record having a f i x e d f i e l d f o r the a t t r i b u t e the f i e l d would contain a p o i n t e r to a l i s t of node items operations and would use the given attribute to select this field of the given value i f only operation were present a s i m i l a r candidate representation would associate a given node with i t s set one of the next steps in the research w i l l be to consider m u l t i p l e redundant representations as candidates in our example the system w i l l then be able to consider the combination of the above two representations as a s i n g l e candidate one d i f f i c u l t y here is dealing with the erase operation a general technique is to convert erase operations to loops with two operations a search with variables in place of and an erase w i t h a l l items s p e c i f i e d e example program l i s t i n g minimal spanning tree construction algorithm begin require list edges priority queue of edges of the graph list item of string item named nodes list item item  elt set costs integer item set set of the nodes of graph set of edges making up minimal spanning tree list refer to an edge item list refer to vertex items integer ec refer to cost of an edge integer costs so far of spanning tree integer disjoint sets of nodes boolean begin if not  bind and  member bind then error if foreach i  temp do make  temp erase  any end execution here costs o comment a b c named d e f g h is an of edges cost edges a b a c a h c e b c b h e f g h e h b e d f b g f g c d e g i i i datum datum datum datum comment initialize set of disjoint sets and the mapping between a node and the disjoint set in which it appears foreach vertex i vertex in make  vertex new spanning tree while i do begin v i w ec if then begin costs costs put in end end comment print out the set of edges of the minimal spanning tree edges and costs of edges foreach that in do begin string v i w ec i i end total cost of spanning tree end references b alternate reference manual stanford a r t i f i c i a l intelligence laboratory april j setl symmetric use of relations institute sept j understanding of data structures lo oct j an the project electronic research laboratory college of engineering dec university of california at berkeley j high level iterators and a method of automatically designing data structure representation electronic research laboratory college of engineering university of california at berkeley j and p an associative language no august low j low automatic coding choice of data structures technical report no i computer science department university of n y d and g the reference manual ai mit may morris j morris a of setl university of california scientific laboratory p automatic selection of associative data structures phd thesis department of mathematics university in preparation j schwartz automatic data structure choice in a language of very high level second symposium on principles of programming languages palo alto california jan j schwartz optimization of very high level and its in computer languages vol l pp press g t and e manual ai memo project mac mit july g why is better than ai memo mit a r t i f i c i a l intelligence lab k user manual stanford computer science technical report july 
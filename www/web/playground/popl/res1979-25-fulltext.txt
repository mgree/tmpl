systematic design of program analysis frameworks cousot and cousot france introduction and summary semantic analysis of programs is essential in optimizing compilers and program verification sys it data flow analysis data type determination generation of approximate invariant assertions etc several recent papers among others cousot graham wegman ullman rosen tarjan have introduced abstract approaches to program which are to the use of a where a is a lattice of approximate assertions t is an approximate pred transformer and y is an often implicit func tion specifying the meaning of the elements of a this paper is to the systematic and correct design of program analysis frameworks with respect to a formal semantics preliminary definitions are given in section concerning the merge over all paths and least fixpoint analysis methods in section we briefly define the forward and backward tive semantics of programs which is later used as a formal basis in order to prove the correctness of the approximate program analysis frameworks section very recall the main elements of the lattice theoretic approach to approximate semantic analysis of programs the design of a space of approximate assertions a is studied in section we first justify the very reasonable assumption that a must be chosen such that the exact invariant assertions of any program must have an upper approximation in a and that the analysis of any program must be performed using a deterministic process these assumptions are shown to imply that a is a moore family that the mation operator with defines the least upper of any assertion is an upper closure operator and that a is necessarily show that the connection a complete lattice we next between a space of assertions and a computer representation is nat made using a pair of func tions this type of connection between two complete lattices is related to galois connections thus making available classical mathematical results additional results are proved they hold when no two approximate assertions have the same meaning this work supported in part by n and and in part by d in section we study and various methods which can be used in order to define a space of approximate assertions or equivalently an function they include the characterization of the least moore family containing an arbitrary set of assertions the construction of the least closure operator greater than or equal to an arbitrary function the definition of closure operators by composition the definition of a space of assertions by means of a complete join congruence relation or by means of a family of principal ideals section is to the design of the approximate predicate transformer of approximate assertions first induced by a space we look for a definition of the correctness of approximate predicate transformers and show that a local correct ness condition can be given which has to be verified for every type of elementary statement this local correctness condition ensures that the merge over all paths or global analysis of any program is correct since is not required for predicate transformers to be correct it is shown that program analysis frameworks are although it is later argued that the hypothesis is natural we next show that among all possible approximate predicate transformers which can be used with a given space of approximate assertions there exists a best one which provides information relative to a the maximum analysis method the best approximate predicate transformer a space of approximate assertions turns out to be some interesting consequences of the existence of a best predicate transformer are examined one is that we have in hand a formal spec of the programs which have to be written in order to implement a program analysis framework once a representation of the space of approximate tions has been chosen examples are given ones where the semantics of programs is formalized using sets of traces in section we that a hierarchy of can be defined according to the fine ness of the approximations specified by a program analysis framework some elements of the hierarchy are and related to the relevant literature in section we consider global program analysis methods the distinction between distributive and program analysis frameworks is studied it is shown that when the best approximate predicate transformer is considered the or not of the merge over all paths and least fixpoint global choice analyses of programs is a consequence of the space of approximate assertions of the it is shown that the space of approximate assertions can always be refined so that the merge over all paths analysis of a program can be defined by means of a least fixpoint of equations section is to the combination of program analysis frameworks we study and how to perform the sum product and power of program analysis frameworks it is shown that analyses lead to more accurate information than the conjunction of the corresponding separate but this can only be achieved by a new design of the approximate predicate transformer induced by the combined program analysis frameworks preliminary definitions t is a pair vg where g program graph and v is the universe in which the pro gram variables take their values the set l of elementary commands consists in elementary tests and elementary assignments an elementary test is a total t map from into an elementary ee la is a total v map from dome sv into a g is a tuple where n is the number of vertices therefore c n is the nonempty set of edges is the entry point no is the exit point and cc el defines the command associated with each ij in e let and inl e then we assume that and for any be be and where is the set of from the j point ni to the vertex i and e aa is re defined as follows if p is an empty path then pl is the identity map on a else p where and p l the system of p the program follows n and is defined as p n i p j u i if notation if is a complete lattice then the set of total maps from the set l into m is a complete lattice l m for the pointwise ordering iff in the following the distinction between s t u t u n will be determined by the context also a map f lm will be extended to lm as xn and to as deductive semantics of programs forward semantics the semantic of a consists in determining at each program point an in variant assertion which characterizes the set of states which are the descendants of the input states satisfying a given entry assertion the program begin do x x end will be represented by its x is an integer no overflow can program graph variable occur more precisely an assertion is a total map from v into r the set a v of assertions is a complete boolean lattice partially ordered by the implication let p be tion derived from the precondition pcf for the ele command sl we assume that the operational semantics of the elementary commands is such that for an elementary test we have l px xx ax whereas for an elementary assignment e we have py that for all sel is a complete morphism ie va a join we assume that the operational semantics of the program k is such that at each program point the invariant assertion pi which characterizes the end of set of states which are the descendants of the input states satisfying a given entry assertion a is the if is a complete lattice and ca then the merge over paths merge over all paths analysis of t using sp and p is the least fixpoint of the system of m using at and defined as is of equations p p associated with the pro pi u p gram it using sp and the system of forward semantic with the program is pi p p i p taking its least fixpoint the descendants of the input states pi ax xl p lx p ax i p ax end of example equations characterizes satisfying backward semantics the backward semantic analysis of a program con in determining at each program point an assertion which characterizes the set of states which are the of the output states a given exit specification since we can consider the inverse of the state transition defined by the operational seman tics no new formalism is necessary in order to treat backward program analysis instead of for predicate transformer we just have to consider s backward predicate trans former q pe notice that is a complete join and meet morphism and the where le o the is program graph corresponding to ax ax xx xx xl ax the corresponding equations is system of backward semantic p pl the merge over all paths and least char of the of the output states satisfying the exit specification ax are both equal to pi ax p ax p ax p ax i end of example in the following no distinction forward and backward program of the above mentioned symmetry will be made because of programs the semantic analysis of programs cannot be au since neither the merge over all paths nor the least fixpoint characterization of the invariant assertions to be generated leads to a computable func tion therefore optimizing compilers and program verification systems are only concerned with the dis of approximate invariants assertions here an approximate is implied invariant assertion q will be one which by the exact invariant assertion p by the deductive semantics definition if then q approximate p iff pq this definition of approximate is the one which is useful in logical analysis of programs data type determination and data flow dual one might be useful eg for proving termination the now classical lattice theoretic approach to approximate analysis of programs can be briefly sketched as follows the representation of an ap assertion is an element of a complete the meaning of the elements of a is specified by a often morphism y mapping a to a subset of assertions ga the intention is that a is an implementable image of those of the program properties which are to be understood at each program point whereas the assertions belonging to are ignored that is approximated from above in ya to each elem command sel is associated an map ts from a to a the is that ts is an predicate transformer such that repre the propagation of the information through the s the ideal merge over all paths graham wegman rosen tarjan is often approximated by a fixpoint tion cousot jones kaplan ullman a fixpoint system of equations where fe is associated with the pro gram graph the approximate invariant assertions are generated by computing iteratively the least fixpoint of f starting from the of an and using any or asynchronous iteration strategy cousot or the least fixpoint is approximated from above using an technique in order to the convergence of the iterates whenever a does not satisfy the a chain condition the design of a t the implicit y and the de termination of the construction rules for f are often empirical the correctness of the least fix point analysis is usually proved with respect to the approximate merge over all paths analysis the cor of which is taken for granted as opposed to this empirical approach we now provide a formal approach to the systematic program framework design of an approximate given where t is sp for forward and for backward pro gram analyses design of a assertions a very reasonable assumption assume that for a analysis of a subset a of assertions has been found to provide meaningful information since any invariant assertion pa for any pro gram must have an upper approximation q in the set qc pq must be non empty let be an assertion and assume that we want to analyze a program m using the merge over all paths analysis and an entry condition q which is an upper approximation of p in x what is the best choice for q it is clear that if p qq then and by the analysis is more precise than hence q be a minimal upper approximation of p in that is such that pq a qe q pq a q q assume that the set u of upper approximations of p in has a cardinality greater than what is the best possible choice for q in u if and then qi and q are not necessarily comparable so that and may be not comparable hence best cannot be defined using the criterion provided by the ordering the only way to which of the two alternatives will be the most useful in order to answer a given set of application dependent questions about the program is to try both of them also the best choice may vary from one program to another this try and see choice method leads to a analysis method which is because of obvious efficiency consider therefore it is reasonable to choose such that example assume that a x integers and where z is the set of q the xo a has two distinct minimal upper approximations in a namely qi x a and q x a now the choice of the most useful upper approximation of the entry tion p is for example the best choice is qi for the program this positive declaration can only be justified by performing the two ie a y and xy a and comparing them since these are not related by the ordering the criterion must be application dependent for example using qi we can prove that xo whereas this is impossible with q on the contrary xx xy a yi the best choice is q for the program since which xo whereas imply xy a not end of example if any program must have an be approximated from above using a and for deriving the most useful approximate any program is required to be reasonable to make the following which can the process analysis of then it is assumption the set za of chosen such that for upper approximations approximate assertions all he set qc of p in a has a least must be pq of element theorem for all the set if and only if contains the of conjunction has a is a moore ie a and is closed under t the approximation operator definition approximation p az p operator o p is the least approximation of p in since is a moore family it follows from and that theorem p is an upper closure that is p is if and pq then for all p pp and ppp pa p is the unique upper closure such that pa on a since is equal to the image of the complete lattice by the upper sure operator p we derive from the following theorem is a complete p is a ie is a complete ie of a iff p is a if the initial assumption choice of does not we can use the following theorem if the upper closure operator p on a such that pa ie the least moore family containing x is p pa as pq a s returning to example where and the least moore containing is the one containing a and the meets of the nonempty that is the complete lattice of the corresponding approximation operator p then then p then then else fi end of example is and a op then ay is a pair of a is onto y is functions the approximation process by the lattice and a pair functions such a pair y defines between a and the dual of a can be defined of a galois con definition let and le be posets ae ll y ll the pair defines a between l and lz if and only if a is xl y is xi si yj y y xi x yl ey yy the above conditions and are equivalent to yy cx y hence we have theorem let ls be posets ac y is a pair of functions if and only if ay defines a galois connection between and l ie iff a and y are theorem imply and representation assertions of the lattice of approximate in order to represent the approximate tions in a computer memory we must use a complete lattice such that the similar algebras and be isomorphic let ye al be the lattice isomorphism let be y p ap is the representation of the least upper approximation of the assertion whereas provides the meaning of the connection ay between a and a has the following property definition let and lg of functions uc ll l is y is r x be posets y if and only if e ax ey is a corollary let and ls be posets and e y ll be functions you is an upper closure operator on li is r a lower closure operator on xx and idempotent moreover if are complete lattices then and and are complete lattices is an isomorphism from onto and y is an isomorphism from onto each function in the pair of functions uniquely determines the other more precisely a x yy u is a complete j y is a complete in complement we will need the following contrary to scott are not required to be continuous lattices need not be continuous l and l and a y theorem if p is an upper closure operator on a the image ya of through the lattice morphism y is equal to pa theorem let and tbe complete lattices and c ll y ll i functions be i l a is onto if and and if and y if one of the above conditions only if only if y is then y li a is an isomorphism from the complete lattice onto the complete lattice l the in of which is y a is if and only if y is onto and if and only if x operator definition in addition now study which can tor moore families can be characterized using or theorems and to theorems and we and various equivalent methods be used to define an upper closure opera we use the notation to state that and l are connected by the pair of functions which are respectively and in if a is a complete from li onto l respectively y is a complete from l into lll we write and assume that the ya is determined by li in the literature the meet usual method for defining a program analysis framework is to specify the complete lattice representing ap assertions and to informally the meaning of its elements eg propagation hence the function ye aa remains implicit it is often the case that a is only assumed to be a complete or dual ly for some authors but since an is to a it is in fact e complete lattice even when the is not used or what is called meet is not n eg when y aa is but not a complete the set ya does not tion with the consequences examined at graph the design of ya and a can be revised as stated by theorem when ye is a complete but not several distinct elements of a have the same meaning since this is useless the of a and y can be revised as follows let be a complete lattice ye aa be a complete lt be ya and is yx u is a lower closure operator on a y is a complete lattice from the into a since expressive ya x among all power of a a and have the same of a which have the x is one with minimal theorem r yl ya i equivalent space of approximate assertions a space o approximate assertions can be either by a moore family or by an upper closure least closure operator greater than or equal to an arbitrary function theorem let be a complete lattice and let l be is the least operator on l than or equal to f let be is the least extensive operator on l greater than or equal to f let dec be x where is the limit of the increasing and ultimately for every constant sequence x such that x fx and for every limit x u xa operator is the than moore is the least closure or equal to f and family contained in fl i definition of a space of approximate assertions by composition of upper closure operators the composition of two upper closure operators m a is not a closure operator however the space of approximate assertions call be designed by successive approximations using the following composition of upper closure operators theorem let be a complete lattice p an upper closure operator on l and n ba an upper closure operator on pl then is an upper closure on l and many program analysis frameworks are designed in order to describe some properties of each program variable but so that the relationships values of these variables are ignored among the an example is jones type determination scheme a counterexample is the determination of linear relationships among numerical variables cousot k the approximation can be characterized as follows assume that qm let am be let us define and al be db v jm vi vm oa a i t o jl o is an upper closure operator on am and an assertion does not state relationships among the program variables if and only if the approximate as on each individual program variable xj are next defined using an upper closure operator pj on a the induced closure operation p on s de by is m pp necessarily it follows xm j of the form p from theorem where pe xm that the composition is an upper closure j operator on am end definition of a space of approximate assertions by means of a complete join congruence relation considering the equivalence relation pi induced by an upper closure operator p on a and defined as if and only if pq the approximation process can be understood as essentially consisting in the space of assertions so that no distinction is made between equivalent assertions which are all approximated by a of their equivalence class since the approximation is from above and a least one must exist assumption not all equivalence relations are acceptable definition let be a complete lattice a bin relation on l is a if and only if e is an equivalence relation o satisfies the property xy o satisfies the property x where is the congruence class containing x theorem jn then if p is an upper closure operator on and if and only if p is a complete p ax relation on l a complete tion on a defines an upper closure operator a space of approximate assertions a theorem let be a complete relation the complete lattice ax an upper closure operator on l on is similar results except complete simplified were already proved in cousot that the above definition of relations has the following result can facilitate the proof a given relation is a relation satisfying and it can be compared with theorem which is relative to congruence relations theorem a reflexive and symmetric binary relation on a complete lattice is a relation iff the following three properties are sat for xy a yz ux a x let v be a nonempty of integers included between two bounds m and either and or and v il the by p q binary relation px e defined on a a qx where and m is a complete join congruence relation the lattice l is isomorphic to pa where operator induced by o p p is the upper closure in conjunction with p can be used for sta tic analysis of the ranges of values of numerical variables cousot end of definition of a space of approximate assertions by means of a family of principal ideals the equivalence classes of the complete congruence relation pi induced by a closure tor p have the property theorem fit e be a complete relation on the complete lattice then is a complete and convex of l let us recall that is iff cl a cb imply that here is another representation of convex sub of l which can be compared with representation of convex an is a subset j of a lattice with the properties and b al a ea it is easy to show that j ideal when if and only if and property holds since l has an the intersection of an infinite family of ideals in a lattice l is an ideal of l given an element a in a lattice l the set is an ideal it is called a of l if every chain in l is finite every ideal is principal a is a subset i of l with the the dual notion is the one of theorem let be a principal ideal and j be a dual ideal of a complete lattice if inj is then inj is a complete and of l every complete and convex c of l can be expressed in this form with uc and theorem i let be a family of principal ideals of the complete lattice containing l then ia a is an upper closure operator on l u the following lattice analysis of the of can be used for values of numerical static t zo where zo t stand for a further approximation can be defined the following family of principal ideals by design of the approximate predicate transformer induced by a in addition to a and y the specification of a program analysis framework also includes the of an approximate predicate transformer t aa or a monoid of maps on a plus a rule for maps to program statements eg we now show that in fact this is not since there exists a best correct choice of t which is induced by and the formal semantics of the con programming language a reasonable definition predicate transformers of correct approximate at given at the minimal tion which is invariant at point i of a program t with entry specification was defined as pi v tp therefore the minimal approximate is the least upper approximation invariant of pi in f that is p v tp o even when is a finite set of finite paths the evaluation of rp is since for each path am the computation se xo xl does not necessarily therefore only involve elements of a and using c and tl a machine representable sequence is used instead of xo xm which leads to the expression which induces an upper closure n operator p lj and the space of approximate assertions in ex choice of and is is an upper approximation only if correct of pi only in a that is if if qi and v p p v p for the entry point we must have p so that we can state the following definition an predicate transformer is said to be a upper approximation of if and only if for all wa c such that and program m we have similarly if is said to be a correct upper approximation of in if and v vw e ie this global correctness condition for is very difficult to check since for any program and any program point i all must be however it is possible to use instead the following equivalent local condition which can be checked for every type of statements end of theorem ze lll is a upper of jn iff we pi p te is a correct upper approximation o tc in where if c is correct upper tion aa in we have the cases when equality holds are not easy to yet the following sufficient condition turns out to be theorem if is a correct upper of t in pa and ts pp then vm v if t is a correct upper approximation of t in a where and p then wr v similar programs results hold for fixpoint analysis of theorem let be an correct upper approximation of where then we ay vt is if y and sp then equality holds in notice that in theorem are not assumed to be the maps sl yet is assumed in theorem and is a thesis in the an apparent tion of this additional requirement gs to ensure that the system of equations x with a program it has fixpoints which can be obtained as limits of iteration sequences this could also be without but thesis taking xl instead of theorem let be a correct of aa in then y vt upper l e where l is the limit of the iteration sequence x fx for successor x xu for limit hence the hypothesis is even not for technical purposes however the justification of this hypothesis can be found in the fact that among all possible approximate predicate transformers which can be used with a given set a of approximate assertions the designer of a program framework intuitively co the best approximate predicate transformer which be this property also explains that no significant counterexamples to hypothesis have ever been found happens to the fact the the best approximate predicate transformer induced by a space of approximate assertions definition if f ar correct upper aa in then we say that tl is all and all programs r of n lemma let be correct upper in if of r and tl or tz is then tl is better than tz notice that the above condition is but not necessary theorem aa is is a upper f tl aa in iff ts sl t is the best correct upper approximation of t in a corollary if then is it is correct upper approximation of t in a the the most interesting consequence is that we have in hand a formal specification of the programs which have to be written in order to implement any specific program analysis framework once a and y have been chosen as a challenge to automatic pro gram let us consider a simple coming back to examples and assume that vis the set of integers included two bounds m and for simplicity we shall assume that m let l be the complete lattice a ab with ordering ab iff and is the let y e l be such that ax let a and zf x or yl then else xy fi let ab be ay y given a and y let us determine the best upper approximation of sp in a again for lack of space we just study the case of since y is an injective complete the function is determined by a then f the same way a e all is where and according to theorem the best upper ap else of if in a is t pa equals then tp where ab and d in which case where a a y a a a ax a since therefore the same way tp ad then proving that this choice in was optimal end of le some program analyses such as reaching available expressions live variables aho ullman are history sensitive because the approximate assertions which are useful at each program point p characterize sets of sequences of states or execution paths from the entry point to p and not sets of states in such a case formal definition of languages using sets of tial traces is more convenient that the deductive semantics of associating program a set of traces with a given a universe of values a set la of ele assignments a set lt of elementary tests the set of traces is the free monoid to generated by l the concatenation operation is extended to elements of the complete lattice by a let us define a forward set of as the set of traces associated with a program t and an entry specification is a set of characterizing of the states traces the by an the connection with the deductive semantics of is made using such that for any set t of traces ut characterizes the descendants of the entry states belonging to when the traces are executed from an obvious hence not given here operational semantics of se traces we derive that where is that and at since a is a complete from t onto a defines an function according to theorem the best correct upper approximation of f in a is we have sl typ p since is a complete t theorem hence the best correct approximation of j in a is since sl and are complete upper join morphisms and ol theorems and im that for all programs t the data flow equations of let e be the set of expressions the set of expressions which are available at exit of a path is defined by and where is the set of expressions in not by the command s while is the set of generated by s an expression is available at some program q if it is available at exit of every path from the entry point expressions available ni to q therefore the set of at q ie where is since u is a complete from onto theorem o defines an function y according to theorem q the best correct upper approximation of ft in k is at since t and and is a complete on theorems and imply notice that as defined at taking to be is the classical system of data flow equations for available expressions aho ullman and that the largest possible solution least for is desired end of hierarchy of program analysis frameworks once the semantics of programs has been defined by at all program analysis frameworks are specified up to the isomorphism y by where is an upper closure operator on a and program analysis frameworks can be partially ordered using the order ing of the corresponding closure operators on a since whenever pi e p pa so that program analysis frameworks corresponding to pi yield er information than the ones corresponding to p global program analysis method is used the following theorem is a constructive version of theorem the of upper closure operators lattice is a complete on a in order to briefly illustrate the hierarchy of program analysis frameworks let us consider three comparable examples the approximation func tion of which can be sketched using a analogy let p be a predicate over two numerical variables x and y the characteristic of which is the following y ol x the upper closure operator of defines a very approximation this set by the ing all its points example consisting in ap of contain a more precise approximation example consists in the characteristic set of p by the rectangle including it and whose sides run parallel with the y y o pp xy x a refinement consists in set of p by its the char ox the corresponding framework was used for the tic discovery of linear among variables of programs cousot end of example solution to analysis problems since whenever some ts is not a complete can be strictly better than when a satisfies the chain condition is computable which is not necessarily the case of in that case a variety of methods can be used eg rosen which can find information that fixpoint methods and there approach the ideal merge over all paths solution which provides the maximum information relevant to a t and y in our the above argument is not entire ly since for different correct approximate predicate transformers tl the case that to from the burden of chosen predicate transformers the argument must con the best approximate predicate transformer relevant to a then the following result is a useful complement to theorem theorem let el be the approximation of in if is a complete of a then zf if o a and t where paths versus least fixpoint global analysis of programs distributive program analysis frameworks we at that once a program analysis framework has been designed the analysis problem has various solutions including the merge over all paths and least fix point solutions it is known that when a satisfies the chain condition and ts is we have e also the additional hypothesis that vl is a sometimes called map implies slightly more general is the fol theorem if is a complete lattice and ie such that ts is then for all programs it and a e if moreover ts is a complete then this theorem is implicitly used at taking a for asl and either sp or z for t if and ccl aa then the above theorem establishes the correctness of with respect to in the literature the correctness of is generally taken for also is considered ae the desired and etc not a of a since the merge over all paths analysis of the program f xo then xo do x x od fi which is powerful enough in order to determine that the does not terminate is strictly better than the least fixpoint which fails to cover that is invariant on the exit path of the loop end of le program analysis frameworks the over all paths analysis of a program using some program analysis frame work can always be defined by means of the least fixpoint of a system of equations associated with that program theorem let be a complete be an approximate predicate trans former be the complete of all subsets of a be be ap up v cl ts ie a complete ea the above construction since at is not is a at in define is not fully isomorphic to at t so that the of as a least fixpoint is too complicated construction is the fol lemma let ll be defined be a complete as lattice and ii then else h s fi f v and are upper closure operators on zl let in the theorems r the least be the join lattice of upper closure and complete of l containing of and on zl is h let p be an upper closure un then closure operator on l which operator xy is less on is the great than or equal to p and which is a complete theorem let p closure operator on a aa be a correct upper approximation of let be pq and be then lit ex moreover whenever one of the following three conditions holds p ie a complete join morphism and wl s pp and tl i the best correct upper approximation of t in coming back to example where a z and pa au and applying theorem we get ta pa so that according to w end of le it is clear that when satisfies the chain condition the construction of theorem may lead to a refined space of approximate assertions na which does not satisfy the chain condition then the iterative computation of may not be naturally in a finite number of steps nevertheless this least fixpoint can be approximated from above using an technique in order to the convergence of the iterates such a technique was developed in cousot using a wide operator in our case a possible choice of v is ql choice will guarantee that the refined fixpoint based on and vi will be more precise than the original one based on p but other application dependent definitions of v might even be more frameworks the ideal method in order to construct a pro gram to be integrated in optimizing com or program verification systems would consist in a separate design and implementation of various complementary program analysis frameworks which could then be systematically combined using a once for all implemented in section we show that such an automatic combination of independently parts would not lead to an optimal and that unfortunately the efficient combination of pro gram analysis frameworks often the sion of the original design phase reduced product of program analysis frameworks theorem let be two program sis frameworks such that and tl tz are correct upper of t in al the direct product of and is defined as l if moreover tl and cz are then this definition of direct product is not since y is not necessarily injective and t is not necessarily optimal hence given a global program analysis algorithm we can get than the one obtained by the separate analyses just by the definition of a and t as stated in theorems and theorem let and be two program frameworks such that ai tl as and t ls are respectively the best upper approximation of t in a let be as the is where a u s t y a ap this inequality can be strict s and since xa is a repre of the space o assertions corresponding to the meet of the closure operators and ya theorem s and ya viz to the join of the moore families o le t t l xo x yl o ev otherwise the product is t t the following program manna ys x with the convention ° xi and natural number x p computes for every integer xx do z then else yy fi od z the fixpoint analysis with entry condition result xo using al leads to the for the variable yz fol io let be posets the sum of l and l is the set of all elements in li or lz considered as disjoint when and are complete lattices we can de fine the disjoint sum ll as li with ordering xy iff x or yt or xy or and the meaning of elements of ll can be defined as ay yx yx if if xl even when yl and y are complete y may be neither nor a complete meet morphism in order to satisfy assumption the set must be completed using theorem then it turns out that the least moore family contain ing is equal to y ll y as defined in theorem therefore the use of disjoint sums amounts to the use of reduced products end of reduced frameworks power of program analysis the power ll with base let noted is the set of all maps from l to lz with fg if and only if fx for all x in l two program frameworks and can be combined by letting mean that for all x in al holds whenever theorem the reduced power with base and is where a is v xl is tk and is and ts gz a vl with lh example tz the fixpoint using az leads to the result for the variable y i y t t od ev ev t t ev according to theorem the direct product of the above analyses cannot yield information on the other hand using the reduced direct product a and the correspond ing optimal approximate predicate transformer which takes account of the rule od ev we get y t t od tt t end of le bl xo etc b y the analysis of the program x b b x xl b xo j od using the reduced product of al and a yields no information since no relationship can be discovered between b and x following theorem we determine that if then g therefore where h g it follows that is isomorphic to ta or the of with the above program and the entry specification is then gl b bt then else f gz bt then g fi g b bt then l b then gs j fi t the iterative resolution of this tions starting from the yields b b b b of end of example references aho av jd design co g lattice theory colloquium third cd ri p iterative methods for a fixed system of equations in a de n sept p cousot r ai abstract unified model for static ss of programs by construction or tion of conf rec of the th acm symp on principles of programming languages jan cousot p r b static of of procedures ifip working conf on formal description of programming concepts northholland co aug p n automatic discovery of among of a pro gram conf rec of the th acm symp on of programming languages jan ew a prentice hall nj rw assigning to programs proc symp in applied math vo ri graham sl wegman m a fast and algorithm for analysis jacm g distributive san francisco lattice lattices wh and co and g et and ence n acts math sci hoare car an programming cacm to hoare car some of predicate transformers jacm july jones nd muchnick ss ing in programming some toward the design of an deal conf rec of the rd acm symp on principles of programming languages ga jan kaplan ma jd a scheme for the automatic inference types conf rec of the th acm symp on principles of programming jan unman jd frameworks acts monotone data informatica ga a unified approach to program optimization conf rec of acm symp on principles of programming languages boston mass oct manna theory hill co of computation a h de et par math o of math combination of ann o connections trans g math j rosen b conf rec programming monoids for data of the th acm symp on principles of languages scott d continuous math springer verlag notes in scott o data types as sept siam comp a ww notes in comp sci data types as objects springer verlag tarjan re iterative for in algorithms and new and results cd press inc am type determination high rep dept ny univ oct for very comp sci m the operators math of a lattice b property extraction in sets ieee trans on soft se sept le 
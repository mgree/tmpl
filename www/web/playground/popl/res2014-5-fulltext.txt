tracing compilation by abstract interpretation di university of italy microsoft research wa usa di university of italy abstract tracing compilation is a popular compilation schema for the efficient implementation of dynamic languages which is commonly used for javascript python and php it relies on two key ideas first it monitors the execution of the program to detect socalled hot paths ie the most frequently executed paths then it uses some store information available at runtime to optimize hot paths the result is a residual program where the optimized hot paths are guarded by sufficient conditions ensuring the equivalence of the optimized path and the original program the residual program is during its execution eg to add new optimized paths or to merge existing paths tracing compilation is thus different than traditional static compilation nevertheless despite the practical success of tracing compilation very little is known about its theoretical foundations we formalize tracing compilation of programs using abstract interpretation the monitoring viz hot path detection phase corresponds to an abstraction of the trace semantics that captures the most occurrences of sequences of program points together with an abstraction of their corresponding stores eg a type environment the optimization viz residual program generation phase corresponds to a transform of the original program that preserves its trace semantics up to a given observation as modeled by some abstraction we provide a generic framework to express dynamic optimizations and to prove them correct we instantiate it to prove the correctness of dynamic type specialization we show that our framework is more general than a recent model of tracing compilation introduced in popl by and palsberg based on operational bisimulations in our model we can naturally express hot path and common optimizations like elimination which are either or unsound in and framework categories and subject descriptors d software engineering verification Г correctness proofs formal methods d programming languages processors Г compilers optimization f logics and meanings of programs semantics of programming languages Г program analysis keywords tracing compilation abstract interpretation trace semantics permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than the authors must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january Г san diego ca usa copyright is held by the publication to acm acm introduction efficient traditional static compilation of popular dynamic languages like javascript python and php is very hard if not impossible in fact those languages present so many dynamic features which make all traditional static analyses used for program optimization very therefore practical implementations of dynamic languages should rely on dynamic information in order to produce an optimized version of the program in particular tracing compilation Г has as a valuable implementation and optimization technique for dynamic languages for instance the virtual machine for php and the v javascript engine of use some form of tracing compilation the javascript engine used to have a tracing engine which has been later substituted by compilation initially and then the problem tracing jit compilers runtime profiling of programs to detect and record often executed paths called hot paths and then they optimize and compile only these paths at runtime a path is a linear sequence of instructions through the program profiling may also collect information about the values that the program variables may assume during the execution of that path which is then used to the code of course this information is not guaranteed to hold for all the subsequent executions of the hot path since optimizations rely on that information the hot path is augmented with guards that check the conditions such as for example variable types when a guard fails execution jumps back to the old code the main hypotheses of tracing compilers by the practice are i loop bodies are the only interesting code to optimize so they only consider paths inside program loops and ii optimizing code is easier than a analysis involving loops goto etc hence tracing compilers look quite different than traditional compilers these differences raise some natural questions on trace compilation i what is a formal model which is generic yet realistic enough to capture the behavior of real ii which optimizations are sound iii how can one prove their soundness in this paper we answer the above questions our formal model is based on program trace semantics and abstract interpretation hot path detection is modeled just as an abstraction of the trace semantics of the program which only i the sequences of program points which are repeated more than some threshold ii an abstraction of the possible program stores eg the type of the variables instead of their concrete values as a consequence a hot path does not contain loops nor join points furthermore in the hot path all the correctness conditions ie guards are explicit for instance before performing integer addition we should check that the operands are integers if the guard condition is not satisfied then the execution leaves the hot path to the code guards are essentially elements of some abstract domain which is then left as a parameter in our framework the hot path is then optimized using standard compilation techniques we only require the optimization to be sound we define the correctness of the residual or extracted program in terms of abstraction of the trace semantics the residual program is correct if it is up to some abstraction of the trace semantics from the original program examples of abstractions are the program store at the exit of a method or the stores at loop entry and loop exit points main contributions this paper puts forward a formal model of whose key features are as follows Г we provide the first model of tracing compilation based on abstract interpretation of trace semantics of programs Г we provide a more general and realistic framework than a recent model of by and palsberg based on program bisimulations we employ a less restrictive correctness criterion that enables the correctness proof of actually implemented optimizations hot paths can be annotated with runtime information on the stores notably type information optimized hot loops can be Г we formalize and prove the correctness of type specialization of hot paths our model on program transformations and optimizations of a low level imperative language with untyped global variables which may play the role of intermediate language of some virtual machine our starting point is that program optimizations can be seen as transformations that lose some information on the original program so that optimizations can be viewed as approximations and in turn can be formalized by abstract interpretation more precisely we rely on the insight by cousot and cousot that a program source can be seen as an abstraction of its trace semantics ie the set of all possible execution sequences so that a optimization can be viewed as an abstraction of a transform of the program trace semantics in our model soundness of program optimizations is defined as program equivalence wrt an observational abstract interpretation of the program trace semantics here an observational abstraction induces a correctness criterion by describing what is observable about program executions so that program equivalence means that two programs are by looking only at their observable behaviors a crucial part of tracing compilation is the selection of the hot paths to optimize of course this choice is made at runtime based on program executions so it can be seen once again as an abstraction of trace semantics here a simple trace abstraction selects cyclic instruction sequences ie loop paths that appear at least n times within a single execution trace these instruction sequences are recorded together with some property of the values assumed by program variables at that point which is represented as a value of a suitable store abstraction which in general depends on the successive optimization a program optimization can be seen as an abstraction of a semantic transformation of program execution traces as described by the in the advantage of this approach is that optimization properties such as their soundness are easier to prove at a semantic level the optimization itself can be defined on the whole program or as in the case of real tracing jit compilers can be restricted to the hot path this latter restriction is achieved by transforming the original program so that the hot path is extracted ie made explicit the hot path is added to the program as a path with no join points that jumps back to the original code when execution leaves it a guard is placed before each command in this hot path that checks if the necessary conditions as selected by the store abstraction are satisfied a program optimization can be then confined to the hot path only making it linear by ignoring the parts of the program outside it the guards added to the hot path allows us to retain precision we apply our model to type specialization type specialization is definitely the key optimization for dynamic languages such as javascript as they provide generic operations whose execution depends on the type of runtime values of their operands related work a formal model for tracing jit compilation has been put forward in popl by and palsberg it is based on operational bisimulation to describe equivalence between source and optimized programs in section we show how this model can be expressed within our framework through the following steps and language is compiled into ours we then exhibit an observational abstraction which is equivalent to and correctness criterion finally after some minor changes that address a few differences in path selection the transformations performed on the source program turn out to be the same our framework some significant limitations in and model the bisimulation equivalence model used in implies that the optimized program has to match every change to the store made by the original program whereas in practice we only need this match to hold in certain program points and for some variables such as in output instructions this limits the number of real optimizations that can be modeled in the theoretical framework for instance dead store elimination is proven unsound in while it is implemented in actual tracing compilers section furthermore their formalization fails to model some important features of actual implementation i traces are simple linear paths of instructions ie they cannot be annotated with store properties ii hot path selection is completely nondeterministic they do not model a selection criterion and iii once execution leaves an optimized hot path the program will not be able to it it is also worth that abstract interpretation of program trace semantics roots at the foundational work by cousot and has been widely used as a successful technique for defining a range of static program analyses Г abstract interpretation has been used to describe static compilation and optimizations in particular describes various optimizations as trace abstractions they preserve in the cousot and cousot terminology approach corresponds to offline transformations whereas tracing compilation is an online transformation language and concrete semantics syntax following we consider a basic low level language with untyped global variables a kind of elementary dynamic language program commands range in c and consist of a labeled action which specifies a next label l is the undefined label where the execution becomes stuck labels l l l l values v value variables x var expressions exp e v x e e boolean expressions b tt ff e e гb b b actions a a x e b skip commands c c l a l l l l for any command c l a l we use the following notation l a and succ l commands l b l whose action is a boolean expression are called conditionals a program p c is a possibly infinite at least in theory set of commands with a distinct initial label lin from which execution starts so that denotes the commands in p labeled by lin consists of two commands when the initial command is a conditional if a program p includes a conditional c l b l then p must also include a unique complement conditional l гb l which is denoted by or cc where is taken to be equal to b so that c for simplicity we consider deterministic programs ie we require that for any c c p such that if then c if then c c the set of wellformed programs is denoted by program transition semantics the language semantics relies on the following type values where char is a nonempty set of characters and undef represents a generic error int z bool true false string char undef undef in turn value and type names in types are defined as follows value int string undef types int string undef any while type value types provides the type of any value here the type name any plays the role of top type which is the supertype ie contains all types while is the bottom type which is a subtype for all types let store var value denote the set of possible program stores the semantics of expressions and program actions is standard and goes as defined in fig let us remark that the binary function int denotes integer addition и is string concatenation logical negation and conjunction are extended in order to handle undef values ie undef and undef b undef b undef with a slight of notation we also consider the socalled collecting versions of the semantic functions in fig e exp store value e e s e e s b store store b b s s b b true a a store store a a s a a s a a undef program states are pairs of stores and commands state store if p is a program then store we extend act and suc to be defined on states meaning that they are defined on the command component of a state also stores returns the store of a state s given p program the program transition relation s p between states is defined as follows s p c c a c p succ it is worth that according to the above definition if c l a l c l b l and cc l гb l are all commands that belong to p and a a then we have that s p c c cc trace semantics a partial forward trace is a finite sequence of program states which are related by the transition relation s if p is a program then we define i i s p i a trace is maximal if for any state s s let us note that according to the above definitions if a trace has a last state l b l with a conditional command such that b b false then is maximal also if a trace has a last state l a l whose next label is the undefined label then is maximal as well the trace semantics t p is the set of all the partial including maximal traces of the program p this set is defined as the least fixed point of a monotonic operator f p called trace transition operator defined as follows f p x store ss s x s s p s t p p the function f p is trivially monotone on the complete lattice so that its least fixpoint t p is well defined example let us consider the program below written in some x while x do x x if x then x x its translation in our language is given below where with a little we assume that the syntax of arithmetic and boolean expression is extended to allow expressions like x p c l x l c l x l cc l гx l c l x x l c l x l cc l гx l c l x x l c l skip the trace semantics t p includes the following partial traces where stands for any integer value and stores are denoted within square brackets x c f p x c x c x c x cc maximal x c x c x c x c x c x c x c x c иии x c x c x c x c x c x c x c x c x c x c x c x x x x maximal x c x cc maximal x c x c иии x c и и и x c x c maximal x c и и и x c x cc x c maximal e exp store value e v v e x x e e e e e int e e e e и e e undef if ei int if ei string otherwise b store true false undef b tt true b ff false b e e e e e e if ei int undef otherwise b гb гb b b b b b b b b a a store store undef a x e x e e a skip ab undef if b b true if b b false if b b undef figure semantics of program expressions and actions abstract interpretation background in standard abstract interpretation abstract domains or abstractions are specified by galois for short or equivalently concrete and abstract domains c c and a a are assumed to be complete lattices which are related by abstraction and concretization maps c a and a c that give rise to an c a that is for all a and c c a a c c a a gc is a gi when xx it is well known that a uniquely determines as follows a c c c a a conversely a uniquely determines as follows c a a c c a let f c c be some concrete monotone function for simplicity we consider functions and let f a a be a corresponding monotone abstract function defined on some abstraction a related to c by a gc then f is a correct abstract interpretation of f on a when f f holds where denotes the pointwise ordering moreover the abstract function f a f a a is called the best correct approximation of f on a because any abstract function f is correct iff f a f hence for any abstraction a f a plays the role of the best possible approximation of f on the abstract domain a store abstractions as usual in abstract interpretation a store property is modeled by some abstraction store that we assume to be encoded through a galois connection store store store store for instance as we will see later the static types of program variables give rise to a simple store abstraction given a program p a store abstraction store also induces a corresponding state abstraction store and in turn a trace abstraction abstractions store abstractions can be easily designed by a standard pointwise lifting of some value abstraction let value be a value abstraction as formalized by a galois connection value value value value value the abstract domain value induces a store abstraction var value where is the pointwise ordering induced by value iff for all x var x value x here the bottom and top abstract stores are respectively and x value the abstraction map value store is thus defined as follows value s x value s while the corresponding concretization map value store is defined by from value as in section and it is easy to check that it turns out to be defined as follows value store x var x value x hot path selection a loop path is a sequence of program commands which is repeated in some execution of a program loop together with a store property which is valid at the entry of each command in the path a loop path becomes hot when during the execution it is repeated at least a fixed number n of times in a hot path selection is performed by a loop path monitor that also records store properties see eg here hot path selection is not operationally defined it is instead modeled as an abstraction map over program traces ie program executions we first define a mapping loop that returns all the loop paths in some execution trace of a program p formally a loop path is a substring ie a segment of a trace such that the successor command in of the last state in exists and coincides with the command Г or its complement when this is the last loop iteration Г of the first state in there is no other such command within otherwise the sequence would contain multiple iterations the last state of performs a backward jump in the program p to recognize backward jumps we consider a topological order on the control flow graph of commands in p here denoted by loop c и и и n cn i ci i ci и и и j cj i j n ci cj k i j ck ci let us remark that a loop path i ci и и и j cj loop c и и и n cn may contain some path namely it may happen that loop i ci и и и j cj so that some commands ck with k i j occur more than once in i ci и и и j cj we notation by using store to denote a map store which abstracts program traces in store c и и и n cn store c и и и store n cn given a static parameter n we define a function which returns the set of store abstracted loop paths appearing at least n times in some program trace to count the number of times a loop path appears within a trace we use an auxiliary function count О n such that count yields the number of times an abstract path occurs in a abstract trace count a c и и и an cn b c и и и bm cm nm x if ai ci и и и aim b c и и и bm cm otherwise i hence can be defined as follows hot n c и и и n cn ai ci и и и aj cj i ci и и и j cj loop st i j store i ci и и и j cj ai ci и и и aj cj count store ai ci и и и aj cj n » finally an abstraction map collects the results of applying to a set of traces t hot n a hot path hp p is also called a n hot path and is denoted as hp a c an cn let us observe that if the hot path is the body of some while loop then its first command c is a conditional namely c is the boolean guard of the while loop we define the following successor function for indices in hot paths next i i n i for a n hot path a c an cn t p for any i n if ci is a conditional command li bi then throughout the paper its complement will be also denoted by li example let us consider the program p in example we consider a trivial store abstraction store where all the stores are abstracted to the same abstract store ie store s here we have two hot paths in p that is it turns out that hot t p hp hp where hp c l x l c l x x l cc l гx l hp c l x l c l x x l c l x l c x x l trace extraction for any abstract store a store a corresponding boolean expression guard ea is defined where the notation ea should at an expression which is induced by the abstract store a whose semantics is as follows for any store b guard ea store a thus in turn we also have program actions guard ea such that a guard ea if store a if store a let p be a program and hp a c an cn t p be a hot path on some store abstraction store we define a transform of p where the hot path hp is explicitly extracted from p this is implemented by a suitable of each command ci in hp which is in turn by the conditional guard induced by the store property ai to this aim we consider three injective functions n l l n l и l l where l l and l are pairwise disjoint sets of fresh labels so that l l l the transformed program for the hot path hp is defined as follows and a graphical example of this transform is depicted in fig definition trace extraction transform the trace extraction transform of p for the hot path hp is p c p ┤ l l l lc p hp where the of hp into p is defined as follows hp l guard ea l ea l i li i n n l i i n p li guard i li li i n the new command l guard ea is therefore the entry conditional of the hot path hp while any command c hp such that succ l is a potential exit or out command of hp l b lc l a l ln an l guard ea b lc l guard ea a l ln guard n an l b lc l a l ln an figure an example of trace extraction transform on the left a hot path hp with commands in in dotted shapes on the right the corresponding trace transform with new commands in blue in dotted shapes lemma if p is wellformed then for any hot path hp is wellformed let us remark that the of the hot path hp into p is always a linear sequence of different commands namely hp does not contain loops nor join points furthermore this happens even if the hot path hp does contain some inner technically this comes as a consequence of the fact that the above functions are required to be injective hence even if some command c occurs more than once inside hp then these multiple occurrences of c in hp are transformed into differently labeled commands in hp example let us consider the program p in example and the hot path hp c c cc in example where stores are abstracted to the trivial abstraction store here we have that for any store store b guard e true the trace extraction transform of p wrt hp is therefore as follows p c cc l x l l гx l hp where hp h l guard e hc l e l h x l hc гx l h l guard e hc l e l h x x l h l guard e hc l e l h гx l hc x l hence can be rewritten at a highlevel representation using while loops and as follows x l while guard e do if гx then goto l if e then goto l x x if e then goto l if x then goto l if гx then goto l l x x l if гx then goto l l x x goto l l skip correctness as by cousot and cousot par correctness of dynamic program transformations and optimizations should be defined with respect to some observational abstraction of program trace semantics a program transform is correct when at some level of abstraction the observation of the execution of the subject program is equivalent to the observation of the execution of the transformed program the approach by and palsberg basically relies on a notion of correctness that requires the same store changes in both the program and the original program this can be easily encoded by an observational abstraction sc store of trace semantics that store changes in execution traces of a program p sc store sc sc c sc c if if c if c c if c c sc t since sc obviously preserves arbitrary set unions it admits a right adjoint sc store defined as t s that gives rise to a gc sc store sc however the store changes abstraction sc may be too strong in practice this condition can be thus relaxed and generalized to an observational abstraction that demands to have the same stores possibly just for some subset of variables only at some specific program points for example these program points may depend on the language in a language without output primitives and functions as that considered in we could be interested just in the final store of the program when it terminates or in the entry and exit stores of any loop containing an extracted hot path if a more general language includes a sort of primitive put x that outputs the value of program variables ranging in some set x then we may want to have stores with the same values for variables in x at each output point moreover the same sequence of outputs should be preserved ie optimizations must not modify the order of output instructions we therefore consider an additional sort of actions put x a where x var is a set of program variables the semantics of put x obviously does not affect program stores ie a put x an observational abstraction o store of trace semantics program stores at output program points only we use x to denote store restriction to variables in x out store out out x out if if s acts put x if l put x l ot out t similarly to sc here again we have a gc o store o this approach is clearly more general be cause the above store changes abstraction sc is more precise than o ie for any set of traces t or equivalently ot ot example dead store elimination the above approach based on a generic observational abstraction allows us to prove the correctness of program optimizations that are unsound in and palsberg s framework such as dead store elimination for example in a program fragment such as while x do z x x z one can extract the hot path hp x z x x z and perform dead store elimination by optimizing hp to hp x x x z as observed by and palsberg section this is clearly unsound in correctness because this hot path optimization does not output bisimilar code by contrast this optimization can be made sound in our framework by choosing an observational abstraction that records store changes at the beginning and at the exit of loops containing extracted hot paths correctness proof it turns out that observational correctness of the hot path extraction transform can be proved wrt the more precise observational abstraction sc theorem correctness of trace extraction for any p program hp t p we have that p in the rest of this section we outline a proof sketch of this result let us fix a hot path hp a c an cn t p and let php the proof relies on a mapping of traces of the program p into corresponding traces of php that the hot path hp or any its initial fragment according to the hot path extraction strategy given by definition we define two functions in fig the first function s on the trace s begins to unfold in php the hot path hp when i s c where c is the first command of hp and ii the condition guard ea is satisfied in the store if this unfolding for the trace s is actually started by applying s then it is carried on by applying ie with a the second function application carries on the unfolding of hp in php when i s ci where i n namely the command ci in hp is different from c and cn and ii the condition guard holds for the store if this is not the case then ci after a suitable unfolding step for ci jumps back to the by with it turns out that these two functions are well defined and does not alter store change sequences lemma and are welldefined ie for any for any sc proof sketch of theorem let us define as t technically the proof consists in showing the following two points a p t php this shows that for any execution trace of p is an execution trace of php this is not hard to prove b php p this is proved by the following statement t php p f php p the proof relies on the fact that one such trace is necessarily of the following shape c where s l guard ea l l ea l l l l guard ea lc l ea l l lc s и if s c store a if s c store a if s store a if s store a otherwise li guard i l i i ln guard n n l li li ci l i guard i i li li s и if s ci i n store ai if s cn store an if s ci i n store ai if s i n store ai if s i n store ai otherwise figure definition of and guard then it is not hard to prove that f php c p in words one such trace of php can be extended through an execution step in php to a trace in p we therefore obtain p p sc t php by lemma sc sc by point a by point b p and this the proof type specialization one key optimization for dynamic languages like javascript and php is type specialization that is using primitives in place of generic untyped operations whose runtime execution can be very costly as a example a generic addition operation could be defined on more than one type so that the execution environment must check the type of its operands and execute a different operation depending on these types this is the case of the addition operation in javascript see its semantics in the standard section and of the semantics of in our language as given in section of course type specialization avoids the overhead of dynamic type checking and dispatch of generic untyped operations when a type is associated to each variable before the execution of a command in some hot path this type environment can be used to replace generic operations with primitives type abstraction let us recall that the set of type names is types int string undef any type names can be therefore viewed as the following finite lattice types any int string undef the abstraction map type value types takes a set of values and returns the smallest type containing it since types viewed as a subset of value is closed under intersections where any is interpreted as the top element value and is the bottom element type can be indeed defined as a simple closure operator ie a monotonic increasing and idempotent function on value t types v t given a value v value type v thus coincides with here the concretization function type types value is simply the identity map with any value following the general approach described in section we consider a simple store abstraction for types var types where is the usual pointwise lifting of the ordering for types so that x and x any are respectively the bottom and top abstract stores in the abstraction and concretization maps store store and store store are defined as a straight instantiation of the definitions in section the abstract type semantics et exp types of expressions is defined as best correct approximation of the corresponding concrete semantics e on the type abstractions and types ie et e t type e e store t this definition leads to the following equalities et v t et x t tx et e e t et e t undef any if i et ei t else if et e t et e t int string else if i et ei t any otherwise for instance we have that et x y x string y et x y x string y string string et x y x int y string undef et x y x int y any any according to section for any abstract type store xi var we consider a corresponding boolean action guard guard x t и и и xn tn whose corresponding program action has the following semantics which is automatically induced as defined in section by the galois connection store store store for any store a guard x t и и и xn tn if i ti i ti type specialization of hot paths let us consider some hot path hp t c tn cn t p on the type abstraction where each ti is therefore a type map the trace extraction transform of p for hp gives rise to the set hp of commands that the hot path hp into p hence for any i n hp contains a typed guard that we simply denote as guard ti typed guards allow us to define type specialization of commands in the hot path this is defined as a program transform that most addition operations in place of generic untyped additions by exploiting the type in formation dynamically recorded by typed guards in hp note that if c hp and x e e then c i x e e l for some i n where l l i l let ct denote the set of commands that permits type specific additions int and string and in turn denote the possible type specialized programs over ct the function hp ct is defined as follows c if x e e i x e e l i x e int e l i x e string e l i x e e l if et e e ti int if et e e ti string otherwise hence hot path type specialization ts is defined by hp c hp the correctness of this program transform is quite straightforward let be the set of traces for type specialized programs in and let tt trace be defined as follows tt l x e e l tt if s l x e type e l s и tt otherwise theorem correctness of type specialization for any typed hp t p we have that hp t hp typed trace extraction consists in extracting and simultaneously type a typed hot path hp in a program p ie it can be defined as follows ht pp hp hp correctness of typed trace extraction t hp is a straight of theorems and corollary correctness of typed trace extraction for any typed hp t p we have that t hp p p example let us consider the following of in a language Г this is taken from the running example in Г where is initialized to an array of true values with a slight we assume that our language is extended with boolean values and arrays the semantics of arrays load and stores is as usual first the index expression is checked to be in bounds then the value is read or stored into the array if the index is out of bounds we assume the program is aborted for var i i i i do if then continue for var k i i k k k i do false this program is encoded in our language as follows p c l i l c l i l cc l l c l tt l cc l tt l c l k i i l c l k l cc l l c l ff l c l k k i l c l i i l c l skip let us consider the type environment t defined as t bool i int k int where bool is a shorthand for bool bool then the first traced hot path on the type abstraction is hp t c t c t c as a consequence the typed transform extraction of hp yields p t hp p p c cc l k l l l hp where hp h l guard bool i int k int hc l bool i int k int l h k l hc l h l guard bool i int k int hc l bool i int k int l h ff l h l guard bool i int k int hc l bool i int k int l h k k int i a general correctness criterion abstract interpretation allows us to view type specialization in section just as a particular correct hot path optimization that can be easily generalized guarded hot paths are a key feature of our tracing compilation model where guards are dynamically recorded by the hot path monitor and range over abstract values in some store abstraction an abstract guard for a command c in some hot path hp thus encodes a store property which is modeled in some abstract domain store and is guaranteed to hold at the entry of c this store information by abstract guards can then be used to transform and optimize hp ie all the commands in the hot path hp this provides a modular approach to proving the correctness of some hot path optimization o in fact since correctness has to be proved wrt some observational abstraction o of trace semantics and theorem ensures that this correctness holds for the store changes abstraction sc of the trace extraction transform we just need to prove the correctness of the optimization o on the whole hot path hp which thus includes the abstract guards of the hot path hp hence a program p a hot path optimization o is modeled as a program transform o hp hp t p program where program may permit new expressions andor actions like the case of addition operations in type specialization o is required to be correct according to the following definition definition correctness of hot path optimization o is correct if for any p program and for any hp t p ot hp ot hp as an example it would be quite simple to formalize the variable folding optimization of hot paths considered by and palsberg and to prove it correct in our framework wrt the store changes abstraction sc nested hot paths once a first hot path hp has been extracted by transforming p to p hp p it may well happen that a new hot path hp in p contains hp as a nested following trace recording strategy we attempt to nest an inner hot path inside the current trace during trace recording an inner hot path is called as a subroutine this executes a loop to a successful completion and then returns to the trace that may therefore register the inner hot path as part of a new hot path to this aim let us the definitions in section let p be the original program and p be some hot path transform of p so that p p contains all the commands guards included in the hot path we define a function that from a trace in p all the states whose commands appear in some previous hot path hp except the entry and exit states of hp if c c if c c c c c c p и и и otherwise in turn we define as follows n ai ci и и и aj cj i ci и и и j cj st i j store i ci и и и j cj ai ci и и и aj cj count store ai ci и и и aj cj n clearly when p p we have that so that finally we define the collecting version t t n example let us consider again example where store is the trivial store abstraction in example we first extracted hp c c cc by transforming p to p we then consider the following trace in t p x c x h x h x h x h x h x h и и и x h x h x hc x c x h и и и x hc x c x h и и и thus here we have that x c x h x hc x c x h x hc x c и и и so that hp h hc c t p hence hp contains a nested hot path which is called at the beginning of hp and whose entry and exit commands are respectively h and hc let hp a c an cn t p be a n hot path in p where for all i n ci li ai let us note that Г if for all i n ci p then hp actually is a hot path in p ie hp t p Г otherwise there exists some ck p if ci p and ci p then ci is the entry command of some inner hot path on the other hand if ci p and ci p then ci is the exit command of some inner hot path the transform of p for extracting hp is a generalization of definition definition nested trace extraction transform the nested trace extraction transform of p for the hot path hp is p c c p p l l c p l lc p l guard ea l ea l c p i li i n ci ci p n l cn p i i n ci p li guard i li li i n ci p i li i n ci p ci p ci i n ci p ci p li li i n ci p ci p while hp let us observe that Г clauses Г are the same clauses of definition with the additional constraints that ci and are all commands in p conditions which are trivially satisfied in definition Г clause where ci p and ci p namely is the call program point of a nested hot path and ci is the entry command of performs a that allows to correctly nest in hp Г clauses Г where ci p and ci p ie ci is the exit command of a nested hot path that returns to the program point performs the of in ci in order to return from to hp Г l i and li are fresh labels ie they have not been used in p example let us go on with example the second traced hot path in t p is hp h l guard e hc x l c l x x l according to definition trace extraction of hp in p yields the following transform hp p by clause by clause by clause p hc x h h guard e h e by clause x x l where we used additional fresh labels in h and l example let us consider again example after the trace extraction of hp that transforms p to p a second traced hot path is the following hp t c t c t c t h t hc t c where t bool i int k int hp contains a nested hot path which is called at succ l and whose entry and exit commands are respectively h and hc here typed trace extraction according to definition provides the following transform of p p t hp p p c cc l i l l l h l guard bool i int k int hc l bool i int k int l h i l hc l h l guard bool i int k int hc l bool i int k int l h tt l hc tt l h l guard bool i int k int hc l bool i int k int l h k i int i hc hc l h l guard bool i int k int hc l bool i int k int l h i i int finally a third traced hot path in p is the following hp t h t hc t c which contains a nested hot path which is called at the beginning of hp and whose entry and exit commands are respectively h and hc here typed trace extraction of hp yields p hp p p hc hc tt l l guard bool i int k int l bool i int k int l i i int we have thus obtained the same three trace extraction steps as described by et al section in particular in p we specialized the typed addition operation k k int i in p we specialized k i int i and i i int while in p we specialized once again i i int in a different hot path thus in p all the addition operations have been type specialized comparison with and framework a formal model for tracing jit compilation has been put forward in popl by and palsberg its main feature is the use of bisimulation to describe operational equivalence between source and optimized programs in this section we show how this model can be expressed within our framework language and semantics and palsberg employ a simple imperative language with while loops and a socalled construct e n x b x x cmd c skip x e if b then s while b do s b to s stm s c s the smallstep operational semantics b state О state where state store О stm is standard let us just recall the semantics of commands b to s k b k if b false b to s k b s if b true if state i i b i denotes the set of program traces for and language then given a program s stm the trace transition operator gp s is defined as usual gp sx s store ss s x s b s so that the trace semantics of s is s s language compilation programs in stm can be easily compiled into program by to an injective labeling function stm l that assigns different labels to different statements definition language compilation the compilation function c stm c is recursively defined by the following clauses c skip l cs skip k s skip k ck cs x e k s x e k ck cs if b then s k s b s k s гb k cs k ck b do s k b then s while b do s k cs b to s k s b s s гb k cs ck example consider the following program s stm in and syntax x while b do x x b to x x s is then compiled in our language by c in definition as follows cs x while while b while гb x while x b гb x x skip correctness for the above compilation function c means that for any s stm i cs program and ii program traces of s and cs have the same store sequences if st trace store returns the store sequence of a trace ie st and st s и st and for a set x of traces st x st x then correctness goes as follows theorem correctness of language compilation for any s stm cs program and st s st t cs bisimulation correctness of trace extraction in relies on the following notion of bisimulation which is parameterized by program stores definition a relation r store О stm О stm is a bisimulation when r s s implies if s b s then s b s for some s such that r s s r s s s is bisimilar to s for a given store denoted by s s if r s s for some bisimulation r it is simple to characterize this program equivalence through an abstraction map of traces that store changes this is analogous to the definition of sc in section store store if и if given store store is defined as follows theorem for any s s stm store we have that s s iff s s hot paths and trace extraction in and model i hot paths always begin with an entry conditional which is however not included in the hot path ii the store of a hot path is recorded at the end of the first loop iteration and is a concrete store and iii hot paths actually are hot paths according to our definition and hot loops can be modeled in our framework by relying on a loop selection map trace c О store defined as follows c и и и n cn и и и cj j i j n ci cj k i j ck ci notice that for simplicity the above definition includes the entry loop conditional in the hot path the map trace c О store then to sets of traces t t let us thus consider a hot path hp cc и и и cn t p for some p program where p may coincide with a compiled cs for some s stm and let us follow the same notation used in section and trace extraction scheme is defined as follows where the hot path hp cannot be re entered once execution leaves hp definition gp trace extraction transform the gp trace extraction transform of p for the hot path hp is gp hp p p c l i i i n n l i i n p clearly gp hp p remains a wellformed program the cor of this gp trace extraction transform which is stated and proved in lemma goes as follows theorem correctness of gp trace extraction for any p program hp c и и и cn t p we have that t gp hp p t p example let us consider the program p in example and the path hp x t p a corresponding hot path hp with the same sequence of commands has been selected in example and extracted in example here the gp trace extraction of hp provides the following program transform gp hp p p c l x x x гx l x l further work we have put forward a formal model of tracing compilation and correctness of hot path optimization based on program trace semantics and abstract interpretation we see a number of interesting for further work on this topic we aim at making use of this framework to study and relate the foundational differences between traditional static vs dynamic tracing compilation we then expect to formalize and prove the correctness of most optimizations employed by tracing compilers of practical dynamic languages like javascript php and python for example we plan to cast in our model the allocation removal optimization for python described in in order to formally prove its correctness finally we plan to adapt our framework in order to provide a model of compilation as used eg by the current jit compilation scheme in the javascript engine acknowledgments we are to the anonymous for their helpful comments the work of was partially supported by microsoft research software engineering tion and by the university of under the project references v e and s a transparent dynamic optimization system in proceedings of the acm sigplan conference on programming language design and implementation pldi pages Г new york ny usa acm r n de a and g abstract interpretation of trace semantics for concurrent calculi information processing letters Г m f m f w n and h a jit compiler for in proceedings of the acm international conference on object oriented programming systems languages and applications oopsla pages Г new york ny usa acm i von sc b and n generalized trace compilation using a parallel task in a dynamic binary translator in proceedings of the nd acm sigplan conference on programming language design and implementation pldi pages Г new york ny usa acm cf a m m s and a allocation removal by partial evaluation in a tracing jit in proceedings of the th acm sigplan workshop on partial evaluation and program manipulation pages Г acm cf a m and a tracing the metalevel tracing jit compiler in proceedings of the th workshop on the implementation compilation optimization of objectoriented languages and programming systems pages Г new york ny usa acm c and p lee program analysis in proceedings of the rd acm symposium on principles of programming languages popl pages Г new york ny usa acm p cousot constructive design of a hierarchy of semantics of a transition system by abstract interpretation extended abstract electronic notes in theoretical computer science Г proceedings of the th annual conference on mathematical foundations of semantics p cousot constructive design of a hierarchy of semantics of a transition system by abstract interpretation theoretical computer science Г p cousot and r cousot abstract interpretation a unified lattice model for static analysis of programs by construction or approximation of fixpoints in proceedings of the th acm symposium on principles of programming languages popl pages Г new york ny usa acm p cousot and r cousot systematic design of program analysis frameworks in proceedings of the th acm symposium on principles of programming languages popl pages Г new york ny usa acm p cousot and r cousot systematic design of program transformation frameworks by abstract interpretation in proceedings of the th acm symposium on principles of programming languages popl pages Г new york ny usa acm foundation october foundation may a b m d d mr b kaplan g hoare b j j ew smith r m m and m type specialization for dynamic languages in proceedings of the acm sigplan conference on programming language design and implementation pldi pages Г new york ny usa acm a cw and m an effective jit compiler for devices in proceedings of the nd international conference on virtual execution environments pages Г acm s and j palsberg the essence of compiling with traces in proceedings of the th acm symposium on principles of programming languages popl pages Г new york ny usa acm m and s refining static analyses by partitioning using control flow in proceedings of the th international static analysis symposium sas volume of lncs pages Г springer inc the virtual machine engineering december inc a new for v the december international language specification standard edition june f class invariants as abstract interpretation of trace semantics computer languages systems and structures Г r milner communication and concurrency prentice hall m the project x symbolic transfer approaches to certified compilation in proceedings of the st acm symposium on principles of programming languages popl new york ny usa acm x and l the trace partitioning abstract domain acm trans program lang syst da abstract interpretation of operational semantics lisp comput Г f and t class analyses as abstract interpretations of trace semantics acm trans program lang syst Г 
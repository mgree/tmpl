program transformations l computer science department university nc introduction this paper extends the predicate calculus formalization of the partial correctness properties of programs ki go to include the preservation of correctness under program transformations the general notion of program transformations which preserve properties is fundamental to the theory of programming and programming languages in the context of proofs of program correctness trans which preserve correctness can be used to improve less efficient but easier to prove programs the basic argument in the use of program transformations is assume that g is a program with attached assertions which has been proved correct with respect to some inputoutput relation now suppose that s is some part of g eg an expression assertion statement etc which is to be replaced by some other such part s to produce the program g the goal is to prove that g is also correct with respect to and therefore the replacement pre serves overall program correctness moreover if the replacement has only a local effect eg the body of a loop then the proof of should be restricted to that part of the program affected by the replacement section the current paradigm for proving program correctness an example in sec tion illustrates in a sequence of ments on a correct and simple but inefficient initial program in section the formalization of partial correctness properties of programs is as a semantic language definition using semantic method this tion is then used in section to describe the several of performing questions about in section the formalization of sections and are discussed and a tion is proposed finally section returns to a concrete example and suggests that the most effective use of is by identification of forms related work is mentioned in section review of program correctness the correctness current is paradigm for proving program a create assertions for the program assertions are created and attached to a pro gram to describe the state of computations of the program at the points of each program must have assertions at the and the exit of the program and within every loop of the pro gram assertions establish locality within the program in the form of pairs of immediately cent assertions and the paths between them the input and output assertions specify the purpose of the program and therefore are the of the program designer it has often been that assertions should be created during and should play an active role in the development of the program b construct verification which express verification conditions conditions are local correctness logical formulae definition let al be an assertion and c describe a path to another ing assertions condition for the assertion then the path is a without associated verification ie if al true its end the path described at its beginning by c is executed with then a will be true at for each programming language semantics must be expressed such that these verification formulae can be extracted from programs in the language and such that these formulae are sound ie if the formulae are valid then the computations of the program do behave as expressed by the verification conditions given the appropriate semantics of a language verification condition construction is a straightforward translation from programs in the language into logical formulae and can be ki go de c prove the verification conditions partial correctness of a program is the that whenever it is executed for data which satisfies its input assertion and terminates its output assertion is satisfied this can be proved by proving the validity of all verification tions of the program because then every tion which starts with the input assertion true will progress through only true assertions and in particular the output assertion will be true note that this imposes the requirement that each assertion must be strong enough to guarantee all further assertions for any computation through that assertion verification conditions can some times be mechanically proved but the computation al complexity of the task use of mechanical the this paradigm is referred to as the tive assertion method for proving program cor ki go there are other ways of proving correctness but this is the most common method in current use termination which combined with partial correctness yields total correctness is usually proved separately experience with the method on numerous examples has exposed its difficulties assertions are sometimes hard to find and are often surprisingly complex condition construction requires a precise and complete language definition and verification conditions are often structurally complex although not necessarily deep mathematical theorems may be used to factor a program proof into several steps and thus some of these simple initial programs usually have simple assertions which may be augmented as the program is improved the verification conditions for a simple program will be relatively simple in struc ture and therefore easier to construct and prove and each of a sequence of may affect only a few verification conditions the purpose of this paper is to suggest a variation of the above where steps a b c are applied to a simple program which is then improved by repeated cation of a fourth step d perform a tion to improve the program in order to describe the mechanism nf this step it will be necessary to modify steps b and c to save intermediate results during verification condition construction and proving this will also require of the whole process of language definition verification condition con and verification condition proving section will provide this and section will describe the mechanisms of step d however we will first look at an example to the concept of a an example using input output consider assertion assertion a program specified ain by gi that is the program is the first n elements of gi the most obvious satisfy these specifications required a vector and simple is to set each of v so that vi program to while assert ai where the language may be assumed algollike over integers with the required to hold immediately before test is performed the appropriate tion is for now to be assertion the loop loop ai that is the i and states not including easily seen loop that i and assertion describes every element of v has been set this can easily be proved the range up to but of program is to be cor gram nature if g has no side effects has been given in of g is note that the pro form and that the now suppose that we know that g is defined as il then hl else h with respect to this g the above program is cor but inefficient because the loop requires evaluation of the conditional expression every time the obvious improvement is to compute g before entering the loop and then to compute gi within the loop as additional improvements would be to use the fact that and perhaps to replace this subscript computation vii by gi in a variable say k we will now perform a sequence of shown in figure ia which these ments another and better sequence of is presented in figure ib and will be discussed in section we sequence be denoted require a notation of transformations for describing a replacement a will n t where part n is is some program part which is a syntactic unit eg ment etc assertion expression state is another part of the same syntactic type an integer to an explanation of the preservation of correctness when is replaced by part a sequence of transformations is then denoted by the part to be replaced then the arrow to and the replacing part the transformations are labelled an algorithm for reading the program resulting from a sequence of n transformations is read the text normally from left to right until either i an is reached if the arrow is labeled with an then follow the arrow down to the over score and recursively read the program text the otherwise ignore the arrow and continue reading nor left to right ii the end of a line of text is reached if the line of text is not then terminate otherwise return to the under score at the root of the arrow the move right to the end of the and continue reading from that point for example in figure ia transformation the list by the statement statement and in transformation this list replaces by after two the program reads replaces the these v while assert ai ain ln i while ai il then hl else assert ai v x it ai l r k i program after while in assert program after while in assert ai figure ia i k e rc y k final program while in assert figure ib i rc k i we will now present an intuitive tion for the preservation of correctness of each of these transformations and later in section we will see the formal mechanisms behind these affects the insertion of only the verification the statement condition which covers the initialization of the loop the state ment has no immediate effect with respect to the assertion ness ai and therefore preserves correct now the effect of the inserted state ment is used by increasing i at the start from to the assertion ai is still true because li includes only il and by the initialization the assertion for the loop does not yet show the effect of so a conjunct is added to the assertion the assertion is still true coming into and going around the loop now the fact that throughout the loop is used to simplify the computation of gi to the inductive assertion ai shows that so the computation of can be optimized to avoid in these last two steps we have simply replaced a subexpression by an equal subexpression where the equality follows from the assertion the entire effect of the changes so far is in the program below the transformation now we will proceed to introduce a variable which will save vii shown k the statement inserted before the assignment to v has no effect with respect to the assertion and therefore preserves cor there is no need to compute hl twice so that vl can be assigned k and since the program is still correct similarly to k is assigned and then vii can be assigned k now we have fixed the program so that both coming into and going around the loop and this can be proved and entered as part of the assertion finally the computation of can make use of the inductive property the final program mation is given below the this example illustrates the to use an easy and simple and then use to optimize way we want program ini the program the relationship between correctness and semantics we have seen that syntactic and semantic definitions of programming languages are required for the construction of verification conditions it has also been suggested fl that correct ness can and should be the basis for semantic definitions of languages the motivation is on the rather than the implementation characteristics of language features we will now relate the inductive tion formalism to the semantic method of knuth in order to the mechanism of cation condition construction which has previous ly been described only in terms of specific implementations ki go de semantic in terms of attributes method which defines a language are to be associated with the nodes of the syntax derivation trees of programs of the language the attributes are defined by semantic rules with the tic rules of the language a program in the lan guage is given a meaning by computing all the at in its derivation tree and identifying the attributes of the root as the meaning attributes have the characteristics that they may be ie defined in terms of the ancestors in the tree of the nodes with which they are or synthesized ie defined in terms of the descendants in the tree of their associated nodes it is always necessary to show that the attributes are welldefined ie that they can be computed and are not defined knuth gives examples of the definition of turing machine and lambda calculus languages kn the correctness formalism suggests two dis but logically related definitions of a language based on the two forms of verification conditions which have been described and imple ki go de the forward verification conditions work from a along a path to a while backward verification conditions work from back to the there are various implementation and intuitive reasons why a particular form is in a given implementation but it will be to use both forms when the mechanism of transformations is dis in the next section therefore we will now define the semantics of a simple language using both methods thus giving two definitions and then show that these definitions satisfy symmetry properties the semantic definition of the simple lan guage will actually be split into two parts verification conditions actually describe the flow of control along a path and the relationships between the assertions at the beginning and end of the path as a logical formula in terms of the assertions and the expressions of statements along the path the assertion and expression languages are usually separately defined by an axiomatic theory which defines the operators of these sub languages and in are to be proved which the verification as theorems the conditions existence of this axiomatic theory will be assumed figure ii definition of a statement lists gives the syntactic and semantic simple language with assignment and conditional statements and the forward attributes are named if rf and and the backward attributes are named lb rb and using the scheme condition refer to the in left and right the derivation tree and the basic idea behind the definition is that considering now only the forward attributes if and rf compute and store intermediate formulae of the verification condition construction and collects them up to identify the the verification tree to the the meaning conditions and passes root where they are used of the program roughly lf stands for the strongest condition which holds before a node in the tree given the preceding syntactic production synthesized attributes inherited attributes p ain l l s ll si lb p lb l p l rb l lf l ain rb s rb l if l rb l rb ll s ve if ll s while b assert l a s if b then ll else l where v denotes a variable which does not occur elsewhere in the program or tions la rb l a if l s lf s notation a assertion b boolean further defined here v denotes substitution expression e expression v variable are not of v for all free occurrences of v in e figure of a simple language assertions and rf is the strongest condition which therefore hold after the node in the sense of before and after execution of the program part derived from the node lf is an inherited where we use the term inherited to not outside just ancestors the subtree but from also any a node case where this is necessary is production where is computed from clearly we could also have passed up to ll and then down to but that would only attributes the backward attributes are symmetric to the forward attributes rb represents the formula which expresses the weakest condition which must hold after the execution of the program part derived from a node in order to guarantee the following assertions and lb represents the weak formula execution which of that must therefore program part hold before notice that attributes are not defined for the syntactic symbols a b e v but only for the symbols p l s we will assume that the derivation tree for a program in this language is not completely filled out with respect to the undefined symbols and that there is an implicit attribute for any undefined node which is simply the text of the expression as mentioned before that text comes into play when the verification conditions are proved as theorems in an axiomatic theory which defines expressions we now must show welldefined ie that for any derivation that the attributes are the attributes can be com tree to show this we will present algorithms for traversing the tree ie at least once each node labelled p s l and computing some of its attributes at each there is one algorithm for computing the forward attributes and a separate but sym metric attributes algorithm for computing the backward theorem for the language of figure i a the forward attributes are well defined b the backward defined attributes are well proof a the forward attributes are computed by the following general recursive algorithm for traversing the derivation tree for each labelled p l or s of a node in left to right order begin compute the inherited attributes of the using the attribute tion for the production associated with the node traverse the end compute the synthesized attributes for the node using the attribute definition for the production associated with the node more precisely for the given language starting at the root of the derivation traverse the tree where traverse depends the type of production associated with the tree on node cases of productions pa ain l compute lf l and p l s compute lf s and l l sl ­ traverse traverse l compute rf p s compute compute if s traverse s compute if l traverse s ve l compute and compute s while and b assert a l compute traverse l compute and f vc s s if b then l else l compute if l traverse traverse cl l compute compute rf s and inherited attributes are always computed before the node is traversed and therefore are available to it and its descendants synthesized are computed after the nodes descendants have been computed and therefore are available to its ancestors therefore when an attribute is computed has been those defined attributes in terms have already been of which computed it and this algorithm will permit all forward attributes to be defined in one pass through the derivation tree b the algorithm for computing backward is symmetric to the forward algorithm by substituting in the general right to left version and for rb left to right lb and for if rf and respectively in the specific version the derivation tree and attributes for the initial program in figure i are given in figure iii the nodes of the derivation tree in are labelled in two ways the integer refers to the order in which the nodes are traversed using the algorithm for computing the forward attributes and the letter refers to the syntactic symbol of the node only the nodes for which semantic rules are defined are labelled and the nodes from which ex are derived are in to denote that the derivation subtree is gives the attributes as computed by the for and backward traversal algorithms in the and attributes have been out using special rules for substitution when variables occur table has been con slightly in that expressions are written out only once and then denoted elsewhere e g where if lf ain the meaning of the attributes tree for this meanings of a program at the root language we is defined in of its derivation have two distinct terms rf forward backward meaning meaning fm expresses that the strongest condition after execution of the program implies the output tion and all bm expresses verification that the conditions are weakest condition valid before execution of the program is implied by the input assertion and all verification conditions are valid note that and are tions of verification conditions for loops in the program we will derivation if defines we will say that the program represented by the tree is correct with respect to ain is a theorem in the theory which the expression and assertion languages soon show that the above meaning formulae to any nodes n of the tree may be generalized rf n rb n n if if np if if np define the pair of formulae as the semantic which does hold of n the strongest condition before n and the weakest which must hold after n then the basic between the two meanings for this language is expressed by theorem symmetry theorem for any node n in the derivation tree proof a standard proof technique for theorems like this is structural induction b structures are assumed to have of various types and is a constituent of is a partial ordering to perform induction to prove property p for a structure assume that p holds for all prove case that p holds our structure of the structure for the structure is a derivation and in tree then this con are subtrees and the types of con are the productions associated with the subtrees thus to prove the above property i i w d i p p ii we will symbol grammar prove on the it for each left of the case where ith production n is the of the the proof which here to illustrate the of this formalism tion induction steps which manipulate logical all other steps follow attributes if rf fm bm is rather long is included types of proofs character and of structural are marked and steps operators are marked from the definitions of the lb rb and the mean p ain l l s similar to production i ll s l abc ll lo k s ve s v rb s s rb s proof due to ki p s while b assert a l lf s l a lf l l s if b then ll else l proof omitted thus the definitions are equivalent the preservation of correctness suppose that we have a program g with tree t and that the attributes for the cor of g have been computed and stored in the obvious way on t ie each node of t contains fields for all the attributes and the formula com as the value for that attribute has been stored in that field furthermore assume that the meaning of g ie the formula computed from the attributes at the root of t has been proved and therefore g is correct we now want to per form a series of in program g eg those discussed in section which will improve the program while preserving its correctness each replacement in text of g will require several actions a to obtain a new derivation tree we will assume that the replacement yields another syntactically correct program g and that t is the derivation tree for the program g furthermore assume that it is possible to match t and t to identify a node r of t such that t is similar to t outside of r ie replacing the sub tree from r in t by another tree rooted at r will yield t let us call this subtree of t which distinguishes t from t the syntactic range of the replacement b compute the attributes by the replacement the nature of the inductive assertion method is that assertions parts of the program and therefore should also be for the effects of for example assume that a replacement occurs within the body of a loop and that no change is made to the assertion for the loop then by the way attributes are defined all those attributes on nodes of the derivation tree outside the sub tree deriving the loop will be the same in t as in t in general we will want to know which attributes carry over from t to t in order to minimize the amount of computation involved in proving that the replacement preserves correctness by inspection of the algorithms for computing attributes we see that i all attributes com before the node r is reached are preserved from t to t ii all attributes of the subtree from r must be computed since this tree is new iii the v attributes way back up the tree must be computed and iv attributes all the other than vc must be computed unless there is an tion which the replacement from the point at which the attributes are attached we will return to the process of updating later but for now the important point is that some attribute of t are the same as for corresponding nodes in t while others must be newly computed or because of changes in the program c proving the verification conditions which cover the replacement the verification conditions arising from those parts of t where the are the same as t do not require this says that proving the correctness of g can be restricted to proving the tion range conditions of the which replacement arise from the this fact syntactic is justified by the following lemmas and theorem lemma let n be a node in a derivation and nl nn be descendants a tree t of n b proof by structural induction lemma special cases of let r be the root of the syntactic range of a replacement in a program g with tion tree t which yields a program g with derivation tree t case production ll sl la r is s in this production the back attribute values of l in t are the same as those of l in t lb r is l in this production the for attribute values of s in t are the same as those of s in t case production s while b assert a l r is l in this production the and case are the production same for s in t as for s in t s if b then ll else l ab r is ll in this production the attribute values of ll in t are the same as those of ll in t proof properties of the traversal algorithms theorem replacement theorem let g be a pro gram with derivation tree t where g is correct wrt let g be a program with tion tree t r be the root of the syntactic range of replacing a replacement r in t to in t r the give t perform subtree the for traversal if r lf r algorithm then the starting program at r with g is also cor wrt if rf r a theorem in the theory which defines expres sions alternatively we may perform the back algorithm starting with and prove proof lemmas and are used to show that the meaning of any sibling of r is still valid and therefore it is only necessary to prove the meaning of r in the semantic context of r theorem explains why we want both forward and backward attributes the semantic context of r in t is the same as the semantic context of r in t and therefore we can prove that g is cor with respect to if we know that g is correct with respect to and that r is correct with respect to the semantic context of r this is what we meant when we said that if a replacement should only have has a local effect t prove correctness then we tion for that local effect the semantic con text the effects of now we can the original discussion of to give the replacement procedure using the notation of theorem a find r the syntactic range of the re placement b compute the attributes of subtree at r using the semantic context of r c prove one of the meaning formulae for r d copy the attributes of t which do carry over from t and compute do not carry over from described as a modification the t attributes of t which this process can be of the traversal al after this procedure it will be known that g is correct with respect to and that t is the complete derivation tree with associated attributes for g there are several variations on this procedure if only the forward attributes or the backward attributes are computed then there is a similar replacement theorem which will require computation of more attributes rather than copy and attributes for t we can regard this as an updating of the attributes of t outside the syntactic range the requirement for updating the attributes is based on the assumption that there will be a series of transformations and therefore after each transformation t should be ready to go for the next transformation it is also possible to updating attributes until it is known that they are required by a further transformation notice also that after the proof of the verification conditions for the initial program it is no longer necessary to compute the vc attributes because the replacement theorem guarantees that they will be valid n l a same as in the above tree would result from the first two transformations of figure ia the syntactic range of the statement insertion is node un fortunately because of the production l sl the theorem as stated requires the ing of practically the entire tree which suggests that the replacement theorem should be broken into cases of various productions to minimize the tactic is range replaced for the second by it is transformation only necessary where to prove using the backward form il else which is equivalent transformation in to what we said section about this there is space to discuss any more transformations it should be noted that the process of calculating and updating attributes trees etc is too tedious to do by hand and should be mechanized for practical use we have presented a unification semantics and the inductive assertion for a specific programming language that this unification is more general of language formalism we claim and will this natural questions claim in response to several a can all languages be defined in both the forward and backward attribute forms the basic idea behind the forward attributes is that the algorithm for computing the attributes models the dynamic flow of control through a program as it traverses the static structure of the program sym the backward algorithm models the dynamic flow of control in reverse order the algorithms are particularly straightforward for our language because it is how ever the semantic method is as knuth says on page as general as any method could be in the sense that the value of any attribute of any node of a derivation tree may depend in any desired way on the entire tree this suggests that the dynamic order of statements from the static order attributes may be defined to carry information about the program structure to the point where it is dynamically re thus it seems reasonable to expect that any language would have both definitions however that is not to say that any forward and backward definitions would necessarily satisfy the symmetry property it could in which be that the definitions are inconsistent case the symmetry property serves as a check of the soundness of the definitions b even though two definitions are symmetric are they equivalent in other the question leads into the complexity of verification condition construction be and proving where one definition may for a particular language or theorem prover both forward de and backward ki conditions have been used as the basis for particular implementations it has been shown that some language features eg arrays are more easily handled or at least described in one method for example the existential quantifier in forward attributes for assignment statements is somewhat harder to understand than the simple sub which is used in the backward attributes thus the backward definition is more c are there variations on the inductive assertion method which can be expressed using the same general method as section this is a very important question because the inductive tion method as now formulated is quite we will now show that the requirements for assertions can be relaxed somewhat if additional attributes are added suppose that we want to permit of the input assertion to be carried along as long as nothing in the computations has those conjuncts for example suppose that the input assertion has a conjunct such as where n is constant throughout the program and this conjunct is required in several places in the program using the inductive assertion method n must be given as part of every assertion and must be proved just like any other conjunct a way of handling this situation is to define other attributes if and rf which contain all con of the input assertion which have not been by assignment to a free variable of the conjunct precisely lf and rf are tions define defined and rf the same as in figure ii with the production s ve conjunction of which as a free variable of all do not conjuncts contain v production s while b assert al the conjunction of all conjuncts of which have no free var l which are assigned to within also replace in by by and and there are two important definition results for this variant theorem derivation for tree any node n in a theorem let g be a program which wrt using this new definition is a program g which is correct wrt the old definition is correct then there using proof in g structural let a be an assertion while b assert al make a be induction on the in a statement of proof meanings follows by of nodes g this suggests a generalization of the forward and backward attributes used in figure ii where some basic changes are made in the inductive tion method in the above example we used new attributes and rf to carry forward all con of the input assertion which were not by an assignment to one of their variables we then stated a theorem that said that for any program correct in this new sense there was a pro gram correct in the old sense this suggests the general notion of a verification sys tem consisting of formulae lr a from one node etc which to the next serve to carry eg lf rf b formula transformers which compute an attribute at a node from another attribute at the node eg define transformers like as the relation between and in figure ii tion c collector which are conditions attributes propagated eg which produce up the tree as that is verification system refers to a general form of semantic definition which corresponds to some variation of the inductive assertion method these variations might be different ways of pre eg by absence of assignment or proof of equivalence formulae which have been previously computed eg conjuncts which arise from the input or intermediate conditional assertions expressions assignments the relation or loop or between two verification systems and vs can be expressed as if any program be transformed in vs correct in vs can into a program cor which verification the existence systems of a hierarchy of name cl insert ion c stat deletion c statement reduction c expression identity c statement c assertion strengthening c inductive variable insertion c loop text transformation l sl si i v ee ve a e vv e b i while while b assert al l while b assert al b assert premises lf s is not a while statement none ue none v not free in el b assert k not free in b l or b assert al while z b assert al b assert al figure transformations b assert there is not sufficient space in this paper to develop the notion of verification systems any further but its importance is that we now have a general description of verification condition con and proving which we can manipulate to describe and explore alternative ways of proving program correctness transformations in section we saw a series of which improved a simple easily proved program but did so in a rather ad hoc way we will now see er series of transformations related to the first series but where each transformation has been given a name and a general form the latter approach represents would most likely the way that transformations be used in general practice are ib text figure iv presents transformations used in the transformations each transformation is given in which in figure terms of part and premises for the correctness of the replace ment since the transformations are given as schema some parts of correctness preservation may be proved for these schema whereas other parts referred to as the premises must remain to be proved for the interpreted program since we do not want to talk directly about trees but rather about we will use abbreviations in the pre such as to mean the value of the lf attribute ap the node from which ve is derived the general idea behind this latter approach is that a transformation ia identified as being useful by occurrence in one or more example pro gram improvements then the transformation is described in form and whatever can be proved about the schema is proved leaving the re as the premises after which whenever this transformation is used only the premises need to be proved for the given interpretation and context consider what each transformation in figure iv expresses cl is the very common transformation where a simple statement is inserted this can be performed whenever s is not a while statement and whenever s satisfies the semantic context cs premise states because the strongest that condition s is not before guarantees the weakest condition after s c c and c are some special of assign ment statements which require very little to be proved before their use c is a special case of assertion manipulation where a conjunct a is added to an assertion a the premises show what is required to prove correctness preservation for a alone rather than for the entire assertion c and c describe transformations on whole loops in c a variable is included in the loop to save the value of an expression e and the only requirement for this transformation is that k not be in use within that part program c loop is a major loop operation which requires only that the loop be executed at least once it should be that this list of transformation the example schema was composed which we are discussing especially however transformations are obviously of general useful ness and it is reasonable to expect that more for the examples would expose more transformations as well as reuse these indeed this is the case and has been shown by a study of examples programs ge where other transformations were found this a general methodology for using where a of useful transformations is collected and used to guide program improvements and it should also be noted that some transformations may be similar to the tion used in compilers but the motivation behind these transformations is rather than equivalence as in compilers that is our transformations may take advantage of assertions and correctness attribute values which compilers usually dont have available returning in the and justify the now to the example we transformations use will of these briefly used in figure ib n by the input assertion guarantees that the loop will be executed at least once and therefore it can be steps work on the part the assignment makes part of the strongest condition before and therefore the expression can be simplified cb permits of these two statements now the fact that before the assign ment can be used to reduce the expression to using can be deleted either c or c we see that we will manipulating g and instead introduce the variable k using c so the holds before assignments the assignment to k are to avoid a second subscript calculation finally g is reduced to hl now we get around to using before the loop because we will finally be manipulating g within the loop actually this step could have been done more easily before step the statements to get the assignment to k at the beginning of the loop now the gi computation is using the assertion s and the assertion there are several points to notice about this second series of transformations while there are steps here and steps in the former series there is actually much less proving cause several of the transformations have no or only simple premises the way in which the are applied has the of a of programs ie a body of rules for programs which suggests that with a large enough calculus the of making program improvements by could become fairly routine the claim that these of the program will is really improve based the an tive for efficiency rather than on the overall method of as discussed in this section illustrates been referred to as what optimizing has of programs kn in contrast to the previous views of optimization as occurring during translation from source to object languages related work milner mi presents an algebraic formula tion of the notion of two programs being tions of the same algorithm and shows how the cor of one program can be established by proving that it simulates a correct program hoare h discusses transformations from abstract to concrete data representations in the context of some specific language features both of these papers address the problem of global changes in data representation whereas the method of the present paper is better suited to local changes in control and expression structures in practice both approaches will be necessary and can be com a system which makes many useful tions to programs eg recursion to iteration has been built by and burstall db in contrast with the builtin knowledge of that system the present paper the evolution of a data base of transformations where some properties of the schema are proved and other properties remain to be proved when the schema are interpreted the automatic programming project we the importance of transformations such as those discussed here but there is no published information on the cur status of that part of the project knuth kn has discussed the role of of programs particularly with respect to optimizing with the goto statement the usage of in this paper is related structured but not programming identical to we would the methods always work of with concrete programs although these programs could be obtained by a process of refinement and tion a basic assumption is that often very simple programs can be constructed to satisfy given specifications and that optimization can be until these simple programs have been constructed and proved conclusions and extensions the relation between correctness and the syntax and semantics of programming lan guages has been through the mechanisms of semantic method this has made it pos to extend the paradigm for proving program correctness to include proving that transformations preserve correctness it remains to define other language features in this way and to study the properties of these definitions the natural ex of the semantic method into verification systems some insight into different ways of proving program correctness the hierarchy of verification systems remains to be explored finally the approach of proving and then improving programs has been applied to only a few examples ge kn and needs to be further to determine the extent to which it may reduce the difficulty and complexity of program proving a methodology from this approach is that bodies of programming knowledge can be expressed and organized as theorems and for program schema as in the example and section this organization of knowledge could have many uses program correctness proofs need not start from some useful features of higher level languages might be suggested by used schema optimizing language might be able to transformations supported by assertions automatic programming systems could base their code generation on the transformation approach the role of optimization and abstraction in programming may be and programming may be in a more systematic mathematical style references bu burstall r m proving grams by structural induction properties computer of db j and r m burstall a sys tem which automatically improves programs proc rd intl conf on artificial i de phd l p thesis an interactive program univ of california di dijkstra e w a for language may simple axiomatic constructs basis fl r w assigning grams proc symp meanings to pro math math ge a model and cal report s l knowledge about case study u programs go good for proving university d i toward a system program correctness of texas june hoare to computer october c a r an programming axiomatic comm approach acm h hoare c a data representations r proof acts of correctness informatica of ki j c a program verifier thesis university phd knuth languages d e math semantics systems of contextfree theory kn tics knuth d lecture e e examples of formal notes in mathematics ed springerverlag ­ kn knuth d e with goto statements report structured programming stanford university may mi milner r an algebraic simulation between programs university february definition cs of we extensible b multiple evaluators programming system in an 
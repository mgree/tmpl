a cal approach to language t programming research oxford university group abstract a framework for surface properties of programming language constructs composed of proof rules to those of and supporting is constructed using the cal semantics of scott and the following approach to language design is then considered the constructs of a language should have surface properties which few hypotheses other than assumed surface properties and have proofs consisting as far as possible of trivial fixpoint and structural tions o introduction the mathematical semantics of scott and is capable of defining realistic programming languages fully in a concise flexible and rigorous fashion it is therefore no that properties of programming language constructs ex in notations similar to that of hoare can be validated as theorems with respect to a language description written in mathematical semantics such verification further ensures a consist of those properties which might be difficult to obtain were a more intuitive approach taken towards their x this research was supported trust formulation by the oxford section of this paper presents a frame work for the validation of surface proper which essentially consist of proof rules and hypotheses in mathematical semantics in section the techniques of sec tion are used to form the mathematical of an experiment in language design in the that correct and surface properties provide a subject of interest to both semantic and the rest of the computing community we consider the consequences of having a criterion as an goal of our design efforts speaking we require the constructs of a language to surface properties with few hypotheses that are not surface properties and easy if not short formal proofs of the criterion will be seen to imply greater semantic clarity in a language that is not only will both the semantic description and surface properties of each construct be less com but a construct will also have fewer surface properties whose respective sets of hypotheses are mutually exclusive we shall discuss general of design from our ap as well as the effect of our on the design of a number of constructs a framework for surface property formulation and validation after defining the notion of surface property we discuss se descriptions which aid our efforts we then introduce a function which evaluates predicates on program variables in terms of semantic functions from the tion of the programming language under consideration finally we give an exam ple of surface property formulation using mathematical semantics surface properties lie begin with an arbitrary program ming language p a surface property of construct r of p consists of a triple pq z hn where a pq is an ordered pair of elements of some syntactic predicate domain pred members of which correspond to productions of a grammar such as pred expr pred here expr is the syntactic category of expressions pred depends in p the formulation on the nature of p of as will that of many other syntactic and semantic domains we shall refer to such domains as h hn is an fall into of cat a assertions about the syntax and execution of r b statements about the ence of values c other surface properties satisfaction of the validation ion of section will imply that face properties contain few hypotheses of types a and b which will called qualifiers the intention of the above definition be can be made clear hoare by using the notation of if hi through hn hold then syntactic substitution of for in pred can be defined in practice expr is either an identifier a possibly com selection on an identifier of structured type or an array or vector application we call such expressions we define two to be related if are identical one is a selection on an re other or one is an array or vector application of an array or vec tor related to the other we shall use this last notion in and we require an explicit predicate syntax in order to be to carry out structural on pred when s our restriction of possible on values to such a syntax does not a loss of however since any useful predicate of this type can be constructed from a fairly small set of generators involving scope and instances of structured types will be discussed in and respectively semantic the flexibility of the definition techniques of scott and implies that our surface property might be based on any one of a number of equivalent in a sense to be discussed below semantic descriptions of p we restrict ourselves to semantic descriptions a semantic description of p ep has the following characteristics abstraction environment denotations pairs of are the the denotations of label identifiers and special jump identifies see are pairs where the second component contains if necessary information about how the of the ab store is by the jump involved the a includes like those of abstract stores s environments env and expressed e as see the of domains associated with various semantic functions are defined accordingly each semantic domain b contains an error element b condition acts as an aid to proofs of the surface properties of abstraction calls by formulation of context conditions eg testing whether an identifier is a free variable of an ab it also makes possible direct proofs by and structural both of necessary theorems and of propositions involving wide classes of constructs of p by a theorem see we mean a result the decomposition of an expression written in continuation semantics into a form allowing specification of that form usually containing functional example composition if of some sort for is a con and y has functionality cc then we might wish to consider the tions under which where o and ct are elements of s condition helps discussions of the surface properties of jumps while implies that elements of domains which are important to our validation efforts may be used as intermediate an finally permits greater in the specification of error con the results of reynolds and provide means for discussing the equivalence of different mathematical se descriptions of a language in the following sense if be the elements of respective semantic domains are defined the existence of a general class of such is proven in the above references then two descriptions are regarded as equivalent if whenever they are used for correspond ing evaluations they give corresponding answers consequently we can show that our on having semantic descriptions does not imply a loss of generality we that ep is meant to be used for the discussion of implementation independent properties of p our stores and environments are abstract and the primitive operations on these semantic entities indicate implementations the features therefore common to when an ele ment of l the domain of abstract tions is mentioned in ep one is con a mathematical value which might be as a bit word or group of words were p to be implemented discusses the correctness of tion techniques by showing whether or not they satisfy the conditions put on them by semantic descriptions with pred and p defined semantics may be given to elements of the former using pred env s t where that the function space being specified need not consist continuous functions as mentioned in env and s are the of environments and stores respectively their defining equations are given in ep defining equations and an of their variety may be found in t is a semantic domain of truth values is defined in of the semantic functions of ep and equal ity relations between elements of seman tic domains the surface properties defined in can now be formulated as follows if hl through kn hold then pp true implies true in l p and cj depend on r p and a and are calculated using the equations of ep for example in algol p p for all r except declarations and jumps for a declaration of an identifier p would equal where is an element of d the of see and for a jump goto l pi would be the environment the denotation of l in p component of the flexibility of mathematical se defined implies that could well be with other have simply a definition which in the minimum which must be ex of this function existence and dependence on pred env and s an in algol assignment ie now consider the formulation of a surface property for an algol assign ment statement x e where z is not a function identified the most way to proceed is to tile predicates p and q of and then find those ki which make the validation of pq x e k hn in general such searches for suitable hypotheses often suggest more sensible pq pairs for the construct under consideration accordingly we let p be see and q be s where s is any member of an appropriate pred syntax for algol this choice gives us a surface property analogous to the assignment proof ne wish to show rule of for all p and o sp true implies where cx cj in commands c is the semantic giving meaning with functionality function to algol of cmd env c s a where c s a is the of command continuations may be derived straightforwardly from the semantic description of the language given in sufficient to ensure the validity of are below with each ki being followed by its formulation in mathematical semantics kl the evaluation of x e terminates without error cx is not la see or a kj the evaluation effects of e has no side o h where ti is the semantic function of giving meaning to algol expressions which can appear on the righthand side of an assignment statement is an appropriate type argument x does not with any other a in s that is the abstract location which x denotes is not the of a or any related to a like safe and below may be defined in much the same fashion as we emphasize that lie are defining sharing as a property of algol not of an implementation of algol h x neither variable in s shares with or is a free of an abstraction applied true the change change that which is evaluated in the value of x does not of a callbyname param does not share with x but in s true lz or h fails to hold we say that x occurs implicitly in s such problems of implicit occurrence the of syntactic sub in predicates to illustrate h we give a situation in which our other hypotheses are assumed to hold and is not valid a s is y b e is c is an abstraction which takes an integer parameter n and has the fol body begin end xn d the with respect of z is not to p and a as for h let a b and d hold as above and let y be an identifier which is a formal name parameter of an abstraction g in whose body assignment statement under consideration is assumed to occur finally assume that the con text in which x is being evaluated is a call of g with an actual parameter if x then else corresponding to y given hl through hs and the basic theorems for the proof of from structural follows on pred and the syntactic category of algol expressions although a completely formal proof is extensive it of a length proportional the syntactic categories is both easy and to the size of involved language design we now consider the design of gramming languages with satisfaction the following validation criterion goal proof as our the constructs of a language should have surface properties which have both few and proofs in mathematical semantics which mainly consist of straightforward fixpoint and structural the author has designed a series of block structured program ing languages on this basis and in the rest of the paper the most important features of these languages will be dis although few of these features are new our reason for including them may cause them to be seen in a fresh light examples will be drawn from one of the languages in the series our treatment will be informal because the principles of language design involved not any par language are the center of our attention an important consequence of our de sign approach has been the formulation and of the that pro gramming languages should be designed in a global manner rather than construct hy construct because the surface proper of constructs are inter dependent for example the assignment statement discussed in has surface properties which depend on the design of the following language features a expressions presence of side effects b sharing c of free vari ables and choice of parameter trans mechanisms we have found few constructs which satisfy the validation criterion in isolation conversely many constructs not mentioned in this paper might be integrated into some programming language without our standard at best only one qualifier that assuming termination and will need to be used in the formulation of surface properties the use of this hy one large notational benefit since is assumed we can ignore typechecking when proving surface properties thus some of the most parts of our semantic descriptions like that in may be discarded another aspect of our approach to language design is that the constructs of a language which satisfies our criterion will have surface properties with proofs whose lengths are proportional to the num of clauses in the syntax of that lan guage it is that a better rela can be achieved remarks about syntax and semantics and name and sharing will be found in a second subsection dis the design of specific language constructs although the constructs in are by no means to form a complete or optimal set and can in several cases be designed in a number of adequate ways one of which is chosen for it is that their description illustrate the major consequences mathematical approach to language will of our design syntax and semantics a fundamental principle which has from our approach is that language features with different surface properties should have distinct the alter to this policy are to formulate several sets of surface properties for the same syntactic con struct each having qualifiers which describe the semantic case under con or to use surface properties made more general when possible by the tion of both additional surface property hypotheses and pq predicate pairs with complex internal struc this generalization makes more difficult and surface properties less clear the syntactic above also the con in which various language features can occur for example expressions with side effects can be syntactically re to a small subset of the con of a language the effect of such limitations of context is to make our validation task easier without forcing us to reject language features which if used carefully are compatible with the validation criterion in our view syntax should play an active role in to provide semantic clarity for a programming language the process of language design thus becomes more continuous into and cannot be and semantics stages indeed semantic we agree with the of that the consideration of domains should be among the first the design of a language and a second point derived from this mathematical attempt at language design is that should be eliminated for example the function result mechanisms in algol pascal and fortran involve assigning to an identifier which in other contexts is of an type be cause this does not happen with any other types of assignment apart from name the use of such devices runs counter to the spirit of the of this result accordingly simplifies the semantic description of both assignment and ab thereby our validation task for those constructs ie discuss a replacement result in if this is not eliminated the only alternative to accepting more complicated validation proofs is to include extra qualifiers the example of strictly speaking should have had our assumption about x not being a function identifier as a hypothesis along much the same lines the only name allowed are dynamic these arise from two sources local variables and formal parameters of recursive abstractions and free of fixed abstractions see we can assume the existence of a pre processing operation that removes textual name from a programming language without this then at surface property with respect to the language sharing sharing greatly com any attempt to prove the surface properties of a construct since changes to the value of an might well alter the values of that occur explicitly or implicitly in the predicates under con for this reason others may be found in the type pointer is in our languages this exclusion however is not in itself enough to remove sharing qualifiers to h of from surface properties in the absence of pointer variables languages with capabilities similar to those of which does not have facilities for parallel processing can contain three main sources of sharing between features similar to the equivalence statement in fortran assignment involving instances of structured types and parameter transmission the first two of these sources must be eliminated if the validation criterion is to be met has no equivalence statements and uses copy rules the third cause however need only be re sharing can result from parameter transmission because a corresponding actual and formal might share with respect to the environment used in the evaluation of the body of the abstraction being applied or b distinct formal parameters might share because their corresponding actual parameters share if the of s are followed and if i we rules like the tion proof rule of sharing of type a neither extra nor complex syntactic operations on predicates we limit sharing of type b to that between formal parameters passed by mechanisms which do not allow those parameters to have their values in see is such a parameter mechanism perhaps the occurrence of other type b sharing indicates that an abstraction has has been either or de signed since surface properties of its body cannot be extended to those of its call without the inclusion of sharing qualifiers a variant of has the restrictions on sharing with one exception of structured type are allowed to share as a result of assignment instances of structured types if we limit the contexts in which such as can occur sharing qualifiers need not be included in the surface properties of most constructs this is another benefit of following the of although it meets the validation criterion less fully than is useful as a tool for the analysis of the surface proper of in sharing situations the of several constructs expressions has two syntactic categories and exp for expressions with and without side effects respectively it can be shown that exp satisfies this that is if the evaluation an element of ezp terminates without error an equation similar to that for hypothesis h of is valid the proof of this proposition follows from the con theorems of and a structural induction on ezp in which the abstraction application case is proven using both fixpoint and struc though the formal for a syntactic proof al category as large as exp is straightforward given this result much of our validation task may be done implicitly by requiring exp in our syntax additionally only exp in syntax of this decision on the we use the variable discussed qualifier k of in will be the distinction implies that expressions with possible side effects can be used without our validation efforts provided the contexts in which such expressions can occur are limited so that the surface properties of most constructs will need neither qualifiers similar to h cf nor which like of assignment account for side effects the surface properties are carefully of members validated of side effects can arise in the evaluation of an element fe of only if fe contains the call of an abstraction of type function this specification the of the second con above assignment in assignment statements con the symbol are limited to the form exp where is an identifier of basic type integer real or boolean a surface property of this construct is i ht where is exp that the evaluation of terminate without error follows from and expresses a is assumed to the proof of i the theorems of the result concerning exp in a short lemma about the effect of simple assignment on the abstract store and a trivial structural induction on pred for the justification of the elimination of qualifiers h to k of see an d the symbol is used to signal the presence of a production of syntax on the righthand side of an assignment statement with the lefthand side as above eg if a surface property of is s then one can validate where t is and here r and w are the semantic functions of which give semantics to ex of type in exp and respectively finally the polymorphic abstraction change is used to perform assignments in of structured type the contexts in which change can be ap are specified in composition a surface property in is see for composition iii pr where s pq s qr r rz and and ia asserts that a does not con a jump to a point external to it self this qualifier may be expressed using a purely syntactic predicate or environment and abstract store arguments may be added to ensure that a forbidden jump occurring in a dy unused arm of a conditional does not affect the result of the jump free test the validation of iii fol immediately from an appropriate con theorem and the property that r cannot contain a jump into rl in our language aims to keep sensible jumps while having hold for as many con a as possible in an attempt to satisfy this goal only are allowed in the language conditionals and iterations if only ezp syntax is allowed in boolean contexts the surface properties of conditionals and iterations like le are easily and validated relative to the face properties of their component com these usually require fixpoint induction and no structural in with hi and sometimes h as j qualifiers the validation criterion for is best satisfied if the syntax of is kept and if the maximum number of iterations is before the first evaluation of the abstractions and parameters the design of abstractions has a per effect on our validation efforts in line with has three abstraction types fixed functions abstractions with fixed free variables s these are the only ab whose applications can occur in exp or pred syntax thus their calls have no side effects functions tions whose applications occur in syntax routines abstractions whose calls produce side effects without returning of result type the of routines are in command syntax we first continue effects of free discuss parameter mechanisms and with considerations of global of abstraction calls and treatment variables parameter mechanisms the example of demonstrates how the use of callbyname as a parameter mechanism can additional in the surface properties of lan guage constructs two types of parameter transmission reference and formal parameters may not occur in a context which might cause their values to be this method of passing parameters is similar to a device proposed by but here we do not allow actual reference and parameters to share as should be expected abstractions of type fixed function may only take parameters by expressed value the use of these mechanisms combined with our re on sharing between actual implies that parameter passing need not affect the abstract store and thus can have a purely ef this in turn allows for example the validation of a surface property to the proof rule iv p pr where occur all free in i or be abstraction of p and r must identifiers p ­ sub ­ r ­ sub ­ and is an identifier of type routine or function with formal parameters through and body i by a proof similar in size and nature to the proof of the substitution lemma given in iv is similar to the substitution rule of hoare its validity depends also on the of and global ef of abstraction calls the free variables of an abstraction f and any abstraction applied within f are like parameters in that their values may not be le by any call of f this convention the specification of those pro gram variables whose values can be by an abstraction call and makes a free vari able of an abstraction and an actual reference parameter of an enclosing abstraction call either illegal or treatment of free variables the of on the use of free variables does not solve the problem which itself in the form of qualifiers like h of lie remove the need for such qualifiers while free variables by using only fixed abstractions in pred as defined by syntax a fixed abstraction takes its free variables of type by when it is declared and has abstractions as free variables only if they are fixed we do not require abstractions of types function and routine to be fixed because the use of fixed free variables causes dynamic name which the of surface properties like that corresponding to iv of calls of abstractions of type fixed function however have no side effects therefore the surface properties of such abstractions are trivial and our causes no practical validation jump s although full jumps and labels may be described and characterized in cal semantics we use no labels and restrict jumps to lies jumps which in effect complete the evaluations of specific constructs examples of and their associated constructs are see return call of an abstraction of type routine exp call of an abstraction of type fixed function or function switch break while or return and the become special jump identifiers and have tions in the environment p the use of only combined with rules which the below of special jump identifiers implies that the test of is by most associated in neither i nor rz can con a jump into the other the specification of the surface properties of and general jumps for that matter is aided by the use of the concept of scope by the scope of an identifier we mean that area of a program text in which the identifier can occur this definition of scope which is a purely textual property is valid be cause of our of name is in scope if its denotation in the environment under consideration is not an error element a surface property of say break is v where consists of those parts of p which can be evaluated without error with respect to the of the denotation of break the qualifier in v is needed solely to the proof of v is immediate a if the area of the abstract store is not affected by jumps if this is not the case ie need to show by structural induction that if an identifier is in scope its can always be taken without accessing any abstract locations which are not in the area of the store under consideration the proofs of the surface properties of abstraction bodies are aided if we validate a wide range of surface proper most of return and of these properties are exp variants though of v care must be taken over dynamic name which do not affect the of surface properties of break structured types structured types be introduced into a language without the validation criterion if the contexts in which instances of such types might have their values can be limited syn there are a number of treat ments of structured types which satisfy this condition for an example see simply uses one such method that allows the declaration of recursive union types like tree and list the polymorphic abstraction change serves as an assignment operator for structured types and can only be applied within the bodies of tions abstractions which can have ref parameters of structured type pd syntax can be expanded to in elements like ezp which acts on an object of structured type and thereby the formulation and validation of surface properties of as well as the characterization of the shape of a struc type side is an related to an identifier of structured type depth determines the maximum length of the composite selectors which may be applied to a graphical representation of the value of side con a loop is a suitable constant cycle the shape of a type is defined to be whatever propositions involving depth and similar are to be taken as invariant over all instances of that structured type for example one part of the shape of the structured type would be true for all side with respect of type to p the between the tions of section calls attention both to the of language tures and to the complications which can from the attempt to discuss the surface properties of a large programming language while we consider the first of these inherent to programming languages our efforts to design languages which meet the validation criterion are made in the hope of reducing the latter qualifiers indicate the presence of semantic that a programmer must take into consideration when he the impact of a construct in his program in the absence of qualifiers satisfaction of the validation criterion often implies simpler and therefore more useful face properties the mathematical approach to language design presented in this paper be more fully discussed in the dissertation which will also include an introduction of the approach to system programming languages future experiments in language design should be aided by the of which is to allow both semantic descriptions to be and imple to be given to theoretical lan guages perhaps a mathematical approach to language design when combined with the ideas of practical programmers will yield more coherent design principles in future than are available at present acknowledgements the author robert and who have provided many discussions additionally pd md and have read the and have made several suggestions for improvement references car hoare an axiomatic basis for computer programming car hoare procedures and an axiomatic ap sym on semantics of a languages s verlag car on programming language design stanford ai aim the evaluation expressions computer journal of gt university oxford in preparation and approach to the theory of computation re the formal semantics of computer languages and their imple cambridge and technical oxford university computing laboratory programming research group implementation and tions of logic for computable functions notices types are not acm symposium on principles of pro gramming languages boston pd the mathematical seman tics of technical programming research group pd and thesis oxford university semantics jc reynolds on the relation between direct and continuation semantics proc second colloquium on automata languages and programming m the reference technical cambridge u mathematical laboratory outline of a mathematical theory of computation proc fourth annual princeton conference on mation sciences and systems pp and technical programming research group continuous lattices proc conference springer lecture series and technical program ming research group mathematical concepts in programming language semantics conference proceedings vo and a mathematical for computer languages on computers and automata institute of and technical group c towards a formal seman tics formal language description languages for computer programming cd t c programming fundamental languages concepts unpublished in c of program ming language proc international computing symposium foundation and technical oxford university computing laboratory programming research group c and c a mathematical semantics for full jumps and labels technical oxford university laboratory programming research group rd a contribution of to the languages technical report ment of computing and information science university the semantics of the acalculus thesis oxford university and 
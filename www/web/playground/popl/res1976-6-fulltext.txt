binding time optimization in programming languages some toward the design of an ideal language d jones s muchnick department of computer science the university of abstract a new approach to the design of a programming language and its processor is proposed and some of the techniques necessary to realize the design are investigated the language would have a precisely specified syntax and semantics with both designed to provide the programmer maximal expressive power and to be as easily understood as possible the semantics would be based on extremely late binding times which provide great power to the programmer and are consistent with ease of understanding of the execution process it would be the of the processor to implement each program in the most efficient manner consistent with its being correctly executed implications of this design and some of the techniques to be used are discussed in greater detail focusing particularly on data types and storage allocation i introduction overview in this paper we propose a new approach to the design o a programming language and its processor and investigate some of the techniques by the design in the past when a programming language has been designed an implicit set of binding time assumptions has been a fixed part of its semantics for example fortran has static storage binding the design of algol implies allocation except for own variables pascal uses static and heap storage algol and use all three of these schemes with explicit allocation and deallocation and lisp snobol and apl provide implicit heap allocation a similar range of fixed binding strategies is provided for data types name binding program text binding and parameter access methods in these and other languages in only a few cases does any current language allow more than one or two approaches for any of them and in each case where a choice is allowed it is always an explicit choice made by the programmer rather than by the processor the choice of binding time discipline has major consequences for both the runtime efficiency of programs and the convenience of the language in expressing algorithms thus fortran with its extremely early binding times user convenience to runtime efficiency while snobol at the other end of the binding is known for its ease of programming complex tasks but certainly not for its execution speed the usual approach to implementing a language is to a method of executing statements which is sufficiently general to allow for bindings this is a preliminary report of work in progress occurring as late as they are allowed to by the semantics of the language thus the runtime support package for a program is likely to contain code for heap storage management and a snobol processor is likely to maintain a runtime symbol table for each program it executes to allow for symbolic indirect addressing regardless of whether these features are used in a particular program or not another consequence of the current design is that if a user eventually running the program he is designing on a production basis he is to code from the beginning in a language chosen for its runtime efficiency rather than its ease of use the alternate approach of designing and debugging in a more convenient language and later translating to a more efficient one is highly because it forces the programmer to be fully in a variety of languages with extremely syntax and semantics and to be able to translate among them this probably accounts in part for the use of fortran and cobol in of the now existence of much more powerful and convenient languages our approach to solving these problems is as follows i we propose that a single powerful and convenient language be designed which allows for extremely late binding times this language should have simple precisely defined syntax and semantics which are free of ad hoc restrictions imposed in the name of implementation efficiency such as declarations data types fixed dimensions or even numbers of dimensions explicit storage management etc it should provide for the possible understanding of the semantics of programs written in it in contrast powerful languages as dijkstra in suggests a similar approach based on defining an abstract machine to model the execution process of a language by all efficiency requirements and the machine to the language we can obtain a much simpler organization so simple in fact that it can very well be used as a means of language definition we also propose that a new type of processor be designed for this language the processor would have as its major new functions i the task of determining the attributes of each variable such as data types name binding storage requirements and so on and the implementation of each program in the most efficient manner ie binding times consistent with its being correctly executed the implementations resulting will range from complete interpretation to the production of highly efficient compiled code depending upon the usage of language features in each program as dijkstra suggests in i assume that the structure of many a machine is such that it is desirable that the translator analyses this program and tries to detect all kinds of special cases of our general concepts for example whether an array has a regular form etc whether an array is perhaps whether a variable is always simple and never defined in the form of a procedure whether a procedure is used recursively or not etc in short the translator will search for unused generality with the aim of something these analyses are no play and furthermore as the analysis is carried out statically the translator must always remain on the safe side in addition the processor may of course do more traditional optimizations such as code movement strength reduction and so on as described for example in i and but we can of good use of computer when the translator a considerable amount of time and in trying to come to that the programmer could have it as well thus the processor will also accept declarations which specify in advance the attributes of any or all variables but they will not be required this would simplify the task of attribute determination the capability of error detection for attribute and aid the generation of efficient machine code the resulting processor will be capable of producing highly efficient object programs when applied to source programs and yet will be capable of executing arbitrary programs in a powerful and very highlevel language it will as a result of preliminary program analysis decide which additional modules are needed to complete processing and to execute the resulting object program the runtime support actually necessary for any particular program might range from only inputoutput routines at one extreme to the complete processor at the other for the situation in which the program creates and executes new program text at runtime such a system will provide a new form of program development by refinement the user could develop and his program using the full power of the highly general processor which could easily produce and then once his program is running correctly he could the processor concerning his usage of features which late bindings and systematically modify his program to eliminate them the advantages of such an approach are described in and should be even more evident in the case where the source language is fixed rather than from setl to to as does in it is our that the development of such a language and processor is one small step along the path to constructing an programming assistant as proposed by in in a recent paper does apl really need runtime checking and discuss the overhead by apl interpreters for implementing the of data types and shapes by runtime checking they conclude that of the rank length domain and value checks required by a naive interpreter could be eliminated by static analysis before execution this result gives us that the design here will not totally production efficiency to programmer convenience in the remaining sections of this paper we shall first discuss the kinds of information to be obtained from binding time analysis and how they are useful in constructing an appropriately efficient implementation of each program processed and then focus in on a particular subset of the binding time information namely the analysis of data types and storage management in an appendix we discuss the language which serves as the basis for our current work in this area was developed as a tool for concepts of programming language semantics and their effects on implementation efficiency it is far too limited to the requirements for an ideal language discussed earlier in this section but it does provide an testing ground for this approach because of its extremely late binding times it will be described more fully in our paper ii binding time analysis the main of our approach to language and processor design is the consideration of binding time as a parameter which may vary from one program to another and even among the parts of a single program we now discuss several aspects of the of binding times and the kinds of information we would like to obtain from binding time analysis i data types to determine for each occurrence of a variable what range of types its value may assume during execution these would include both atomic types integer string etc and compound types such as structures and arrays one use of this information is to determine at analysis time whether runtime type tags and tests for type correctness will be required during execution and if they will where the tests can be most efficiently performed the need for such tests should we feel be determined by the processor and be reported to the programmer the need for such tests and tags and the techniques for avoiding them are clearly irrelevant to the task of implementing any given algorithm and so should not be the of the programmer clearly only two binding times are relevant to data type analysis time and execution time to determine for each variable whether it requires dynamic storage allocation and if so by what discipline stack or heap this dimension of binding has significant effects on runtime efficiency and is one of the major differences among current languages storage binding disciplines range from that of apl snobol and lisp in which every assignment may cause through explicit allocation and deallocation with heap management algol pascal allocation at block entry and deallocation at block exit allowing much simpler stack management algol to static allocation at analysis time fortran cobol pascal clearly the simplest most natural and most powerful method from the programmers viewpoint is the totally dynamic approach we feel that it is worth considerable effort to learn how to select the most appropriate storage allocation method for an arbitrary program rather than forcing the programmer to explicitly storage as is necessary for example in name to determine for each use of a variable or procedure or label name whether it is bound in a fixed way within the enclosing program text or whether it is a global variable or formal parameter in the latter cases it is important to determine to which variables or expressions it may be dynamically bound and how this may vary during execution in the case of procedures it is conceptually natural to allow global references to be bound dynamically to their calling contexts as in apl and snobol and to bind similarly variables which occur in actual arguments of procedures as in algol the main alternative to this approach is to bind names in some static manner a consequence of this is that calls to library procedures must pass all variables which may be referenced in the form of often argument lists parameter access methods to determine for each formal parameter whether it may be stored into or both and the most appropriate method of accessing it eg call by text substitution reference value result or name as for binding the most natural method for the programmer namely text substitution is particularly inefficient program analysis will attempt to determine for each parameter a more efficient method which yields the same behavior program text creation to determine whether the program may read or otherwise dynamically create program text during execution this facility adds considerable power to some of the languages used in artificial intelligence research eg lisp and and has been available in some compiled languages as well such as however it is clearly quite expensive since it requires the ability to use the full language processor during execution we next discuss each of the above topics briefly with respect to issues of efficiency implementation consequences and analysis strategies i data types the need for runtime type tests imposes overhead in both space and for the type tags which record the current type of a variable and time to set the tag whenever the value of the variable changes and to test it at each use to date this overhead has been in languages such as lisp apl snobol and algol due to the fact that formal parameter types need not be specified analysis will eliminate the need for a great many of these tests by verifying compatibility of assignments and uses techniques for this type of analysis based on program flow are described in detail in section iii of this paper program flow analysis as will be described for data types in section iii seems quite appropriate to determining program points before which storage for a given variable must have been allocated and those points beyond which a variables value may no longer be referenced thus deallocation as well as providing some information about the amount and organization of the storage to be allocated for the variable given the substantial overhead of runtime storage allocation activity it is clearly desirable to allocate variables which assume only atomic values integer boolean etc statically before execution or on a stack at entry to a program unit if recursion allows multiple of the program unit the situation is more complex for variables whose size andor shape may vary during execution the first priority for such variables is to determine whether allocation must be done or whether their storage requirements remain constant over larger segments of the program if we assume that as in array bounds need not be declared and that any component of an array may itself be an array then two distinct problems arise the first is that the number of levels of an variable may increase without bound it appears that flow analysis techniques may make it possible to decide whether this can happen and to determine the various shapes the variable may assume by methods similar to those used to test of contextfree languages the second problem is that the dimensions or number of components at one level of an array may vary in any assignment may add a new component to a structured variable this problem is more difficult since flow analysis provides no natural means to determine eg the range of values of i in a statement such as ai i hence a conservative analysis scheme would treat every variable which appears with subscripts as extensible which is clearly this difficulty could be by i optional specifications of array bounds when arrays are not in fact extensible by allowing of the integers as subscripts as is done in pascal or in a language possibly by more sophisticated analysis techniques based on the suggestions of and may another storage allocation problem relates to procedures since these are typically entered and in a manner it appears natural to assume a stack allocation scheme for their local variables this is certainly applicable to those variables which are not assigned on one call and during a later one it appears that flow analysis may again be a suitable tool by which to determine which values must be from one activation to the next and that the stack of and may provide a suitable and relatively efficient implementation method for this as well as providing a basis for a variety of less traditional control disciplines such as and backtracking name the only relevant binding times for names are processor time and during execution name binding during execution which is necessary to support symbolic indirect addressing as is found in snobol and dynamic contexts for global variables involves some sort of runtime symbol time and overhead to search the table whenever an variable is referenced this may significantly slow program execution name binding may be determined by i forming a graph which indicates calls from each procedure to the others associating with each node lists of variables which are listed as formal parameters or used but neither nor listed as parameters respectively associating actual arguments with formal parameters for each call and propagating the information through the graph the process is simple enough that we shall not illustrate it here this algorithm assumes that all called procedures are accessible to the processor when the analysis is performed which seems highly desirable since otherwise each variable whose scope includes a call to an procedure must be regarded as a possible nonlocal reference from within that procedure of course this might be by associating with a procedure library a table of nonlocal references for each procedure and allowing the processor access to these tables parameter access methods clearly call by text substitution is to be avoided if possible since it requires runtime statement analysis further call by name which is similar in effect can be expensive analysis would attempt to determine the under which call by text substitution or name could be replaced by reference or other methods without the meaning of the program aside from complications due to name binding the main problem in this area is that a called procedure may change the values of nonlocal variables and parameters which appear in actual arguments which are themselves expressions flow analysis seems to be an appropriate tool to determine whether such assignments can occur however we have not as yet a serious investigation of this area s text creation we the language proposed in section i as allowing as does statements such as call x where x is a variable whose value is a procedure the question is whether x may have values stored into it which are constructed dynamically during execution this would require a complete runtime language processor and would probably the other kinds of bindingtime optimizations discussed here note that variables do not in themselves cause difficulties as long as they are only assigned and not on in other ways thus a program segment such as the following x y input if z then x output y call x can be handled by compiling all of the procedure values before execution determining whether procedure text can be input or constructed during execution appears to be amenable to flow analysis techniques one implementation technique that might be used to the effects of dynamic procedure creation is the facility in some lisp systems to run compiled and interpreted routines together iii data type analysis data types are one variety of a larger category of information about variables which we call the set of attributes for can be naturally represented by a contextfree language given by the following grammar type ÷ int i str i i gen i shape shape i ÷ i v where num represents a integer or the symbol an attribute symbol may indicate for a particular variable at a particular point in a program what its data type is the simple types are integer string and undefined respectively gen ie general is the union of all types and a shape type represents a structure with a known or unknown respectively number of components whether it has a value def whether it will be used later in the program ref and how much storage it sz the notation i v v n denotes the situation in which a variable may have any of the attributes n such information propagates both forward and backward in a program eg if the statement a b appears in a program it tells us that a must be numeric after this statement and b must be numeric before it to determine the attributes of each variable at each point of the program we exploit the forward and backward propagation and the type restrictions of the operators to construct an algorithm which begins with all attributes at all points assumed general and then iteratively inserts and propagates information until the process has used a related approach for type determination in the setl language where extensive analysis is required merely to determine the meaning of an operator due to the use of the same operator symbols for many different purposes see the appendix for an explanation of the use of brackets and the operator our approach appears to be both more general and less complicated though without further refinement it results in larger systems of equations than other related approaches are those of kennedy i ii and graham and wegman though none of these specifically consider applications to data type determination the last authors present a general model of information propagation problems which could provide an appropriate basis for formalizing our methods a simple types we now present a complete type analysis procedure for simple ie types for programs with only assignment conditional and branch statements and the block structure brackets begin end used only for not to introduce new variables except at the whole program level and structured variables this analysis will be useful in runtime storage allocation activity and the use of type tags as follows the result of the analysis will be a pair of functions fb p x i ÷ where denotes the set of identifiers occurring in the program p is the set of program points or between sequentially executable statements and is the set of attribute symbols defined above to explain their use we must first define for a statement s and variable x the sets use constraints and constraints t i there is an assignment of values to the variables in s such that s may be executed correctly with x having type t t e i execution of s may store a value of type t into x for example if s is the statement a b length a then str int n and now let i be a program point just prior to a statement s which uses the variable x we use f to monitor program execution as follows if fix then i at point i a test of a runtime type tag associated with x for membership in is necessary if not present signal a runtime type error and take appropriate action at the programmers option the action could be the statement execution or error correction ii store a runtime type tag for x whenever x is assigned by a statement from which control may pass to i without x if fix is sufficiently large t contain all types which the value of x may possibly have at program point i then this method will signal all runtime type errors and avoid attempts to execute statements with type errors clearly letting fix gen would provide complete testing but at the of much unnecessary type tag manipulation our technique will construct the smallest possible sets fix which allow complete testing consistent with the conservative assumption that all possible execution paths through the program may occur in actual computations note that such a minimal set must exist assuming fix is finite since if functions f and f both provide complete type testing as described above then ft given by fix fix n fix will also this scheme can be improved in two ways first a more explicit method needs to be provided for deciding which assignments must be by corresponding type tag assignments second if it can be determined at each assignment of x that certain types are incompatible with all future uses then the type compatibility test can be performed at the point of assignment the need for later testing and possibly making the type tag itself unnecessary both of these improvements may be realized by using b f x q ÷ to further monitor execution as follows assume program point j immediately follows statement s which assigns a value to variable x if then after performing s test the type actually stored into x against if not present signal a runtime type error if present set xs type tag accordingly we clearly wish to contain all types which x may be assumed to have in subsequent statements which use the current value of x it is also clearly less important than fix since use errors will be detected at the point of use if not however it does allow earlier error detection and the use of fewer type tags the properties of b are to those of f a larger b will result in fewer runtime tests and if both b and b detect type violations which would result in errors in later uses then b u b has the same property hence there is a maximal value for b note finally that the f and b functions need not be stored in any explicit form during execution b formulation of the equations first we convert the program into flowchart form for conceptual convenience and insert a program point between any two statements such that control may pass directly from one to the other at the entry to the flowchart and at each exit let the resulting graph contain the subgraph in figure i where ij are program points and s is s f i g u r e a statement information about types will in general propagate forward from fix to and backward from to in particular if s does not change x then we have fix and if s assigns a new value to x then will be modified as well these effects of program flow are naturally expressed as a system of settheoretic equations with each fix and as variables in the following with ij s and x as above we write to denote the new forward information about x derived from fix and similarly denotes the new backward information derived from and now suppose a statement s is immediately by program points ii im and by jl jn as shown in figure then the s £ figure equations are as follows f equations for x i fix m u il if i is the initial program point for each program point jj as shown mn figure b equations for x n i u jl for each program point ii as shown in figure x gen if jj is a ter where i and i program point fix if x is not assigned in s f if x is assigned in s except for case below q if s is x y if x does not appear in s gen if x is assigned but not used in s if x is both assigned and used in s n if s is y x n if x is used but not assigned in s except that s is not as in the equation n u jl can in most cases be replaced by the more tive n q jl which will frequently result in a smaller f solution and hence fewer runtime tests the reason is that normally any constraints which x must satisfy along paths leading backward from jl jn must all be satisfied at if im however it is possible that s is directly or indirectly a branch on type for x and the jl path will be taken only if x is an integer the j path only if x is a string etc in this case the only is to use the union the example given below illustrates this problem finally we show how to determine and from the form of s and x store constraints i t if s is x constant and t is the type of constant gen if s is x input range type of op if s is x op exp is not used for s of the form x y so we leave it undefined use constraints i if s is y exp output exp or if exp gen if x does not appear in exp or exp is x op n if x and exp x op n op xx q p yx gen for p any of and p type of exp if exp is not a variable for p as in item c solution of the system of equations the system of equations for f just defined will be of the form x x f xi xp xp xp or equivalently f where each x denotes one of the fix and is the vector for fixed values of it is clear that x xi x x implies xp or ip p ie that f is monotonic on the partial ordering of set inclusion it follows that a unique minimal solution to the set of equations exists and can be obtained by computing fi ¢ u i io this is the desired solution for f since as noted before it should be as small as possible in order to minimize runtime type checking for b the mentioned above requires that it be as large as possible the equations for b has the same abstract form y y and again yi g i for i p implies g thus gen m gen for i i and thus y b gen gen will be a maximal solution b this solution may then be substituted into the original f equations to begin their solution process d an example of data type analysis simple types as an example of our methods we shall perform the data type analysis on the program begin scope sum st m x input y input if x then begin st st y goto l end sum s u m y l if x then goto m output sum o u t p u t st end we first translate the program into the flowchart shown in figure and then construct the systems of equations which we write in figure in an abbreviated form we abbreviate fix n int for example by writing bi int at the intersection of the x column and the fi row and n by bj n at the intersection of the x column and the bi row note that this program contains an implicit branch on type as discussed if statement following point if the program and its input are compatible the type of the y input according to the value of x solving the equations in figure by the methods described in section we obtain the type information shown in figure comparing this information with the values of uc and sc we conclude that i no type tag is required for sum st or x a single tag with possible values int and str is needed for y no type checking is needed for sum or st at point a check should be made to ensure that the value input for x is of type int at point a check should be made to ensure that the value input for y is of type int or str and the type tag should be set accordingly at points and the type tag for y should be checked to ensure that it is of type or int respectively no other type checking or tags are needed inspection of the program will show that this is sum st vt i x i n p u t y i n p u t i f x no es sum sum y st st i n a y yes if x output sum output st figure indeed the minimal type checking sufficient to ensure the correct execution of the program note that the efficiency of the solution process can be improved somewhat by first chains such as fx fx fx fx we leave a general attack on the efficiency question to a later paper sum b gen bi b b b u b b b b b u b b b b b u b int b b u bi b b n gen bi bi gen st b gen b u b b b u b str b u bi b b u bi b bi q gen gen b equations bi b gen b b n int u b q i nt b b n i n t u bi q i nt b b n int u bi q i nt b bi gen bi b b u b gen b u b b q str b u bi b n int b u bi gen bi gen sum f f bi n i n t f fi f f u f f f f f f f f f f b q i n t f f u f f u f fi f l l f equations st fo bi q s t r f u f f f b n s t r f f f u f f u f fi x f fi b q gen f f f f f f u f f u f y f fi f u f b q gen f f f f f u f f u f figure sum b gen bi gen b gen b gen b gen b gen b gen b i n t b gen b gen gen gen bi gen b function st x y gen gen gen gen gen gen gen gen gen gen i n t gen gen i n t int v str str int str gen i n t gen gen i n t int gen i n t gen gen i n t gen gen gen gen gen gen gen gen gen gen f function sum st f nt f i n t f int str f int str f int str f int str f int str f int str f int str f int str int str int str fi int str d d d t v int v str nt int v str t int v str nt int v str nt int v str nt int v str nt int v str nt int v str nt int v str nt int v str figure iv extensions and other applications in this section we shall discuss several extensions to the techniques introduced in the preceding section and point out some further applications to storage management a definitions and references the attribute symbol def as applied to a variable x at a program point i indicates that x has received a value along some path leading to i and ref indicates that x will be used at some later point in the program thus points at which x has both these attributes are exactly those where it must have an associated storage area to hold its value the settheoretic equation technique of section iii is quite appropriate for determining these attributes the equations are as follows f equations for x i fix m u il if i is the initial program points for each program point jj as in figure b for x n i u jl for each program point j as shown in j figure if jj is a terminal program point where i fix if x is not assigned in s def if x is assigned in s and i if x is neither used nor assigned in s ref if x is used in s if x is assigned but not used in s the solution process for these systems of equations is identical to the earlier ones and the convergence analysis there applies as well as an example we analyze the program begin scope abc a input l b input c ab if c then goto l if b then begin output c goto m end output b m end the flowchart corresponding to this program is shown in figure and the corresponding equations and their solutions in figures and respectively a input b input c ab b function ac b b i ef b ef ref b e f ref ref b ef b r f ref b ref b ref b b f function abc f fi def f def def def f def def def f def def def f def def def f def def def f def def def f def def def f def def def figure yes if c · output b output c now by forming the union of f and b to determine the variables which have both attributes at each point we determine that a requires storage at points i and b at and and c at and the results of this analysis can be used to determine the minimal over which each variable requires allocation and hence minimize the storage space used by a program alternatively it can be used to determine simply the point at which each variable can be allocated storage and the point at which it can be deallocated figure b equations a b bi b b ref b b u b b b b b u b b b b b b b b bi ref b u b ref ref b c bi b ref b b u b b ref f e ab f fi def f f f f i u f def f i u f f f f def f f f f f f f f f f f f f f f f f f f f f f f f figure b procedure text creation as noted in section ii creation of procedure text during execution can most types of optimization discussed here thus it is extremely important to determine whether this kind of activity can occur in a given program to perform this type of analysis we must first identify each call statement in the program and examine the string expression appearing in it if the string expression is a constant it causes no difficulty ie it is of compilation if it is a variable further analysis is required if it is an expression then procedure text must be created during execution if it is determined that all procedures are given by string constants they may all be compiled if at least one procedure is given by a variable but none are given by expressions then we must perform the data type analysis of section iii and can then perform a further analysis to determine whether program text is in fact constructed dynamically or merely assigned to variables let x be a variable whose attributes include tr at program point i then we define attributes and to mean that i at least one path leading to i may assign x a string value without performing operations on it and respectively at least one path leading to i may assign a computed or string value to x directly or indirectly these attributes will only propagate forward the equations are given by i fix u n d m il if i is the initial program point for each program point jj in figure where i fix if x is not assigned in s if s is of the form x if x is assigned input or a string expression other than a constant or a variable in s if s is of the form x y if x is assigned an expression or constant not of type string in s the operator is defined by the table and by the property of associativity a b c a b c for example we analyze program text creation for the program begin scope a input b output a if a then b output c c b call c d begin scope c b end call d end the flowchart is given in figure note that data type analysis shows that all variables except a may be of type the resulting forward equations for program text creation analysis are given by figure a and their solution is in figure b a input b output a if a b output c cb call c d begin scope c b end call d figure f equations f f i fo f f f f f f f f f f f f f f f c fo f f f f fb · fb f f f a d fo f f f f f f f f f fi f f f f f f f f figure i f function b c b thus we determine that the procedure which may be assigned to b and c can be compiled while that assigned to d must be constructed and processed during execution the points where a variable receives the attribute in the formulation of the equations supply all the string constants which are candidates for compilation note that assignment to a global variable in a called procedure or the of a possibly variable as an actual argument to a procedure this analysis considerably since such an assignment may cause an otherwise variable value in the calling procedure to become for example if the statement b output c were b b input instead then the statement call c would cause b to receive a value unknown before executions so that any later use of b must be c of local variable values the local variables which need to be from one invocation of a procedure to the next are exactly those variables which may be used along some execution path before they receive a value in the current invocation since any other variable will get a new value in the current invocation before it is first used the need for can be determined by placing the body of a procedure in a loop and then performing the data type propagation for it any variable among its resulting f types at a use of it is a candidate for for example for the procedure parameters ax begin scope b if a i then b i b b x b end which is called by call we obtain the flowchart of figure ii with the containing loop provided on performing the data type analysis we find that b is of type v int at point i and hence is a candidate for yes i b i b b x b figure d lengths of strings to optimize storage allocation for variables we must first determine the range of lengths which each may have then any string variable whose length has a constant bound may be allocated storage before execution and those whose lengths are unbounded can be selected for at appropriate points during execution flow analysis is again an appropriate technique for determining bounds on string lengths only forward propagation is necessary and the form of the equations is as follows f equations for x i fix if i is the initial program point x max for each pro gram point as shown in figure where i fix if x is not assigned in s if s assigns to x a value of a type other than str if x is assigned a string value by s except for case if s is x y the function the length imposed by s for s a statement of the form x is defined as follows i length of string for any string constant if is a constant i if is a constant lb otherwise for example ab ab to illustrate the analysis process we the following program for a post tag problem derived from begin scope x i m tag x ii x x length x if tag then begin x x goto l end x x ii l if length x then goto m end the flowchart is shown in figure and the f equations and their solution in figure note that if we substitute x input for x i then we get fix for i which suggests that we must do for x during execution of course we x i p t a g x ii x x length x · tag x x x x ii if length x yes o figure f equations tag f f f f f f f f f f f f f f f f f f f max f f f max ff f function tag f f f f f f f f f f x figure must do so since the value read into x during execution may be arbitrarily long but in cases such as this program we can restrict the allocation activity for x by refining the analysis in particular if we set fix length x in the f equations where length x denotes the unknown length of the x read in the solution shows that fix length x for i thus in this more refined analysis we can determine that allocation for x need be performed only its value is read in we leave to a later paper a discussion of the complications introduced by allowing multiple symbolic constants of the form length x in the equations string length analysis introduces a new the set of attributes is no longer finite the solution to the equations may be infinite for example if the constant ii is replaced by in the example above then fx must satisfy fx so that fx co is the only possible solution e structures and arrays as mentioned in section ii structures and arrays of either the highly general variety found in or of more limited pose significant complications for the techniques discussed here rather than attempt a full of the difficulties here we shall only point them out and outline the directions of our future work in this area the first problem is that in analyzing an assignment of the form ai exp there is no way to determine in general the range of values of i by data flow analysis techniques or for that matter any method short of executing the program thus we must assume that this assignment may modify any component of a and this implies that we must union the possible types of components of though the program might never assign values of different types to the same component thus any array whose components are possibly requires runtime type checking at each ac s second unless all subscripts of a in every assignment to it are constants or can be determined to have bounded value we must assume that the number of components of a at each level is extensible third the number of levels of in a structure may also be unbounded and flow analysis alone will fail to determine that it is bounded in cases where it is for example consider the trivial program begin scope ia i i a i l a ia i il if i i goto l end our present techniques can determine that a has two components at each level but not that it never has more than ten levels it would in fact find the type of a immediately following execution of a ia to be v v int v solutions to all of these problems can be provided by optional declarations but the approach outlined in section i suggests that we first attempt to obtain as much information from program analysis as possible before this alternative some of the improvements which can be provided easily by optional declarations are the following i the use of named selectors or types as in pascal as subscripts provides bounds for the value of a subscript and hence marks structures which are not extensible as to the number of components at each level declaration of a maximum or constant number of levels for a structure clearly solves the third problem above note that the use of named selectors or types introduces the need for checking the validity of each reference to a component while no subscript checking is needed in full all possible components are at least implicitly present at all times though this introduces overhead it is generally desirable since it provides one kind of execution error detection v conclusions and future research in this area we have presented a proposal for a new programming language whose semantics would be based on very late binding times and minimal use of declarations and whose processor would automatically select the most efficient binding times consistent with the semantics of each program we have also presented some program flow analysis techniques which appear to be appropriate for several aspects of binding time selection clearly much remains to be done first it remains to be determined just how far these methods can be extended without requiring the user to supply a mass of material second we lack evidence to determine whether the approach is in fact is whether the algorithms can be made efficient and whether they will produce an acceptable degree of optimization for most programs these questions must be prime concerns for future work in this direction some particular for future work include the following i how much useful information about data types and storage requirements for largely unconstrained structures such as those found in can be provided by flow analysis techniques how much improvement can be made in the analysis of structures if they are constrained to have declared bounds on their depth of andor what complications are introduced into the analysis of program text creation by global variables and actual arguments whose values may be procedures and may themselves be modified in procedures what are appropriate methods for solving the systems of equations with the symbolic constants length x discussed in section how much useful information about the dimensions of structures can be obtained from observations of the following sort if a always appears in a form such as for i by to i do ai expression in a given program then a has exactly i components as noted previously and may sketch some possibilities for analysis of this sort is flow analysis or some other method appropriate for constraints on parameter access what effects do dynamic as found in have on the analyses in contrast to the preceding question what improvements can be obtained in the efficiency or completeness of the analysis methods by restriction to programs what are appropriate for the processor and runtime support package i how can support for userdefined data types as in pascal or for data abstractions as in clu and be integrated into a language of the sort discussed here and what effect do they have on the analysis methods and implementation efficiency some of the concerns about implicit abstractions discussed by in are particularly as for combining our approach with such highlevel abstractions ii what are appropriate semantic models to express formally the optimizations discussed here methods based on and a model we have under development ourselves all seem likely candidates references i allen f e control flow analysis proc of symp on compiler optimization sigplan notices vol no july pp alan m j does apl really need runtime checking and vol pp daniel g b new programming languages for artificial intelligence research computing vol no september pp daniel g a model and stack implementation of multiple environments comm of the acm vol no i october pp john t schwartz programming languages and their compilers second revised edition inst of math sciences new york univ dijkstra w on the design of machine independent programming languages in richard ed annual review in automatic vol pp graham l mark wegman a fast and usually linear algorithm for global flow analysis conf record nd on of prog lang january pp k pascal user manual and report springerverlag berlin jones d s muchnick a unified treatment of binding time and parameter passing concepts in preparation i kennedy w node applied to data flow analysis conf record symp on of prog lang january pp ii g a a unified approach to global program optimization proc acm symp on of prog lang october pp may automatic comm of the acm vol i no march pp b m syntax macros and extended translation comm of the acm vol no ii november pp liskov programming with abstract data types sigplan notices vol no april pp the manual computing center the university of ann finite and infinite machines prenticehall pp pratt t w a theory of programming languages part i dept of computer sciences univ of texas at austin july m type determination in very high level languages report no inst of math sciences new york univ the complexity barrier again acm interface sigplan notices vol no i jan pp william a towards a language to support structured programs dept of computer science univ pittsburgh pa april appendix the programming language is language designed as a tool for some of the semantic and pragmatic aspects of programming languages its syntax semantics and methods of implementation are described completely and precisely in our paper one major design of the is to provide a context in which the effects of design features on implementation efficiency can be clearly observed since we have on semantic issues the syntax is as simple as possible such desirable structural features as ifthenelse while for and case statements however such structures may easily be added by purely syntactic methods such as syntax macros as we show in the version of the language named the syntax of is presented in extended form in figure ai we use for for optional items and with their usual meanings for regular expressions and a new form a b to stand for a b a the and operators all take precedence over concatenation which takes precedence over alternation is used to indicate brackets as terminal are extended symbols while indicate that ordinary brackets appear in the terminal string the semantics of is defined by specifying an abstract machine which executes programs written in the language the full definition of the abstract machine is too extensive to include here so we content ourselves with some remarks and examples of the semantics i the value of a variable may be an integer a character string the undefined value denoted · or a structures which is a finite ordered tree with objects of the other types at the leaves the components of a structure are accessed via a so that eg indicates the j tn subtree of the i th subtree of the current value of x a linear notation is used to write structures so that x corresponds to the tree x at ab and xi i x x cat and x variables are allowed to change their sizes shapes and types during execution of a program block structures is provided to limit the scope of name references by the scope declaration but has no effect on allocation of storage or data types the scope of a global reference depends on the dynamic calling context as in apl rather than the static block structure as in algol an expression may be an arithmetic expression a string expression or a structure whose components are expressions an assignment statement with a variable on the left and an expression on the right is performed by i evaluating the expression by the precedence rules inherent in the grammar and then ii binding the variable name or component if appearing on the left to the value computed in step i an assignment statement with input on the right causes the next value in the input stream to be read and one with output on the left causes the value of its right side to be note that the size shape and type of the value assigned to a variable may change arbitrarily from one assignment to the next the if statement is executed as usual except that no else clause is allowed it is required that the expressions compared in an if statement be of the same type if they are not structured or that both be structures notice that only equality and inequality comparisons are meaningful for structures no distinction is made among character strings which are data labels or program text thus goto is executed by first evaluating the string expression to a string constant if this string constant labels some statement in the current block control is to that statement otherwise we trace back through the dynamic chain of containing blocks until the label is found if it is not found execution of the program aborts similarly call is ex by i evaluating the string expression to an executable procedure body if the result is not executable this will be discovered only during the attempt to execute the procedure ii substituting each actual argument for each occurrence of the corresponding formal parameter in the procedure body resulting from step i and then iii control to the first statement of the resulting text note that this makes it possible to create or input new program text during the execution of a program and then execute it execution of a return statement or the end of a block causes control to exit from the containing procedure or block and the variables within it to become note that the above describes the semantics of and not an implementation so that a processor is not bound in any way to use text substitution when a more efficient parameter passing method is equivalent to it or to carry runtime type tags for variables whose types are known to be static and so on program ÷ block block begin scope statement end scope ÷ scope statement label assign i goto i if i call i block i assign var i output exp i input goto ÷ goto if if then statement exp i i i i i exp call call args args ÷ exp list exp ÷ exp list ÷ i ÷ term i term factor i ft factor ÷ var i number i i length ÷ £ ÷ ÷ var i string i string ÷ i ÷ letter i i i · i i i i i i i i l i i i i i i i l i l l i keyword ÷ begin i end i scope i return i input i output i goto i if l then i call i length i i substring i parameters label ÷ var ÷ subscript subscript ÷ letter letter i letter ÷ a i b i i z number ÷ i i i i i i i i i i procedure statement ÷ parameters £ data ÷ constant £ constant ÷ number i string i data figure ai syntax of a number of extensions to have been defined with the purpose of making implementations more efficient for all programs written in the language at the of decreasing the power of the language the extensions cover all of the five dimensions of binding time discussed in section ii of the paper for example in the area of storage allocation there are three variants i which requires the to explicitly allocate and storage the syntax is modified by adding two more alternatives to statement namely allocate and and defining allocate ÷ allocate shape £ ÷ £ share ÷ part part ÷ i shape i shape and making appropriate changes to the semantics the size and shape of the value of a variable is now constrained to be between allocation and the corresponding deallocation ii which causes allocation at block entry and deallocation implicitly at block exit in this version scope in the definition of block is replaced by decl and decl ÷ declare shape t is added to the syntax the semantics is modified to be identical to doing explicit allocates as in of all variables whose scope is the current block at entry to it explicit at all exits from the block and no within it iii which requires storage allocation for the entire program to be done before its execution begins the syntax is modified as for except that decl and shape are now decl ÷ declare static shape shape ÷ number i shape i number shape and the semantics is appropriately modified each of these versions programs more than the one before it but also results in a more efficient implementation a similar of restricted versions is defined for each of the other four dimensions we refer the reader to our paper for further information on the restricted versions and the language in general the research directions of this paper from the observation that the need for the more powerful versions is usually present implicitly in the structure of a program written in a less powerful version hence a sufficiently processor could choose the most efficient binding times compatible with the structure of a program rather than the to use the less powerful versions 
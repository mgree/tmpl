flow analysis and optimization of structures by d jones s department of computer science the university of usa i introduction in the authors introduced the concept of binding time optimization and presented a series of data flow analytic methods for determining some of the binding time characteristics of programs in this paper we extend that work by providing methods for determining the class of shapes which an unbounded data object may assume during tion of a program and describe a number of uses to which that information may be put to improve storage allocation in compilers and interpreters for advanced programming languages we are concerned with finding for each program point and variable a finite tion of a set of graphs which includes all the shapes of values the variable could assume at that point during the execution of a program if this set is small or regular in structure this information can be used to optimize the programs execution mainly by use of more efficient storage allocation schemes in the first part we show how to construct from a program without selective updating a tree grammar whose nonterminals generate the desired sets of graphs in this case they will all be trees the tree grammars are of a more general form than is usually studied so we show that they may be converted to the usual form the resulting tree grammar could naturally be viewed as a recursive type definition of the values the variables may assume further standard algorithms may be employed to test for emptiness or linearity of the tree structure in the second part selective updating is allowed so an alternate semantics is introduced which more closely traditional lisp implementations and which is equivalent to the tree model for programs without selective updating in this model data objects are directed graphs we a finite approximation method which provides enough information to detect cell sharing and cyclic structures whenever they can possibly occur this information can be used to recognize when the use of garbage collection or of reference counts may be avoided the work reported in the second part of this paper extends that of schwartz and cousot and the partial grant work reported support of here was performed national science under foundation the cousot c they have developed methods for determining whether the values of two or more variables share cells while we provide information on the detailed structure of what is shared the ability to detect cycles is also new it also extends the work of kaplan who distinguishes only binary relations among the variables of a program does not handle cycles and does not distinguish selectors so that his analysis applies to nodes representing sets rather than ordered tuples ii programs with data in the first part of this paper we shall carry out our analyses on a simple programming language called sl structure language whose syntax is as follows program s assign if test goto exp label stint i if i goto var exp i var output exp input if test goto atom exp i exp i var goto label atom i var i exp i i var we assume that instances of the syntactic classes var sel atom and label are members respectively of the sets var sel atom and label which are pairwise disjoint informal discussion the sl closely lisp with the prog feature but without functions or and extended selectors to allow arbitrary see reynolds numbers of for to handle functions the semantics of sl are essentially those of lisp with two minor exceptions the uses of nil a special atom in lisp must be done a reynolds work to our attention after this development was completed he treats a subset of lisp with recursive function calls and without sequential execution it seems clear that the two methods could be combined via the empty or undefined data structure l and any attempt to apply a selector eg car cdr to an atom or l will result in program instead of being undefined in lisp without selective updating operations it is natural to view the value of a variable as a tree without regard to cells pointers etc each internal node will have an edge labeled s leading to a subtree for each s in the set of selectors sel if tl tm are trees root node leading to tm denotes the tree consisting of with edges labeled sel sel m the roots of tl tm respectively a if t has this structure then denotes i the subtree t all trees in examples in this paper will use the fixed set of selectors sel trees will be given with the root at the top leaves at the bottom and atoms labeling the leaves selectors may be omitted for convenience in which case the edge directed from a node goes to the hd subtree tl subtree semantics of sl the value of an atom is an element of the set atom and is given by the function atom atom we assume that atoms are otherwise unspecified simple data objects numbers character strings booleans etc trees are defined formally by the sequences of labels encountered on paths from the root to the leaves such a sequence is written as s where n s i sn c sel and a e atom the set of all such label sequences is naturally described by sel x atom by definition f sel x atom such a tree is a finite subset t of that if s s a t then n s s bc ab the null tree t is written as l read bottom the definition allows trees with missing branches such as in diagrams the missing branches will be drawn and filled in with j some examples are shown in figure diagram i a set l figure by definition if tm are trees and se sel then ts tl i stl q t and tm il i tl c ti the definitions are naturally extended let bm be sets of trees as then as ts i t c bm tm i ti eb mt q bm following the constructs we define in terms style of denotational semantics the meanings of the various of the domains atom al sel x atom and store var a store a c store is a function mapping each variable to its current value we only define the meaning of expression evaluation and ment statement execution the other features of sl can be formally defined by wellknown means including continuations exp store is a partial given by function o atom o o undefined or is an atom if u e assign var ix store s given by exp u lx c var var ox execution of a statement program will be aborted if and the whole a an expression undefined which must be evaluated is b an if statement compares two values either which is a nonempty nonatomic tree c a nonempty nonatomic tree is read by a statement var input of note that point b implies that eq in lisp rather than equal these tests model iii structure shapes and data flow equations we now show how to construct a system of forward data flow equations from a program let x be a program variable in var and i a program point the system will then have a variable fix the least fixed point solution of the system will associate with fix a set of tree shapes which includes all possible shapes x could have at point i in any possible execution of the program the set of shapes is x o shape se defined simply by that the next is we have replaced symbol o which represents we form the lattice all elements an arbitrary shape of all of atom by atom subsets of shape with the usual subset ordering the variables in the equation system will have elements of shape as values as in we first convert an sl program to a flowchart and annotate it with program points in the set n one for each arc in the figure consider the flowchart segments of p s j a statement pi i p s j ye db b if j no statement figure the equations are formed as follows form of s equation x atom or x input o xy u u x ys u u x ym if atom x if x f j x yes n o il il o f j x il yes n ill f j x il yes n n ol il n other f j z yes u u i y u u finally the equation l is included each variable for the initial x program point i and o note that the only way in which statements constrain the shapes of values to them is through the possibilities for of execution taking these constraints into account through backward flow analysis as discussed in our or kaplan and could provide more specific information about shapes however we ignore this possibility for the present since the extension is straightforward to obtain the maximal information available from forward flow analysis about the programs data values the fix sets should be as small as possible as long as they include every value which may be computed it is for this reason that the sets o and ol appear in the equations to conclude as much as possible from the programs assumed correctness iv solving the flow equations there are at least two methods available to solve the data flow equations one is iteration in either its regular or form see and starting with every fix d it should be clear that the functions involved are all continuous so solutions always exist this method is appropriate if the solution is finite unfortunately this is not generally the case for the systems under consideration here instead we shall introduce here a method based on regular tree grammars which handles the finite and infinite cases equally well the objective is to obtain a regular tree grammar such that the language it generates is a safe approximation to the minimal fixed point of the system of flow equations this is useful since tree grammars are a extension of regular string grammars consequently existing algorithms can be used to test for linearity etc the approach is to form from each data flow equation a production in an extended regular tree grammar which is then transformed into an ordinary tree grammar tree grammars a regular tree grammar see for example or is a grammar with n a finite set of nonterminal symbols z a alphabet of terminal symbols such that n n z s e n is the initial nonterminal and p is a finite set of productions of the form a t where here is defined by i n u z s ii if k a c t tk e then at tk q iii nothing else is in note that the linear in ii corresponds representation to the tree a a tk k m co our by tree grammars we choose k m and o atom u l xl sel x if t is a tree as used in our trees description of of sl the corresponding is recursively defined by element bt atom atom gl sel m t tm a sel sel m ii l tm for example we have the equation below hd m b tl tl c a hd tl aa bc we assume the semantics of a regular tree grammar is defined by least fixed points in the same manner as was done by for languages that is nonterminals are interpreted as sets of trees and the productions are viewed as a system of set equations it should be clear that this gives the same generated set lg as the usual semantics since the analogy between regular tree grammars and contextfree grammars is very close we will also write tree productions in the sl notation for convenience this does no since it is easily seen that t t by production example the natural interpretation of a z c is that for all tb b tc c c the tree is in a translating into tx terminology at b the c production is as shown in figure a and means ii bc i tb i tc a b figure that if tb c b tc c c then the tree in figure b is in a having shown the connection to ordinary tree grammars we now proceed to assume that all grammars are expressed and interpreted in terms of sl trees definition an extended g above except that p is productions of the form regular grammar is where n z p and s are now allowed to contain a bs where s e sel a as the semantics of of sets is simply the for example the three such a production assertion that productions in terms bs s a tl cc would correspond to the set equation u tl is in a for some t the new production type clearly gives rise to a continuous function so the solution of the extended regular tree may be found as before by least fixed points examining the flow equations we see that they are nearly in the extended tree grammar form except for restrictions involving and removing these is safe since the result is only to the solution values referring to figure a let i be any of the preceding s then the construction can now be expressed by of s production var var var atom var input or var var sel var o otherwise m an example consider the program in figure a linear tree x from input items transfers them to y so they appear original order which and then on y in builds their i l z input x x yes l if nu x goto n no y cons x hd y i x goto m n zz yes figure the productions those for obtained z from this are l i fx i fy fx fx fx fx lx o fx fx fx i fx fy fy fy fy fy fy fy i fy fx fx fx fx fx i fx fy fy fy fy fy fy i fy simplifying this by productions and renaming we get chains of a b fx c fy al i a ab ii cl i a d the solutions are d o d note the right of each variable is clearly evident or theorem if g tree there is grammar g is an extended an ordinary regular with lg lg regular tree proof method transitive we give the construction of derived rules to be the smallest o relation such that which define reflexive uses the relation a a x implies a x b a b sel sel m c ti tm imply a wt provided tl tm all derive nonempty sets of terminal trees now define g where pr pl abs c p and essentially reynolds by we omit the proof the same theorem was proved in another more complex method that lg lg lg d so the example elimination of productions the right proceeds as follows with selectors on a and c j follow productions from the b a follows from b b b and ab oa d o follows ab o from d and the revised grammar has productions b oa i a oa do and it is easily solution as the right this method to the original checked that it has the same grammar with selectors on the does not yield a perfect problem for two reasons solution first the flow analysis and each variable makes some information method associates a set of values analysis possible as in the following with each node while this it can lose example x l x if goto l the values x may actually have at l are complete binary trees of heights however the method above leads to productions the ao i aa a which have all binary the second reason concerning and l in ignored in constructing conjecture that these the of the increase the complexity trees as solution is the restrictions the flow equations which were the productions we restrictions do not solutions although they may of obtaining them v relating allocation the tree grammars to storage a simple and fairly efficient implementation of sl may be organized as follows each internal node is represented by a record with fields one for each selector in sel ln tree is identified by a pointer any to the record for its root node each program variable is bound to a word contained in a fixed runtime location whose content is a pointer to the root record of its current value or the value itself if atomic thus an assignment x y merely copies one root word into another x ys copies the s field of ys root record into xs root word and x ym makes the root word of x point to a newly allocated record whose fields s l sm are initialized to the values of y i ym his method involves only a bounded amount of work for each statement type and provides maximal natural storage sharing ie all that can be achieved without the use of a hashing cons there are some obvious common to languages which are amenable to data flow analysis we now briefly discuss those which can be handled by use of the tree grammars just presented the main tool used is the fact that familiar and regular grammar algorithms generalize directly to tree grammars in particular is easily decidable let x be a variable and consider vx u fix our upper bound on the set of i pl values x a assume during execution a if vx contains at most one shape other than a fixed location may be assigned to the root record of x so its may be addressed directly without need for the root word b if vx is finite a storage area for x may be allocated statically for x before execution in storage this area need not activities c now consider vx if this is empty no record within a value of x needs to contain an field let statement x ys be by program point i if o or j is in a runtime error is possible if a runtime error will definitely occur more will be said about optimization like programs in the second part of this particularly concerning storage reference counts and garbage collection use of of by and the vi elimination collection of reference counts and garbage in the remainder of this paper we assume an implementation like section in addition that described in the last we extend the language to a more powerful version called by the addition of selective updating in a manner similar to and in lisp two standard methods for storage management are the use of reference counts and garbage collection garbage collection is the more powerful method but the collection process is quite expensive and in its classical forms to the computation especially in interactive and contexts when cyclic data structures cannot occur as in sl the method of reference counting may be used however this method requires both space overhead to store the counts and time to update them in this part of the paper we describe a method to reduce both zero by a types of overhead program analysis often to the analysis constructs finite approximations to the actual runtime data structures which may occur and is guaranteed to detect cyclic structures and nodes with reference counts greater than one they can possibly exist in this way runtime if data cells may be put into three classes those whose reference counts never one these may be returned to free storage as soon as pointers to them are no reference counts need be maintained those which may not appear in cycles but whose reference counts may one these may be allocated with reference count fields which are maintained during execution other cells which may appear in cycles the overhead of reference counts may be avoided at the of using garbage collection in it is observed that only to of cells are ever pointed to more than once so this optimization should result in substantial further our method for detecting opportunities for optimization appears to be significantly more general than that of before to give an alternate semantics for sl based on the ideas sketched above and presenting methods for analyzing its storage allocation properties we shall extend the language to include selective updating in a manner which models the functions and in lisp and assignment to records with pointers in languages such as pascal and the new operation is written as xs y and its intended effect is to replace the edge from the root of x by an edge leading to the root node of y this selective updating operation makes it possible to create cyclic structures as shown in figure where performing x on the structure in a results in that shown in b thus the language with selective updating is more powerful than without it we call the language with selective updating selective updating structure language x aa bc fx a b figure we now give a semantics for which within it an alternate semantics sl equivalent to that in section ii and based the implementation ideas in section v to do we first the store to consist of all directed graphs of the following sort for on this each internal node has one son for each selector in sel each leaf is labeled the null tree with an atom or l each variable one node in var labels one and only each node is accessible labeled node from a each node is a member of a universal node of nodes set for example corresponding the graph in figure a is a store to the values of x y and z in b in the example rightmost node the effect function in figure a node is the upper of the assignment statement is a assign store defined below in general modifying u unless s aborts following table from variables new a s as all is found by described in the nodes which are are removed from the form of s var atom add a new leaf node atom node move var labeled to the new var var var o move var to label node var make var o il a new node n and move to label it for m add an edge from n to node var var sel if node var has an sel descendant then move n to node n else is undefined var sel var if node from it then replace leading to has an sel edge it by an sel edge node is execution is aborted in exactly the same situations as in the semantics of sl given in section ii let o be an acyclic store graph and x a variable in a define tree to be the tree which results from performing node splitting on the directed acyclic graph all nodes and edges reachable from node xu for example if o is shown in figure a then tree is the tree labeled z shown in figure b theorem let assign be any sl assignment statement or equivalently and assignment statement other than a selective updating operation and a an acyclic store with variables xl xn then xl tree x n xn a a b figure the following auxiliary the semantic definition function is used in node var store node vu the node in u labeled v where a bl an s bn denotes the finite al satisfying bi for i n thus the two languages are semantically equivalent if we ignore the selective updating operation we omit the proof of this since it just amounts to showing that the usual lisp implementation strategy is valid define a node in a store graph to be shared if there are two or more distinct paths from variables or possibly from the same variable to the node and to be if it is contained within a cycle in the graph vii modeling the sharing semantics as is usual in flow analysis our approach is to define a system which is finite and whose solution in effect symbolically executes the program in parallel over all possible execution paths the structures just described may grow in two ways in depth ie path length from a variable to a leaf and there may be an unbounded number of garbage nodes to this we discard nodes and consider only bounded approximations to the graphs annotated with sharing and circularity information to aid in the reference count analysis define a directed graph to be if each node is accessible from a node labeled with a variable by a path of length s k then the flow analysis lattice share is the set of all sets of directed graphs of the following form each variable x c var labels one node denoted node x and each node may be labeled by one or more variables there are two sorts of nodes unknown labeled and known not labeled an unknown node represents a set of nodes whose internal structure is not represented in the approximation unknown nodes may be labeled with either of the following and possibly a variable s indicating that the unknown structure represented by the node may contain sharing c indicating structure that the unknown may contain a cycle each leaf is labeled with o indicating an atom indicating the null tree or and possibly s or c each known node has one outgoing edge sel for each sel sel each unknown node may have any number of outgoing dotted edges ­ each going to a different node the lattice operations are set union join and intersection meet given a fixed set of selectors and a fixed set of variables the number of graphs with no nodes is clearly finite as an example of a graph consider the limited graph in figure a node in a share graph is defined to be shared if there are two or more distinct paths from variables or possibly the same variable to the node or if it is accessible from a node labeled s or if it is itself labeled c it is if it is included in a cycle or labeled c xk a z w o i s i c s o y figure constructing the data flow equations our point i a set of modelling a store execution paths of figure the equations is to associate with each program graphs fi each graph resulting from one or more consider the flowchart segments are formed as follows where d the functions clean and next are p defined below form of s equation assignment fj u ed if atom var fj yes c d i node var is labeled o or c d i node var is unknown or is known and not labeled o f j yes d i node var is labeled l or f var d i node var is unknown or is known and not labeled l if var var f j yes d i var node var and node var are both labeled labeled o or both l other fj d fi u u to define and next let set of all sets of graphs satisfying be the conditions through of the definition of share however they need not be the are now next assign share and share the idea is that next applies the statement and clean makes the resulting graphs the function node can be carried over to the graphs in share and naturally we now explain how to compute next s for an assignment statement s and set of graphs first if e share s will normally consist of one graph obtained by modifying as described in the table below however net s will be empty if s aborts and may have more than one element if a variable is moved to a of an unknown node form of s next s var atom or var add a new leaf labeled o to move var to the new node var var move to label node var var o make a new node n and move to label it for i m add an sel i edge from n to node vari var sel var ease node has an sel edge replace leading it by an sel edge to node var node var is labeled o or next node is unknown add an edge ­ from node var if not present var var sel case node var has an sel n move node var var to node is known but n has label o or next s node var is unknown with immediate descendants nl n next r where r are with var moved node var nl respectively to nodes n r in figure we illustrate next s for several statements s where contains only the single limited graph of figure the purpose of the function clean is to restore the next s a subgraph we first which character of the graphs in define for any consists of all nodes n which are not accessible from any node by a path of length k or less together with all edges in between such nodes a x o i i y l x zx c s y y xc z w o i c s i a xc z o i o c s a xu z w o o c s o figure now clean resulting from transformation is the set of applying the to each graph y in o graphs remove all nodes which are from variables partition ti into components cc connected for each ci do if ci contains at least one edge then c into i node labeled c a single unknown let the resulting graph be called partition fi into components c c connected each c do f c contains more than one node then node n c into a single unknown if c contains a node labeled then label with c c else if c contains a shared node or a node labeled then label with s s the coalescing operation above is done merging the nodes of c into a single node n preserving incoming and outgoing edges and variable labels within c more precisely by create a new node label it with and with all variables labeling nodes in c to n any edge coming into c to point replace any edge coming out of c by a dotted edge from to the same endpoint provided such an edge does not already exist delete all nodes of c and edges between them as an example of clean suppose we start with the graph in figure a steps through result in the graphs in figure b through f assuming the resulting graph is to be limited note that our comments about backward flow analysis in section iii apply here as well ix solution of the equations note that share is finite it is not hard to see that f is monotonic so the minimal fixed point solution may be obtained by regular or iteration as an example of the kind of information that can be obtained from the equations suppose no node accessible from node xo in any share graph in the solution is in a cycle or labeled c then no node accessible from x in any computation can be part of a cycle so the descendants of x need not be by garbage collection similar remarks apply to sharing a node can be deallocated as soon as any reference to it is a xy b y c d figure xy e xz c s i az f figure theorems establishing these facts will be proved in the next section first we give an example of the flow equations and their solution using again the program in figure for purposes we this program a bit and insert a few program points to obtain the flowchart and forward flow equations in figure xy f f f ux fl f f fl u f f x y f f x f figure to solve the equations we proceed by the method of iterations f to stability and then in turn f f and f until the whole system the solution for f and f with k is indicated by the table in figure no shared or cyclic structures occur so the simplest storage allocation method may be used further x one cell which can be used immediately by the y z ot l ix yes zo no null xj no y x xy xy x y figure x theorems on detection cf sharing and cycles we show in this section that the share model is capable of detecting any sharing or which may occur in the data structures of a program of course since the model is finite and based on conservative assumptions it may also indicate the possibility of sharing or where none occurs in the actual program to state the results we first need to define a compatibility relation between store and share graphs which will intuitive notion that if a store o results from a computation leading to program point i then the set of share graphs fi contains a graph representing for example for the store graph in figure o a the share graph in b is compatible while that in c is not xx y a ba y o s b d a b m c figure let be the set of nodes in graph u by definition an from o to is any function r nodes such that xu node x for all x c var let there be an edge in u from n to n with selector label sel then a if rn labeled is edge there is an rn to b if rn is unknown either rn or there is a dotted edge from rn to further o and are compatible written o iff there is an admissible r from u to node correspondence if node n is shared in a then either is shared in t or rn is accessible from a node labeled s or c rn in i if node n is contained in a cycle in u then either in is contained in a cycle in y or rn is labeled c thus it is easy to see that the graph in figure c is not compatible with that in figure a because among other reasons of node xa is node while the tail descendant the tail descendant of node x is not node y we next show that the transition functions and compatibility theorem let assign be an assignment statement u a store graph and a share graph such that u then there exists gi proof the proof omitted for brevity compares the effects of next and clean on g and by an enumeration of cases to show that the diagram in figure in the diagram o r is te admissible node correspondence given by u y y is a graph in assign y and r and r are appropriate admissible node cl to relate the above theorem to the identification of situations where storage management simpler and more efficient collection can be used we first define than graph x for a variable x and a share graph t to be the of t all nodes reachable from node xy and all edges between them we then have the two l by r by r e corollary if graph x contains no shared nodes for all f fi for program points i then variable x requires neither reference counting nor garbage collection ie any node reachable from the root of x may be deallocated immediately when a reference to it is removed proof by the theorem all sharing which can occur in the store semantics is recognized in te compatible share graphs if no node in graph xy is ever shared in any possible then nodes reachable from x can never be shared cl corollary if graph xt contains no cyclic nodes for all fi for all i then variable requires no collection ie management storage for nodes reachable from the root of x may be done by reference counting x of proof corollary similar d to that for preceding the above results are global in two respects they concern the behavior of a variable throughout the execution of a program and concern all nodes reachable from it the information present in the fi is sufficient however to obtain results which are local in both this could be applied to make very efficient use of a dynamic storage management system in which cells are divided into three types those which are immediately deallocated those which are reference counted and those which are garbage collected then a particular cell which can be identified as never being shared in the future can be allocated as the first type one which may be shared but will never be cyclic as the second type and the remainder as the last type we leave the detailed development and analysis of this approach to later work it should be noted in closing that has studied the situation in which reference counting is an appropriate method for dynamic storage management his indicate that our intended use is an appropriate one references g jr list processing time on a serial computer cacm vol no pp in real j m garbage collector overhead to compile time cacm vol no pp w s tree generating regular systems and control vol pp j r regular canonical systems f math vol pp d w and c c an empirical study of list structure in lisp cacm vol no pp cousot and cousot automatic synthesis of optimal invariant assertions mathematical foundations proc acm symp on intel and prog lang notices vol no august pp cousot and cousot static determination of dynamic properties of generalized type unions sigplan notices vol no march pp j tree automata and tree grammars report fn department of computer science university of denmark the mathematical of contextfree languages new york goto e and associative algorithms in an extended lisp university of may hoare c a r recursive data structures j comp and sys vol no pp jones n d and s s muchnick binding time optimization in programming languages some toward the design of an ideal language proc rd acm sigplan symp on lang january pp kaplan relational data flow analysis technical report dept of and comp sci princeton university april revised kaplan and j d unman a general scheme for the automatic inference of variable types conf record of th acm symp on lang az january pp robert and christopher a of programming language and hall london press john new york reynolds john c automatic computation of data set definitions of august pp b b schwartz j t optimization of very high level languages i value transmission and its computer languages vol pp e denotational the approach language mit press semantics to cambridge ma j tree automata an informal survey in aho cd in the theory of computing prenticehall pp 
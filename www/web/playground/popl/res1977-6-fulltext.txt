expression continuity and the formal of algorithms institute new and j t schwartz science department of mathematical york university sciences abstract this paper the technique of strength reduction or formal in a set theoretic context as recently introduced by we give pragmatic rules for the recognition and treatment of reasonably general cases in which the optimization is applicable and consider some of the problems which arise in actually to this optimization as part of a compiling system background development of very high level languages depends in part on our ability to recognize common major aspects of programming style as resulting from the application of some standard technique of program improvement to an underlying program prototype a technique of program improvement that we are able to as general can become the basis for a general optimization method and once this method is in hand we can safely write programs in relatively simple forms since their more complex optimized forms will be seen as obvious improvements derivable mechanically or from these simple forms an interesting new high level optimization of this form has recently been described by el this optimization was applied by to his proposed language e but his ideas carry over easily to other set theoretic languages such as setl optimization technique which he calls iterator inversion and which we shall prefer to call formal generalizes the classical method of reduction in operator strength for which see the basic formal idea of this technique can be put as follows suppose that an expression c xn will be used repeatedly in a program region r but that its calculation cannot be moved outside r because its parameters xl x n each entry to r by calculating it are modified before entry within and r if we make keep c available c available on within r by it each time one of its parameters is modified then we may be able to avoid all full of c within r for this approach to be reasonable there must be some way of c more easily after its parameters are modified than by calculating c each time it is required for this to be the case we are likely to require two conditions to be satisfied which we may describe as follows a within r all changes xj xn to the parameters xj should all be minor or small b for each such assignment there should exist an update identity x l xn xn xn xn work by nsf under grant which allows the new value f of f to be calculated from its old value fold by an easy calculation that the expression f u xl f is continuous in its if this is the relative case to then we the modifications occurring within r the application of this idea in the settheoretic setting was by and has been pushed further by and unman fl who made the interesting observation that formal in a settheoretic setting could actually improve the asymptotic behavior of an algorithm and that this fact be used to develop a theoretical characterization of the situations in which this applied in the discussion which follows we shall idea in a less formal sense than and unman to state pragmatic rules for the discovery and treatment of reasonably general cases in which formal can be applied initial examples in setl the computations s u s x and s s x respectively add and delete the value of the element x from the set s both operations change s only slightly similarly if s and t are sets and the number of elements of a a is much smaller than s then modifications of the form s u s t a represent slight changes to s if f is a set of pairs used as a mapping then the operation fx u z which replaces all pairs whose first element is x by the pair xz causes f to change slightly if f is a set of used as a mapping then the indexed connected assignment region r all xn z changes to variables f only which slightly are sets if in a strongly or mappings are slight modifications of the kind just described then these variables can be called induction variables within the region r examples of setl expressions continuous in all of their parameters st set intersection s t and set difference s t for example are set union if we consider expression s t then if s differential change the value c of can be by executing the corresponding code c c a t or similarly if t a small change we can update c by performing c u c a or c c a s as has expressions involving provide more interesting examples of this of continuity the setl expression q which computes the set of all values of the set s such that the boolean valued subexpression fx q holds is a example this expression is continuous in s and f but in q if s is slightly by s s f a then c can be updated by executing which represents a small change c u c t x to c when a j fx q f is changed by executing the indexed assignment c if u z then yo e s then c can be updated c if fy by executing q then yo if z q then yo else else just before the assignment z the st formal parameters of set theoretical expressions continuous in all of their we now formulate a few general rules concerning the formal of set theoretical expressions continuous in all of their free parameters it must be observed that none of the transformations which we are studying can safely be applied to expres sions containing operations which cause side effects used for which reason we shall always assume such operations to be absent in the expressions we treat we also assume that is applied prior to any attempt to optimize by formal so that object types are known during the analysis of a program for reduction consider the settheoretic expression kx in which kx is any subexpression containing only free occurrences of the bound variable x and containing no free instance of the set s suppose that the expression is used in a strongly connected region r and that the following conditions hold i the boolean valued subexpression kx contains m free occurrences of an nary mapping f in which each such occurrence has at least parameter expression involving x the bound variable of the set former all other free variables occurring in k are loop invariant slight ii f and modifications s are induction of the form variables of r ie inside r s is only changed s u s fa where a is a small set in comparison by with s and f is only changed by indexed assignments of the form then we can formally yn the expression z in the region r let c be a variable to be associated with the value of the set former expres sion l we will say that c is available on exit from a program point p if c is equal to the value which the expression would have if evaluated immediately after the statement at p is executed c is available on to d if c is available on exit from all predecessor points of p if c is available to p and if c is not available on exit from p which will happen when execution of the state ment at p changes the value of a parameter upon which the value of expression depends then we say that c is at p to the expression within a strongly connected region r we begin by making c u it available into on to r initialization this is block done then by inserting at each the assignment point p inside r where the value of the induction variables s or f can change the value of c which could be at p will be updated by inserting appropriate slight modifications c u c i cl where exit from p we now cl is a small set proceed systematically relative to c this keeps to discuss continuity c available properties after of the expression and associated update rules for c for two cases illustrated by examples f which result from in section an indexed above assignment small changes in the set s and changes to rule either before or after each occurrence in r of a small change to s s z s a we can insert the differential update operation which preserves the value c u c i x of in c a i kx rule suppose that the boolean of the nary mapping symbol of f appear in r different terms subexpression f suppose k of also that contains m free these m occurrences fp where bound lx p variable represents the dn x jth parameter expression of the set former of the ith term x involving x which then at each point is the p in r in which the mapping f is following program transformation relative position p changed slightly by an indexed assignment code yn code make the p p u x c s px l md w y k c u c qr p p it can be shown that rule f u value is fy yn z cc is a corollary of rule to see this consider e let pi be the mapping whose domain is s and l then for any yl yn we the set have yi x x vn if s changes by deletion of pi yl yn then df changes by of the yl yn moreover if s is modified b deletion pi y yn then the yl yn is removed from the domain of all the f terms occurring in l next we observe that if c is available on to p ie is available just prior to the modification y yn r df just to f by the before point indexed assignment p then the statement yn u z and yn z if does not change in any of the occurrences of fin l consequently c is not by assignment yn z and hence it remains available suppose now that in expression c is available on to the program point p then we could r u il p y c in proceed as follows yn with rule at p at p ut s equal to the set delete s from s at p update at pl add s back to s and at p use rule again to update c this would give us the following code p ps u ss i px m y q yi yn p c u c x e s i kx in this p p p code fy yn s ss c is not by the statement yn z hence if c is available on to p then by rule we know that c remains available on exit from p and now finally since in the value of the set s is the same before d as after pl and because s is not used between p and pi the code is equivalent to that shown in rule the assumption that at least one of the parameters in each f term in k involves x the bound variable of the set former will usually cause the set s to be small in comparison with s then by the continuity properties stated in rule we can conclude that the modification to c appearing in rule is small compared with the set c itself the code generated by rule can be improved by eliminating in the expression s kx that s il can be rewritten ri where r as u which rr x appears at are disjoint i kx locations sets suppose p and pl suppose then x gs i kx also that in each set we know x g ri i kx kx transformed by elimination of redundant operations into an equivalent but expression then it may be to work with the partition ri of s instead of s and to rewrite x c s i kx as as an of this observe lx g ri i that if we let ri u x g s l rr the term rk i a partition x q y q yn where ro of s moreover on the set ri we can replace which appears in the expression k at location p of the code generated by rule by yn cf above this can lead to a version of line p of which is relatively easy to evaluate as an example of the redundancy elimination method just outlined consider the following example c x l q l suppose that the mapping f is changed slightly by an indexed assignment z which occurs at a program point p then to update the value of u we proceed as follows first a partition ri r r is computed note that this is not precisely the partition described above rather it arises from that partition by a further formal transformation which for simplicity we omit observe that this partition contains three sets because only three different f terms occur in the boolean subexpression in these are fx and l since fx is the only f term of whose parameter expression parameter involves part of no f term we put r xs ix involves fx we set since the and similarly u x we put i fx the code generated u x e to update is then as follows c u c r x x g x e sr u ri i i r i yo xc r i x r u z c u c x r i i q yo fl xr i fz as noted by the z method xc of formal which has been described can be extended in a useful way to apply to various setl expressions that implicitly contain set among these are the forall iterator ie vx c block the existential and universal quantifiers ie i kx and i kx and the compound operator ie x g s i kx ex to formally these expressions we rewrite them by replacing the implicit set former x s i kx which they contain with x e u e s i the set former thus can then be rules and let us now consider more the setl compound operation an example c x g cl ex of which x g c ex the value ex in general x cl ex means for the general case in which the binary operation has an appropriate i xn inverse inverse eg arithmetic binary with as its inverse we note that is continuous relative to slight changes in c ie before an occurrence of the code c u cf a cl can be updated by an appropriate change either c cl a ­ c ex or applying the to cl of tion form cl u cl inverse heuristic rule continuous and c of yields update ac functions identities ex of continuous for a more functions are general compound continuous opera in order to formally c x c s i kx ex the expression in a strongly connected region r we require all the conditions imposed on to hold and also require that neither the set s nor the nary mapping symbol f occurring in k should appear in the sion e of if all available on initialization block to the induction for that parallel these conditions are met we to r this is accomplished by inserting next within r at each point p where variables s or f we can apply the rules and by first the assignment c can be following continuity making into by rules it rs rule be maintained where s is modified in c by executing in r by the code s u s a the value of can c c x e a s kx ex or c c inverse x c a respectively a similar rule analogous to rule can be stated to cover the case of changes to f these rules imply continuity properties for many other high level setl operations the counting operation applied to a set former ie x g s i kx can be treated as xs i kx when side effects of the existential and universal quantifiers can be ignored then the corresponding setl forms x s i kx and fx s kx can be rewritten as x s i kx o and mo respectively set inclusion the predicate r s is continuous in both s and r since in setl r s can be handled as x s i x r o of containing parameters on which they most setl expressions will not be continuous in all the parameters on which they depend for is continuous example the set former c in s and f but it is relative to changes in q suppose that the expression occurs in a strongly connected region r and suppose also that all changes to s and f are slight within that q can take inside r the computation following general form r then can scheme if we know be removed the set d of all q values from r according to the a define a map cq xs i q q for all values q on to r b whenever differential changes to s or f occur in r modify according to rules and cf section for all values s s a we can perform the following update code each stored q d eg q set ca after q cq u cq f x a i q c whenever q changes in r nothing more is needed d replace all three major computations problems can in r by cq easily make this approach infeasible a storage b updating modified of all the sets cq may be too expensive all the sets cq when a parameter may more time than is saved upon which by avoiding c depends continuous the calculation of y is c c storage nevertheless of the these set may be too expensive problems can be overcome in cases in which we know that when an expression e must be stored as a map the map will be continuous relative to differential changes in the continuity parameters of e ie update operations are only required a small part of the domain of the map fortunately this property holds for a few special cases of common occurrence in setl programs one such example is if on c to r cl is stored as a map defined on dg and if s and f are induction variables of r then can be after the occurrence of s s a we can invoke the update rule vx a i fx whenever the indexed cl fx cl fx x assignment z occurs the following code can be executed if x c s then u z xo if x o g s then xo example above the treatment of a somewhat class of expressions that can often be within this class we consider the set where that i ql qt are free variables k of is a subexpression qt upon which only involving c depends x parameters upon which we assume depends and maps fi upon which c can depend in k all have parameters depending on x k of only involving the parameters ql qt on which but whose occurrences is assumed to be a subexpression c depends and also the maps fi we assume that expressions time or are computed dynamically and are able d are either qt on to by substituting a new free variable b for at then and keep the value the preceding c cb available results in for every an interesting va way to b a class by available at compile r we can simplify we compute db of set c x e s i fx ccl where the free variable q is a set recall from section that is continuous relative to small in s and relative to indexed assignments to f if a is changed by a computation q u q t cl where al a then the corresponding update correction c u c f x s i fx c ql will often represent a small change to c however because the set former in still requires an iteration over s this update computation will often be too expensive to allow of for this reason it is appropriate in handling to use the identity the sets c x g s i fx w b then appear can be treated by the methods sketched earlier in the present section which require that we store a map cb for all b in an appropriate domain set db then the operation can be replaced by the less expensive code c u c t cb set involving boolean valued subexpressions involving comparison operations such as can sometimes be treated c as special cases a of to see this let m be the largest q value that needs to be considered and let m be the minimum value of fx x g s over all f and s that can appear putting sa b m b q we see that is equivalent to x s i fx sq if q changes slightly by q q t ql then sq changes also slightly by sq u sq b q b q al or by sq u sq b thus to update cl we can simply execute lo c u c q b q al cb or as appropriate u c qc ql b q cb another class of special cases derives from c x s c fx a set former which despite its close to must be handled very differently whereas is continuous in all of its parameters is in q applying thus we must save the value rule of the last section of c in a map cq to we derive defined for all values the update computation q cq u cq x a i q fx when wish d is small q can to extend the iteration be expected not to be over all of da but when is large we may only over the smaller set q fx which can be rewritten equivalently as a few preliminary c u remarks on q to implement formal rules sketched in the preceding pages we will need to perform the following steps information develop an algorithm which including use definition given chains parsed type setl code analysis p plus possible additional declarations describing the relative sizes of sets and maps etc finds all the expressions e xn in p which can be formally formalize rules as we to do in sections forms of setl expressions and for updating all basic program the transformations of parsed code p which apply in several possible ways one of which is not to apply them at all these update these rules transformations must in effect match setl expressions to basic elementary patterns and must then carry out appropriate symbolic to avoid an expression with cases e ix xn only we suggest if either the following heuristic a it is continuous in all the parameters changed within some strongly connected region r or b it is in some parameters which vary within r but the map need ed to store its values is continuous n all the parameters x in which e is continuous ie only discussion a few values of of need to be changed when xj is a and b of the previous section since slightly recall the transformations the which are actually applied will leave behind large numbers of expressions which can be simplified very greatly by the application of constant folding dead code and redundant expression elimination etc it is important to incorporate these optimizations into any formal scheme application select the most of the transformations of the program versions in the next section which some result of our from implementation ideas will appear implicitly in our manual optimization of a simple program how automatically can formal be ad study of an example to come to terms with the above question we consider a simple example topological sort this example is also studied in od the input assumed by this algorithm is a set s and a set of pairs sd representing an transitive relation defined on s as output it produces a tuple t in which the elements of s are in a total order consistent with the partial order sd a concise setl form of the algorithm is as follows t while ga s s t t a tuple concatenation s s ­ a end while the while loop l of contains only one expression which is not already in a most reduced form such as might be found in a table of such forms this is the existential quantifier a es i since analysis will reveal that a the bound variable of the quantifier is used within l we transform into qa c x s i s this for an attempt to the set former expression x e s i s w value we will call the elementary pattern describing is x where kx is the subexpression s q in s is already in a reduced form thus to reduce the expression we must reduce its subexpression kx to reduce kx we first rewrite it as s s s s which simplifies to s s this last transformed into y g s i y g y g s g o to reduce integer equalities expression is in turn eq o and then again we will always require into that both arguments of be reducible the parameter o of the preceding expression is elementary the second parameter k y g s of the immediately preceding equality is reducible only if the subexpression k u s is reducible we observe that k is continuous with respect to the induction variable s but not with respect to x or sp however sp is a region constant of l and hence k can be reduced to a map x depending only on the single parameter x furthermore is continuous relative to small changes executing the in s code ie at each small change s s k a k can be updated by where x a y y f a y s i x e is an auxiliary map introduced when we apply the general rules sketched in the preceding pages once this transformation has been applied to k we can go back and attempt to the expression k y which led us to consideration of k the assignments differential expression k is to but continuous cf changes to each set x with respect to changes to x and indexed rule of section with respect to thus k can be reduced to a defined over all x g s depending only on the parameter x the update rules are respectively which must be applied as follows to y when ry u f a is executed xy u y we a y and yy wc a since p no direct eliminate it by combining but only a update rules and role update rule for k which we shall call in our this leads to the we can following by the more heuristic name count here yy g x g a is as in above note that u depends w on s and that by applying the general rules of section we see that succ is to be updated after s s a by executing vb x al once count is reduced by immediate application map combining all s x q we can reduce x g si qi of rules and of section this eliminates the these transformations and applying appropriate auxiliary we the following much improved form of the topological sort t va s u y s ye s u x e s i o while qa tt a dy we as u w o y s s a vb s x a i x lo a o a very end while good optimizer might determine that the expression w al s of is just that the constant that s of is and that x e a o of is simply a dead variable inside l with these improvements also s can be eliminated a final version of the as a topological sort could be written as follows t va g s y g s y s i a x s i while la t u t a yy g if o then y else al end while this final version of the topological sort algorithm will run in a number of cycle proportional to the number of elements in the map the original form of the algorithm will require like cycles which can be much larger however the chain of symbolic transformations which leads from to is quite long and it appears that an automatic optimizer will be able to traverse this chain especially since in this case and still more so in more general cases there exist transformations whose application an automatic system would have to consider however it may be practical to design a automatic system whose user may that he a particular subexpression of a program to be in one of several possible ways this may make it possible to efficient program versions with more ad less than would be typical if the final program version had to be out in an entirely manual way work is currently in progress to produce working setl algorithms that generalize and realize the techniques sketched in the preceding pages algorithms which perform auxiliary functions such as or transformations are being studied we expect to be a major problem our goal is to implement formal as a extension of the optimized setl system currently under development at el b stl st formal has great potential for transforming very high level code to reasonably efficient low level code as a setl to setl optimization it works best when a setl the result is written of formal in a very high style in which iterative is then highly efficient operations low style setl as is pointed out in program validation can be expected to apply most easily to very high level programs since the required correctness proofs can be expected to be in this regard see the transformation remarks in ll in setl regarding a simpler experiment on al allen f john and kennedy of operator strength rice university tech rep august bl robert and david on the tation approach to programming sciences institute b burstall recursive april r m and j programs research a transformation report no system university for developing of edinburgh march cl john and kennedy for reduction of operator strength rice university technical report c john and schwartz j t programming languages and their institute of mathematical sciences new york university el level iterators and a method for automatically designing data structure dept of computer sciences and the electronic research lab univ of california february e level operations in automatic programming dept of comp sciences and the research lab university of california berkeley october fl c and unman jeffrey d variables in very high level languages proc third acm on principles of programming january kl kennedy reduction in strength using temporaries setl no march k kennedy linear function test replacement setl no may k kennedy dead computation elimination setl no august k kennedy algorithm to compute use definition chains setl no august k kennedy subsumption with constant folding setl no february ll sc experiment with optimization in setl to appear in the proceedings of the september conference on very high level languages s ed the language of j in relation to setl setl no january schwartz j t on programming an on the setl project i ii institute of mathematical sciences new york university schwartz j t new york comments on high level and specific suggestions concerning converge iterators and some related no b january schwartz symposium schwartz reduction j t lecture at the june informal setl j t no july programming or the notion of and the of programs to setl no a july sh tl st schwartz j j t a framework no for certain q kinds t and r no on lq of high level method of iterator inversion thomas an of program improvement transformations dept of information and computer science university of california at thomas et al february program transformation dept of information and computer science university of california at january 
programming language constructs for it is impossible obtain good axiom systems to clarke university n c abstract deduction systems for establishing partial correctness of programs may fail to be complete because of a incompleteness of the assertion language relative to the underlying interpretation or b of the assertion language to express the invariants of loops s cook has shown that if there is a complete proof system for the assertion language eg all true statements of the assertion language and if the assertion language satisfies a certain natural condition then sound and complete axiom systems for a fairly large subset of algol may be we exhibit programming language constructs for which it is impossible to obtain sound and complete sets of axioms even in this special sense of these constructs include i recursive procedures with procedure parameters in a programming language which uses static scope of identifiers and ii in a language which allows recursive procedures modifications of these constructs for which it is possible to obtain sound and complete systems of axioms are also discussed background many different have been proposed for proving programs correct of these the most widely referenced is the axiomatic approach of car hoare h the formulas in system are triples of the form p s q where s is a statement in the program ming language and p and q are predicates in the language of the first order predicate calculus the assertion language the partial correct ness formula p s q is true iff whenever p holds for the initial values of the program variables and s is executed then either s will fail to terminate or q will be satisfied by the final values of the program variables a typical rule of inference is s p p while b do s the axioms and inference rules are designed to capture the meanings of the individual state ment of the programming language proofs of correctness for programs are constructed by using these axioms together with a proof system for the assertion language what is a good axiom system one property a good system should have is soundness h d a deduction system is sound if every theorem is indeed true another property is completeness c which means that every true statement is provable from the incompleteness theorem we see that if the tion system the assertion language is and if a sufficiently rich interpretation such as theory is used for the assertion language then for any sound axiom system there will be assertions p s q which are true but not provable within the system the question is whether this incompleteness reflects some inherent complexity of the programming language constructs or whether it is due entirely to the incompleteness of the assertion language for example when dealing with the integers for any consistent proof system there will be predicates which are true of the integers but not provable within the system how can we talk about the completeness of a axiom system of its assertion language one way of this question was proposed by s cook c he gives a axiom system for a subset of algol including the while statement and procedures he then proves that if is a complete proof system for the assertion language eg all true statements of the assertion language and if the assertion guage satisfies a certain natural condition then every true partial correctness assertion will be provable g extends work to recursive procedures similar results are given by and de and by manna ma new results of this paper modern programming languages use constructs which are considerably more complicated than the while statement and one might how well axiomatic approach can be extended to handle more complicated statements in this paper we will be interested in the question of whether there are ta large university portion with of this research was completed the support of an ib research while the author was a at cornell programming languages for which it is impossible to obtain a good ie sound and complete like axiom system this question is of obvious importance in the design of programming languages whose programs can be naturally proved correct we first consider the problem of obtaining a sound and complete system of axioms for an algol like programming language which allows procedures as parameters in general it in procedure is impossible calls we prove that to obtain such a system of axioms even if we calls of the form call p p calls necessary if one wants to directly of this form are simulate the lambda calculus by parameter passing we then consider restrictions to the programming language which allow one to obtain a good axiom system the incompleteness result is obtained for a programming language with the fol features i procedures as parameters of procedure calls ii recursion iii static scope iv global variables v internal procedures all these features are found in algol na and in fact in pascal w we also show that a sound and complete axiom system can be obtained by modifying if we change any one of the above features from static scope to dynamic s scope a complete set of axioms may be obtained for i procedures with procedure parameters ii sion iv global variables and v internal procedures as parameters or if we procedures as parameters a complete system may be obtained for i procedures with procedure parameters ii recursion iii static scope and iv global variables as far as we know is the first axiomatic treatment of procedure this parameters an independent source of incompleteness is the coroutine construct if procedures are not there is a simple method for proving ness of based on the addition of aux variables ow if however procedures are recursive we show that no such simple method can give completeness these observations to languages with parallelism and sion additional programming language constructs for which it is impossible to obtain good axioms are discussed in section outline of paper the development of these results is divided into two first dealing with procedures as parameters and the second with the coroutine construct in section a formal description is given for a programming language with static scope global variables and procedures with procedure parameters this is followed by a discussion of condition modifications necessary to handle dynamic scope are also ed in section we prove that it is impossible to obtain a sound and complete axiom system for this language in sections l and we discuss re sufficient to that good hoare like axioms can be found sections and are to completeness and incompleteness results for the coroutine construct and follow the same outline as was used the paper concludes results and remaining in the first part with a discussion open problems of the paper of the a simple programming language and its semantics as in c we distinguish two logical sys involved in discussions of program assertion language l in which predicates describing a programs are described and the expression language l in which the terms forming the right hand s es of assignment ments and boolean expressions of conditionals and while statements are specified both l and le are first order languages with y is an extension of l in general the fi lb are called identifiers and are or by the positive integers the variables of la are called variable var id an interpretation i for la consists of a set d the domain of the interpretation and an assign ment of functions on d to the function symbols of we will use the notation iii for the a ity of the domain of i once an interpretation i has been specified meanings may be assigned to the variable free terms and closed let i be an interpretation formulas of l with domain le a program state is an ordered list of pairs of the form vd where each v is a variable identifier is an element of d thus a program and each d state is similar to the association list used in the tion of lisp if s is a program state and v is a variable than sv is the value with the first occurrence of v in s ly the program state obtained by adding the pair vd to the head of list s and is the program state obtained from s by deleting the first pair which contains v vars is the set of all variable identifiers appearing in s if t is a term of la with variables x x and s is a program state then we use the ts to mean t i xn likewise we may define ps where p is a formula it is frequently convenient to identify a p with the set of all program states which make p true ie th the set if this identification is then false will correspond to the empty state set and true will correspond to the set of all program states we consider a simple programming language which allows assignment procedure call while compound and block statements procedure tions have the form k end where q is the name of the procedure is the list of formal variable parameters is the list of formal procedure parameters and k is the body of the procedure a procedure call has the form call qa where is the list of actual variable parameters and is the list of actual procedure parameters to simplify the treatment of we restrict the entries in z to be simple program identifiers we further require that procedure names be declared before they appear in procedure calls an environment e is a finite set of procedure declarations which does not contain two different declarations with the same name if m is a declaration then is the environment obtained from e by first deleting all procedure declarations which have the same name as it and then adding if s is a statement and e is an environment then is the set of variables which are global to s or to some in e meanings of statements are specified by a meaning statement function mm associates i s state s and environment with a e a new state s intuitively s is the state resulting if s is executed with initial state s and initial ment e the definition of m is given operationally in a rather nonstandard manner which makes use of renaming this type of definition allows static scope of identifiers without the introduction of closures to handle procedures the definition of is by cases on s is begin new x b end where i is the index b xl x of the end es x first program not appearing in s e or vars and s a is a special domain element which is used as the initial value of program identifiers s is begin k end b end b ql end es where i is the index of the first procedure identifier not in b or e and k end q s is begin bl b end b end es s is begin ends s is x its s is if otherwise s is bb es if s otherwise s is call q mk xp if k length length and length undefined otherwise sometimes it will be easier to computation sequences than with the m directly a computation sequence work with definition c of the of form gives the environment and program state during the i step in the computation of since the rules for generating sequences may be obtained in a straight forward manner from the definition of m they will not be included here the meaning function m may be easily modified to give dynamic scope of identifiers with dynamic scope when an is referenced the most recently declared active copy of the identifier is used this will occur with our model if we omit the renaming of variables which is used in clauses and in the definition of m thus for example new x b end b where unless explicitly stated we will always assume static scope of identifiers in this paper partial correctness assertions will have the form p s qe where s is a program p and q are formulas of la and e is an environment definition p s qe to i s e iff is true with respect v if is a set of partial correctness assertions and every assertion in r is true with respect to i then we to discuss the completeness of an axiom system independently of its assertion language we introduce notion of definition l is expressive l and i iff for al s q e there with respect is a formula to of l which expresses the weakest precondition note that is undefined we could have alternatively or used the strongest post condition if la is expressive with respect to le and i then invariants of while loops and recursive will be expressible by formulas of la t every choice of l l and i gives cook in the case where the assertion and expression languages are both the language of presburger arithmetic wand wa gives another example of the same more realistic choices of l l and i do give both the full language of number and i is an interpretation in which the symbols of number theory their usual meanings then l is expressive with respect to le and i also domain of i is finite is lemma if l a le are first order languages with equality and the domain of i is finite then la is expressive with respect to le and i if h is a axiom system and t is a proof system for the assertion language la relative to i then a proof in the system ht will consist of a sequence of partial correctness assertions p s qe and formulas of la each of which is either an axiom of h or t or follows from previous formulas by a rule of inference of h or t if p a qe occurs as a line in such a proof then we write f tp s qe in a similar manner we may define and a are sets of partial correctness r ta x where assertions r definition a axiom system h for a programming in the sense language of cook pl is sound iff for all and complete la le and i sh that a is expressive and i and b t is a complete with respect to i with proof system to l e for l a fp s tp s qe recursive procedures with procedure in this section we prove parameters theorem it is impossible to obtain a system of axioms h which is sound and complete in the sense of cook for a programming language which allows i procedures as parameters of procedure calls ii recursion iii static scope iv global variables v internal procedures remark in section we show that it is possible to obtain a sound complete system of axioms by modifying any one of the above features to obtain the incompleteness result only identifiers are needed as parameters of procedure calls the incompleteness proof allows in addition variable parameters which are passed by direct syntactic in order to prove the theorem we need the following lemma lemma the halting problem is undecidable for programs in a programming language with features i v above for all finite inter i with the proof of the lemma uses a modification of a result of jones and muchnick j note that the lemma is not true for flowchart schemes or while schemes in each of these cases if the program may be viewed as a finite state machine and we may test for termination at least by the execution sequence of the program to see if any program state is repeated in the case of recursion one might expect that the program could be viewed as a type of pushdown automaton for which the halting problem is decidable this is not the case if we allow procedures as parameters the static scope rule which says that procedure calls are in the environment of the procedure call allows the program to access values normally in the runtime stack without first the top of the stack formally we show that it is possible to simulate a queue machine which has three types of instructions a the value of x to the of the queue b the front entry from the queue and place in x and c if xy then go to branch the halting problem for queue machines is since undecidable the desired result follows the queue is represented by the successive of a recursive procedure with the queue entries being maintained as values of the variable top which is local to thus an addition accomplished to the by having of the queue may be call itself from the front of the queue are more complicated also contains a local procedure up which is passed as a parameter during the recursive call which takes place when an entry is added to the of the queue in ing an entry from the front of the queue this parameter is used to return control to previous of and the values of top local to those the first entry in the queue will be indicated by marking eg the appropriate copy of top suppose that the queue machine program to be simulated is given by then the simulation program section has the form in the language of begin new top dummy progress declaration of local procedure up while do begin if prog then inst if then inst else else if end end end prog prog then else null the variable prog counter serves as an instruction counter for the being simulated initially it is the variable progress is used to indicate when control should be returned to the previous activation of the procedure the procedure loop diverges for all values of its parameters it will be called when an attempt is made to remove an entry from the empty queue declarations for prog counter loop and the program variables for he queue machine are omitted from the outline of the simulation program the appropriate encoding for queue machine instructions is given by cases a if is j begin a then replace by if prog prog then else end ­ note that we are assuming that the first instruction in any queue tion also prog program will be an statements of the form prog counter may be eliminated by a fixed number representation of new variables to hold of prog counter the binary b if is begin x then replace by call back prog counter end ­ if the queue is not to the local procedure activation of prog empty will up declared on from correspond in the previous the call on back the first of top in the second parameter back ia called up below parameter x will first activation of back up from within up contain the value of the is only used when see of c if is if then go to n replace m by begin if x x else end finally we must describe the procedure up which is used by sim in determining the value of the first element element in the queue and deleting that if top first then front of end else begin call back if end of queue first end end end up after a call on up the parameter front queue will contain the value of top in activation of the parameter first of is used in marking the queue element which will be first in the queue this completes the description of the tion program we now return to the proof of the theorem suppose that there were a sound complete axiom system h for programs of the type described at the beginning of this section thus for all la le and i if a t is a complete proof system for la and i and b la is relative to l and i then lp s qe s qe this leads to a contradiction choose i to be a finite interpretation with iii observe that i may be chosen in a particularly simple manner in fact there is a decision procedure for the truth of formulas in l relative to i note also that la is expressive relative to le and i this was shown by the in section since i is finite thus both hypothesis a and b are satisfied from the definition of partial correctness we see that true s false holds iff s diverges for the initial values of its global variables by the lemma above we conclude that the set of programs s such that s false holds is not since recursively enumerable on the s s false hand o we can enumerate those programs s such that s false holds simply enumerate all possible proofs and use the decision proce for t to check applications consequence this however of the rule of is a contradiction the reader should note that the incompleteness result above holds even if procedure calls of the form call p are if such calls are allowed then the incompleteness result may be obtained without the use of explicit recursion ie for a language with features i iii iv and v only completeness results in order to obtain a sound and complete proof system we must first restrict the programming lan guage of section so that sharing is not allowed we require that whenever a procedure call of the form call q is executed in environment e all of the variables in are distinct and no in is global to the declaration of q or to any procedure in e which may be indirectly by the call on q a formal definition of sharing is given in d once sharing has been a good axiom system may be obtained modifying any one of the five features of theorem these results are summarized in figure at the end of the paper note that in the description of language we must also self application in procedure calls eg calls of the form call p this restriction may be enforced by requiring that actual procedure parameters be either formal proce parameters or names of procedures with no formal parameters such a restriction is unnecessary for languages or in order to establish the completeness results of figure sound and complete axiom systems must be given for languages due to space we will only consider language in this paper however similar axiom systems may be given for languages and the range of a statement consider the following program if yl then begin call end f call call segment end else end g yo observe that the only procedure calls which can occur during the execution of the program segment are call and call in general let so be a statement and e an environment the range call of qi with respect e for to e is which there the is computation sequence of the form call set of pairs a valid if static scope of identifiers is used the range of a statement s with respect o to environment e o may be infinite this is because of the renaming at block entry which occurs in clauses and in the definition of m if however dynamic scope is used then the range of a statement with respect to a particular environment must be finite in fact there is a simple algorithm for computing the range of a statement the range of s with respect to environment e is given by where the definition of is given by cases on s new x a a l end a end a where l end al a end a end e s ran n n t if call en where qe and k otherwise this same property of dynamic scope provides a simple algorithm for determining if the execution of a statement s in environment e will result in sharing axioms for dynamic scope the axioms and rules of inference in the proof system ds for language dynamic of may be into three classes axioms for block structure bb axioms for recursive procedures with procedure parameters rr and standard for assignment conditional while and consequence hh axioms for block structure el where u begin a end ve x u begin new x a end e i is the index of the first program not appearing in a e u or v ba u begin u begin a end k end k end a end ve bb u a u a ve provided that ee and e does not contain the declarations same name of two different procedures with the ba u a ve u begin a end ve bb u al ve v begin a end we u begin al a end we axioms for recursive procedures parameters the first axiom r is an induction allows proofs to be constructed depth of recursion r with procedure axiom which using induction on n axioms adapted stating variable call enable an induction hypothesis to be to a specific procedure call before these axioms we define what it means for a to be with respect to a procedure tion with y is definition let procedure q have k end a variable y is active respect to call q in environment e if either global to k or is active with k xp call to a call on a procedure if y is not active with q then y is said to in e from respect to be within with respect to the particular call similarly a term of the assertion language is if it contains only variables a substitution u is with respect to call provided that it is a substitution of terms for variables r u call qi uu call qp ve vu e provided and e a is with respect to call q r call q e provided that call q call q v ro is with respect to and e r provided active u call q call q that no variable in call which occurs free in t is r u call q ve u call gx provided that no variable free in u or v occurs but not in the corresponding position of is the list of formal parameters of q this axiom will not be sound if sharing is allowed in r true length p call q length length or length snd standard axioms for assignment conditional while and consequence these axioms are widely discussed in the literature and will not be stated here we illustrate the use of the above axioms by two examples the first example illustrates dynamic scope of identifiers the second example shows how procedure parameters may be handled example we prove true begin end zo new x zx xl begin new x end x call g end let e be the environment zx end zx z h call q ze r yl begin x call q end ze hl b x begin new x x call q end ze b true begin x begin new x x call q end end ze hi l b true begin new x zx end xl new x x end z call q end bb note that if dynamic scope zl static the scope correct were post used instead of condition would be example we prove z if yl then begin end f call xo yy call call end else yo end g let e be the environment containing the tions of f and g let and be the bodies of procedures f and g respectively the range of call with respect to e consists of call e and call e it is sufficient to determine the effects of call and call when executed in environment e we assume a call e and a call using these assumptions prove a and a it is straightforward to by axiom and rl we obtain a call a call e e by axiom r and l a zo line call by axiom r with the for z and x for wo we get a zo call zz w e substitution of o e line together with the desired result two applications of b gives soundness in this section axiom system ds for variables is sound proof system assertion language we outline a proof that the programs with dynamic scope of we show that if t is a for the true formulas of the la then a implies lp a qe the argument uses induction on the structure of proofs we show that each instance of an axiom is true and that if all of the hypothesis of a rule of inference are true the conclusion will be true also the only difficult case is rule of inference ri for procedure calls we assume that the hypothesis uo o un of r is true and prove that call must hold for without loss of generality also assume that the proof used to obtain from uo n we n does not involve any additional applications of axiom for procedure calls to simplify the proof we introduce a meaning function m j is defined in exactly the same manner as if s is not procedure call for procedure calls we have if the ed a k length length and is undefined otherwise thus mj with m on statements for which the maximum call does not j we also extend the definition correctness given in section depth of procedure of partial we write jp s qe iff cq in the following lemma we state of the properties of m j lemma properties of m without proof some a call fv for all u f b suppose that a where and a are partial correctness of the form p a qe formulas of a are obtained from those in r use of axiom r r implies j a v e sets of and the without c if procedure in k ve holds and the xp e with name f has declaration k end then first fve must hold also d if then there is a ko such that jk implies the proofs c and d follow directly from the definitions straightforward of m the proof of b is since use of axiom r for proce calls has been we return to the soundness proof for ri by part a of the lemma call by the hypothesis we see that call implies of r and part fi b of the lemma lin lin by part c of the lemma implies lin lin hence by induction we have for all j ui call let and suppose that then there is a ko such that fx e ss jk implies since we conclude that thus call holds for for ri interested and the we leave and reader proof of soundness is complete the proof of soundness for the rules of inference to the completeness in this section we outline a proof that the axiom system ds is complete in the sense of cook let t be a complete proof system for the true formulas of the assertion language la also that the assertion language la is expressive with respect interpretation to the expression language we prove that l and e fu s ve implies ul s ve the proof uses induction on he structure of the statement s and is a generalization of the completeness proof for recursive procedures out procedure parameters given in g due to the length of the proof we will only consider the case where s is a procedure call other cases will be left to the reader assume that uo call is true we show that uo call is provable let call call be the procedure range of call and let environment corresponding to call calls in the e be the i we assume that fi has declaration variables which ki end g that ii is the list of are active in call fi and that is l active in call the list of variables finally which are we choose to be a list of new variables in call which are we will show that is provable for all follows that i from this result is also it provable is correct to see that this observe that part of the argument by axiom r and properties of p b o eo by axiom r c call o e r by axiom r d r by properties of sp since the variables of are are in call and e call eo by rule f uo of consequence f o call is o and since the strongest post condition corresponding g call to uo and call by e it f and is still notation the rule of consequence necessary to prove let and to ii we show that the proof of will then follow for procedure calls proof of is by induction of ki using an induction hypothesis by the axiom ri on the structure which is what more general than what we need to prove lemma let k be a statement and let t and w be predicates such that t k we and such that the k with respect to e is included in call call then l t k we proof proof is by induction on the structure of k we will only consider the case where k is a declaration ie end s end if t k we then we must also have t k we where s end and e l end note that the range of k with respect to e is included within the of k with respect to e by the induction hypothesis we have that by axiom we b we see that n tt k we other cases in the to the interested reader has been established observation that ti proof of lemma are left note that once lemma follows from the lin a coroutine has the form coroutine ql q end is the execution begins in q and also terminates in q this requirement satisfies the axiom for q and q behave in identical otherwise if an exit statement is encountered in q the next statement to be executed will be the statement following last resume statement executed in q similarly the execution of a resume statement in q causes execution to be following the last exit statement executed in q if the exit resume statement occurs within a call on a recursive procedure then execution must be in the correct activation of the procedure a formal operational specification of the semantics for is given in ck if recursive procedures are a sound and complete axiom system may be obtained for the programming language of section with the addition of the coroutine construct such a system based on the addition of auxiliary ables is described in the axiom for coroutine statement is similar to the one used by cl however the strategy used to obtain completeness is different from that by auxiliary variables represent program counters and therefore have bounded magnitude rather than stacks theorem there is a axiom system h for the programming language described above including the coroutine construct but requiring that procedures be which is both sound and complete in the sense of cook and recursion we show that it is impossible to obtain a system of axioms for programming language allowing both and recursion provided that we do not assume a stronger type of than that defined in section we will argue in section that the notion of introduced in section is the natural one we will also examine the consequences of a stronger notion of let l be the cr programming language with the features described in sections and including both recursive procedures and the coroutine statement a lemma the language interpretations the halting problem l is undecidable cr i with for programs in for all finite proof machine we will by means since stack the halting machines show how to simulate a two stack program in the language problem is undecidable for l cr two the desired result will follow the simulation program will be a coroutine with one of its component routines controlling each of the two stacks each stack is represented by the successive of a recursive procedure local to one of the routines thus stack entries are maintained by a variable top local to the recursive procedure deletion from a stack is equivalent to a procedure return and additions to a stack are accomplished by recursive calls of the procedure the simulation routine is given in outline form below prog begin stack new top progress while do if prog then inst if then inst else else if end ­ then end stack call end begin stack proc new top progress while do if prog then inst if prog counter then inst else null else else if then inst else null end ­ end stack call stack end end where inst inst inst k are of the program for the two stack machine being simulated thus for example in the procedure stack we have the following cases if i push x on will be begin prog counter end if is pop x from stack begin prog end will be if inst is push x on stack or pop x from stack will simply be exit end a similar encoding inst inst for the copy of the program within procedure stack may be given theorem of l which is cr it is impossible axioms h for the sound and complete to obtain programming in the a system language sense of cook the proof is similar and will be omitted to the proof of theorem of results and open problems a number of open problems are suggested by the above results an obvious question is whether there are other ways of restricting the ming language of section so that a sound and complete set of axioms can be obtained for example from section we know that such an axiom system could be obtained simply by ing global variables ables were restricted suppose that global vari to be read only instead of entirely would it then be possible to obtain a sound and complete axiom system theoretic considerations merely show that automata the type of incompleteness argument used in this paper is not applicable in the case of and recursion the most important question seems to be whether a stronger form of might give completeness the result of section seems to require that any such notion of be powerful enough to allow assertions about the status of the runtime stacks cl suggests the use of auxiliary ables to prove properties of which involve recursion it seems likely that a of which allowed such variables would give completeness however the use of such auxiliary variables appears counter to the spirit of high level of a recursive programming languages program can involve if a proof the use of variables why not simply replace the recursive procedures themselves by stack operations the purpose of recursion in program ming languages is to free the programmer from the details of implementing recursive constructs finally we note that the technique of sections and may be applied to a number of other programming language features including a call by name with functions and global variables b unrestricted pointer variables with c unrestricted and d label these features pointer variables present variables with with difficulties with recursion al respect to program proofs and one might argue should be avoided in the design of programming languages suitable for program verification references ck clarke jr e m programming language constructs for which it is impossible to obtain good axioms technical report no ­ computer science department cornell august clarke jr e m interaction of programming language features report computer science dept university sept cl acts m program informatica proving vol pp ­ look sa semantics cal report university published and for an algol fragment computer science of to in be de and the completeness of the tion method mathematical on inductive centre dec d james mathematical semantics as a complementary definition for defined programming language constructs in et al three approaches to reliable software language design specification complementary semantics technical report computer systems research group university of dec g g a complete axiomatic system for proving assertions about recursive and programs technical report no computer science dept university of jan h hoare car an axiomatic approach computer programming cacm october pp to h hoare car procedures and parameters axiomatic approach symposium semantics of algorithmic languages e berlin pp e an h hoare car and pe consistent and complementary formal theories of the semantics of programming languages acts informatica vol pp j jones nd programs computer of in jacm and ss muchnick are hard to analyze science department november to even simple tr university be published procedures procedure with parameters recursion global variables static scope internal procedures sound and system complete axiom language inc inc inc inc inc no language no inc inc c language inc language inc no recursion no self inc inc inc global variables inc inc inc inc yes yes yes language inc language inc inc inc inc inc dynamic scope inc yes inc internal procedures not allowed yes figure theorem summary 
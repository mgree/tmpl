a compact optimizer christopher w fraser department of computer the of science abstract object code pay but are usually ad hoc and they would be easier to understand if instead of performing many ad hoc they performed a few general optimizations that give the same effect they would be easier to implement if they were and parametrized by symbolic machine descriptions this paper describes such a compact machine independent optimizer introduction of all optimizations those applied to object code are among the ad hoc instruction sets elegant treatment and research to higherlevel global optimization however ence shows the value of object code even the compiler with global optimization reduces code size by with object code optimization examining compiler design shows why to be global tion usually precedes code generation to be simple and fast code generators usually operate locally so the code generator produces perhaps locally optimal fragments but these may look when for example local code for a conditional ends with a branch so does local code for the end of a loop so a conditional at the end of a loop becomes a branch to a branch this in the code generator its case analysis since each combination of language features may admit some optimization it is better to simplify the code generator and optimize object code consequently object code optimization and its problems a this work was supported in national science foundation part by the under contract attention informal nature background little has been published on object code optimization and many early object code optimizations eg constant folding via multiplication are now performed at a higher level allen a exception is redundant load elimination the global register allocation many code generators simulate register contents to do this and to replace where possible memory references with register references final the object code generated by the optimizing compiler final collects several effective but ad hoc optimizations deleting comparisons that are unnecessary because a previous instruction set the condition code exploiting special case instructions and address chains of branches and deleting un reachable code the optimizer described below the more final by on one general tion it a little code quality for simplicity and comparisons with final quantify this tradeoff overview po is a compact optimizer given an assembly language program and a symbolic machine description po simulates pairs of cent instructions and where possible replaces them with an equivalent single instruction po makes one determine the effect of each instruction a second to reduce pairs and a third to replace each instruction with its equivalent compared with conventional object code po is organized in a simple manner and is easily by changing machine descriptions moreover it is not by ad hoc case analysis because it combines all possible adjacent pairs not just or constant computations or any other special cases compared with conventional object code pos effect can be described especially po replaces each instructions with single instruction pair of adjacent an equivalent if possible po replaces its each instruction equivalent with later sections explain and adjacent the window at the boundaries between ments of code misses many others so po is best with a highlevel global optimizer used descriptions to simulate an instruction po must know its syntax and its effect examples illustrate the notation which is based on bell and bell the example below defines one of the instructions which o the memory cell mc addressed by a register where d is a register index from an instruction field it also sets the condition code n and z bits rd o n o z the first column gives an language syntax pattern lower case pattern variables d for variable fields the corresponding pattern in the second column describes the effect of the instruction using these variables po assumes that the program counter is automatically so this be made explicit other details to the object code eg setting the carry bit are omitted for this second instruction if the z bit as implies example defines the which branches is set z pc l read po assumes that program counter pc names the machines to simplify transfers reference the all occur simultaneously to rd refers to its register so each initial value even if the instruction changes it further all instructions are fully pairs of patterns are used to define m instructions with n addressing variants each po the instruction list in order so the person who describes the machine should decide which tions are and put them first since po knows target machines only through these patterns it is by a different instruction set its few are tions built into its algorithms and machine description language for example the assumes that the machine uses a program counter and that variables once set set po cannot optimize code that uses changing device registers po assumes that one instruction is better than two adding instruction to machine descriptions would correct this finally instructions with internal loops eg block moves are hard to describe in the language above in general such assumptions are removed by extending po as it stands po a useful class of assembly language programs determining the effects of instructions initially po determines the effect of each statement in isolation so po assumes that programs do not modify themselves given an statement the a matching syntax pattern and returns the correspond ing register transfer pattern with pattern variables evaluated for example the instruction add r matches the syntax pattern add so po for s and for the register transfer pattern d in rd rd s j and obtains rr nr o o programs typically ignore some effects of some instructions for example a chain of arithmetic instructions may set and reset condition codes without ever testing them po can do a better job if such useless register transfers are removed from an instructions register transfer list for example the full effect of the instruction above includes assignments to the n and z bits if the next instruction changes n and z testing them its useful effect is just r r if the previous instruction references r indirectly the useful effect may be had by instead and removing the add instruction is a address calculation that references indirectly through a register and then increments the register the full effect requires the add t ion since does not set the condition code consequently when initially determining each tions effect po ignores effects on such dead variables to do this the initial pass the program backwards and associates with each instruction its useful effect and a list of variables that are dead from that instruction forward each instructions list is that of its lexical successor plus the variables it sets the variables it if the instruction branches its list is just the variables it sets without exam since those that are dead from the branch on depend on where dead variable elimination it jumps considering full control flow and variables is an unnecessary this simpler analysis permits the first pass over the code to eliminate most extra effects such as condition code setting as a code not to dead variable elimination at a higher level a measure of it now instructions with no effect are removed choosing instruction pairs once the initial pass determines the of each instruction po passes forward over the program and considers the combined effect of adjacent instructions where possible it replaces such pairs with a single instruction having the same effect po a pairs effect by combining their independent effects and substituting the values stored in variables in the first for instances of those variables in the second the effect of add r cm r is ignoring dead variable elimination r r n r o z r mr o n o z which simplifies to o mr o po now register effect version a single instruction transfer pattern matching it finds the of with a this r a register transfer pattern matches if it performs all register transfers and if the rest of its register transfers set dead variables eg the condition code after each replacement po up one instruction to consider the between the new tion and its predecessor and continues it is harder to combine pairs with a branch the combined that effect start of pc l l is l or just l when po combines instructions assignments to the pc as a adding relational useless assignments to the i treats special case and removing pc labels prevent the consideration of some pairs combining pairs whose second instruction is labelled changes erroneous ly the effect of programs that jump to the label to include the effect of the first instruction po must ignore such pairs and assume that all branches are to explicit labels to improve its po removes any labels it can when it a label it looks for a refer ence to it if it finds none possibly because optimization like the one above have removed them all po removes the label and tries combining the two tions that it separated this enabled po to remove the last three branches in the large example in the appendix when po removes the last reference to a label that it has passed it could back up to the instructions the label separated new optimizations are possible with the label this happens only with labels referenced after their definition however when optimizing code generated locally from a program with structured control flow loop and sub routine heads are the only such labels and po removes these so was discarded as an generality branches make extra pairs if tion branches to l po simulates instruction l and replaces it alone if possible for example an it with leaving l l ll br l has the effect ll pc l this combines to ll pc l and po replaces l with instruction note that tion may now be unreachable second instruction done l the in the second had first the ll r o the combined effect would have been z r cl pc ll r o that is po behaves as though the first branch over one extra instruction and the target were conditional on that branch and then it simulates as before however even if there were an instruction with the first effect po would not re place the first instruction because introducing the new label it requires other tion po combines only cent instructions and branch chains example the show po optimizing gram that has been used to illustrate final gives the initial produced by earlier phases of the compiler for a program that comments guide the user new to the in addition to the effects shown sets the condition code ing the value it assigns set condition code but do nothing else a pro code trees each po the pairs shown in appendix in the order given each line gives the pair reduced the resulting instruction and some explanation in most cases it replaces the pair with one equivalent three pairs are branch chain members and so only the first instruction is changed comments note these note that by simply combining adjacent po collects branch chains uses addressing modes combines and useless and unreachable code appendix gives the result final goes one step further with an optimization called it changes the last branch to go to l instead of l and eliminates the second sequence this in turn admits one last optimization the and br can be combined into a but by itself it does not make the pro gram faster only smaller hence it differs from pos tion even a window would not help could be added to po but the larger need is for a that reduces code size through more gen reordering implementation po is a line lisp program that runs in k bytes on a it was developed in three a description of the sufficient to optimize all examples in this paper is lines and was written in an po has also optimized several short and ibm programs po is experimental so it still needs documentation test ing and most of all optimization po treats only instructions each second lisp which simplified programming en algorithms programs would be stored as doublylinked lists and for a program of length n po would take on steps using lists requires so m ny extra implicit passes that po takes on steps algorithms slow po even more eg po uses linear search to find instructions in the machine description and hide some eg po doesnt know that some can be done by these problems seem simple and seem ble but further development is needed conclusions the success with po suggest the division of between the optimizer code generator and object code optimizer for example the easy of a optimizer may simplify code generators they might produce only sequences for additions and rely on a optimizer to where possible discard them in of or increment instructions experiments indicate that a very naive code generator can give good code if used with po global might also be simplified since po eliminates much unreachable code should global perhaps other global optimization should be pushed down to the object code level register transfers perhaps a global optimizer could be adapted to take a more global view of object code and so catch by pos narrow window appendix i appendix a b c d e f e g h g i j i k k m n m appendix tree with thanks to ll l l l lo l l l lll l mov mov add br add v br mov mov br add br mov br br br b ri rr r r l kr rr l r lo lll r r r r l l l l l l r call l r pi m tr r r mr o test pc l r r mr r r pc l rl call print r test r pc lll r r r r pc l call s print pc l pc l pc l pe l return pairwise optimizations on tree l mov mov br br br br r l rr lll l rr rr l l l l l l use remove label l use remove remove label lo remove label lll use remove retain remove label remove label unreachable remove label unreachable l retain without l retain without unreachable without l l lll optimized tree ll l l l mov mov mov mov bp mov mov mov br ri rr r l rp l l rr l l r call iu ms r mr o test mr r r pc l rl call g r mr increment call print pc l return r r pl references allen f e allen of optimizing in r editor and j transformations a ed tion j t sigplan notices local july bell c structures g bell ­ and a s and examples computer for code optimizing w a new strategy generation the general purpose compiler i computer m s flow analysis programs northholland of e object code s optimization january and c w cacm optimization w m cacm t a d c d f and j m neighbors the program mation information and computer science uc w s o the design of an r k c b and c m o compiler 
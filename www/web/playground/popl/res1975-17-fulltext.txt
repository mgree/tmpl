an algebraic model for string patterns f ip associates limited introduction a great deal has been learned about programming and programming during the past ten years the concepts of structure protection and having effects on the way languages are designed unfortunately from fortran to pascal and and beyond has no parallel development of string manipulation languages language abstraction however in the design are the it was the lack of powerful string manipulation tools that lead to the of snobol found et al and its descendant snobol in a great variety of string manipulation et al has problems although snobol is in the field other string manipulation languages have been developed among them and di and each of these languages provides facilities for the inserting deleting sorting testing tagging and counting of strings accordingly they share a common set of design difficulties characteristic of this class of languages the central problem in designing string manipulation languages is to of basic concepts for building composition and transformation procedures appear quite different and more than ordinary algebraic computations find a set which unfortunately no standard operations exists for string notation or accepted manipulation system of et al the difficulty arises monoid a of strings largely from the weak algebraic structure associated generated from an alphabet fit under the fundamental in particular many useful mappings from tuples of strings elements of a are not in terms of concatenation alone with the operation in a to of the second fundamental operation of manipulation is extract on this can be done by specifying he character and of the substring to be extracted or by a of pattern matching a number of formal systems exist for the specification of pattern matching processes including post systems described in and markov normal algorithms it was involving specified thesis that any algorithmic the manipulation of characters as a normal algorithm activity could be and a markov normal algorithm consists of a sequence of rules for the replacement of characters from a string stored in a register by other characters a number of variants and extensions to normal algorithms exist di but in general a rule consists of a lefthand side be replaced and a righthand specifying the substring of the register side specifying the replacement string contents that is to the of a rule is that the lefthand side or pattern be matched in some fashion against the register contents if a substring as specified by the pattern is found the rule is said to be applicable or equivalently the pattern match is said to have otherwise the pattern match has failed and the rule is if the rule is applicable the pattern the string specified by the righthand side replaces the substring matched by unfortunately markov algorithms are not in themselves a very string manipulation applications the difficulty in learning algorithm based languages is summarized in a comment by c at conference on symbol manipulation languages tool for and using markov the working i think one of the languages at least rather small number a markov algorithm about for my purposes of problems in markov algorithm type is that there is a which my mind works like we feel that this problem can to a great degree be by embedding the pattern matching and replacement features of markov algorithms into that and as far as possible enforce the concepts of structured programming one of the most problems in the design of better string manipulation languages arises in the specification of patterns snobol patterns although extremely flexible and powerful are difficult to explain and use we feel that this is due primarily to the complexity of the model used for pattern matching in in particular the programmer must be familiar with the operation of the pattern matching procedure called the including its backtracking and pattern matching heuristics has developed a theoretical model to distinguish problems inherent in snobol pattern matching from those inherent in its implementation however model is intended to aid in the design of improved snobol implementations not to and simplify the semantics of patterns and pattern matching it is to the latter problem that the algebraic model developed in this paper is addressed in section a number of definitions and notational conventions are introduced and an example the approach to the theory of mathematical semantics is presented this material is to the algebraic model for patterns and pattern matching developed in section by to familiar algebraic notions most notably that of a ring and to a theory of mathematical semantics it is that the model developed here is more logically consistent and hence simpler to understand and use correctly than the snobol model for example the notions of negative pattern and pattern allow certain classes of strings to be recognized by patterns that are both easier to read and simpler to write than their snobol counterparts as another example the recursive pattern definition mechanism in is error whereas the semantics developed here for recursive patterns is consistent and definitions and notation in this section we establish a number to the development of the algebraic of definitions and notational model for string patterns conventions strings we start by assuming the existence of some alphabet fit of atomic symbols or characters the nature of these symbols is left undefined the in the examples of this section will be on a character set of letters and symbols but there is nothing in the development preventing the symbols of the alphabet from representing other entities even entities having structure as long as that structure not used in string manipulation operations is we give the following inductive definition and a is the consists the null string is c then sa is a string total number of characters of no characters a string over a ins definition over every the length the length of strings over a alphabet of a string of the null if s is a string over s is denoted by and string is zero ie it counted sets sets with the definition the definition each set element that we shall give for patterns depends upon an extended form below of counted sets provides us with a mechanism for any information that can be encoded as a single integer of definition a counted set also called a multiset is a set with the added property that with or bag and each member of the set there is associated an integer denoting set containing the elements s respectively then s is written element is not given the multiplicity s sm with as that element is of that element if nl n if the assumed to have multiplicity s is a counted nm multiplicity one of an note or even negative s can be said sets in which that the definition of counted sets does not the possibility of we for the moment a discussion of negative however we remark that if s is not an element of a counted set s to have multiplicity zero in s ordinary sets then are simply counted all elements have multiplicity one or zero zero then we first establish a partial ordering for counted sets definition let s and t be counted element of t with nonzero multiplicity t are equal written s t if and sets then s contains t has the same or greater only if s t and s written s t multiplicity if every in s s and in developing an algebraic model for string for the following operations on counted sets patterns we will require definitions definition let c then kc is a counted set nc and is defined by be a counted set and let kc cm k be an integer we remark definition an integer that oc the empty set let c then nc be a counted set of integers k f c and let k be contrast this definition and hence it is defined counted sets of integers with that of kc is an operation on element for all counted sets and are operations on the elements of ways the concept of set union we define here the notion operations of pattern alternation can be extended to counted sets of additive union which we will and concatenation in any of a number of use in defining the definition let c and d be is a counted set containing property that the multiplicity in c and d counted sets the the settheoretic of each element additive union of c and d denoted by union of the elements of c and d with in c d is the sum of its c d the example let c a b c d a b e a b c then c d a c e la d e la c b lb c c extensions in developing a mathematical be using the approach of finite approximation with which we will be dealing namely defined as complete lattices a review helpful at this point semantics for recursive pattern definitions we will to the theory of computation based on the notion scott to use this theory the data types strings and counted sets of integers must be of some definitions may prove definition for all a poset is a set in which x y z the following conditions a binary for all x x s x if x s y and y s x then if x s y and y s z then relation x y x s z x s y is defined reflexive transitive which satisfies definition let a be a then an element a b e b b s a as b of b is the least a poset partially c a is an upper the greatest ordered by s and let b be nonempty subset of bound lower bound of b if and only if for all set of all upper lower bounds lower bound of b by lub b b definition and a least a in l a lattice is upper bound a poset a lattice any two of whose l is complete elements have a greatest when each of its subsets lower bound has a lub and in dealing with data types we make the following definition definition approximation a domain is a data type that is partially ordered by we have already defined a partial ordering by containment for counted sets to form a complete lattice from the counted sets of valid cursor positions for a given string s ie those integers c such that o s c s we add to the data type an universal counted set denoted top which is the least upper bound of the domain and contains every counted set and counted set denoted which is the greatest lower bound of the domain and is contained in every counted set we denote the domain thus defined by qs ordering to strings we simply ap to form a primitive s add two new values domain as follows top i and and define a partial bot where so s s sn is an enumeration of all strings over a given alphabet the scott terminology bot is the greatest lower bound of the data type and an approximation of every string is the least upper bound of the data type and is an extension of every string the product c e ds the partial s ap s in domain s x ds is defined lattice s and c cz in ds continuous functions and least fixed points for valid is defined contexts sc where s e s and by ap sc i and continuous the second requirement of the scott theory in the sense of the following definitions is that mapping between data types be definition a subset x of a lattice for each finite subset of x is directed if and only if x contains an upper bound definition of d a function fd d is continuous if and only if for every directed subset x x lub fx i x c x ie the function preserves limits among the operations by a negative shown to be for we have defined thus far on counted integer constant is not continuous use in defining recursive patterns sets only and will accordingly be the importance of complete lattices and continuous functions lies technique of modelling recursive functions by infinite sequences of finite and then showing that any particular value of these functions is determined number of approximations the technique is well illustrated by an example modelling recursive factorial function we adopt the f body to define a function fd d in the approximations by a finite from notation example consider the primitive domain in integers extended from the set of integers to the domain num and the multiplication follows operator nl n il i bot i bot top bit top bot bit bot bot top bot top top top bit top top c top this extension makes define the factorial continuous function fact since it is continuous in each num num on this domain by fact num k num if ko then else argument k now we can notice that fact can be regarded as a parameter of the righthand thus the equation defining fact can be rewritten as fact where f num num num num is defined by f num num g num num if ko then else of the equation fact is then a fixed point of f by the following definition definition point of and only consider a function f d d for some domain d then x e d is a fixed f if and only if x fx a fixed point x of f is a least fixed point if for all fixed points xl x of f x x x xr of f if fixed given it can be shown that any continuous point scott moreover if f is by the iteration formula x for n function continuous of on a complete the least lattice has a least fixed point x fx where is thus we can solve the equation fact for its least fixed point using fact where bot e num n maps each element elements of num to we produce the sequence domain where and form the limit ap ap ap which is the least fixed point of f a table of some of the fn for various k will show that the least fixed point is indeed the factorial function values of n and k o f lf bot bot bot bot om bot bot bot bot bot bot bot bot bot bot bot f bot bot bot if f bot bot i act bot top bot top t op top an algebraic model for string patterns introduction two facts lead to the search for an algebraic model for string patterns for the specification of string transformation procedures there is only a very weak algebraic structure inherent in strings and second it is the function of patterns to impose a upon the strings they match early directly the algebraic structure of strings failed to produce useful results attempts to approach the problem indirectly through string patterns a strong of the of this approach is contained in and this section is a and extension of theory of discrete patterns in order to the algebraic properties of the model the principal justification for the model developed here lies in the natural interpretations that can be given to the concepts that will be introduced to the algebra the most of these are negative both of which similar but more constructs and m the snobol mo e patterns equipped with a definition from of patterns of counted sets we can now give a definition adapted definition a pattern p string and c is an integer is a counted set of is a function where s is indexing s called the integers called the a string position positions called the subject the value of function two patterns are said to be equal if and only if they represent the same cursor may be regarded positions can take values in the range o is thus as a pointer into the subject string motivating the following the cursor definition definition referred of s the ordered to as a context pair sc for pattern into two where s is a subject string and o c is matching and represents a string parts by a cut between the and cl st characters examples let any string we can define a pattern follows for all contexts sc if substring else which we denote simply by a as a then let p ab and s and respectively then for c and is o the snobol primitive function nonnegative integer for all contexts sc else sc len is defined if cn as follows let n be a then sc cn extended we can now introduce algebraic structure the concept of negative of the model patterns which is central to the definition where sc let p be a pattern then p is an arbitrary p sc context is a pattern and is defined by example let p len and s aa and respectively then p s c for c o and is producing thus a negative pattern is defined in a purely a negative instance of a counted set algebraic sense as a function pattern the final definition p to allow a counted in this section extends the definition set of valid cursor positions as its of an arbitrary second argument definition nc if the second argument is the empty set we define ps example let p ab and s then ps the algebra of patterns alternation arbitrary we are now able to define the pattern in the definitions that follow context synthesis operations of concatenation and p and q denote patterns and sc is an definition the concatenation of p and q denoted by p q is a function defined by p definition the alternation of p and q denoted by p q is a function defined by p i we now propose to show that given suitable definitions of identity the operations of alternation and concatenation patterns form a ring with patterns for unit element definition fail is a pattern defined by for all contexts sc fail is a pattern that fails to match any string definition null is a pattern defined by c for all contexts sc intuitively null is pattern that matches just the null string theorem patterns unit element under the operations of alternation and concatenation proof let p q and r be arbitrary process to verify patterns that and sc be an arbitrary form a ring with context it is a p i q is a pattern p i qq ip p iq i rp i q i r p fail p pi p fail patterns under i form a group p q is a pattern p q r p q r p q i r p q p r q qp rp patterns p null null under pp and form a ring qe d we have avoided an informal semantic interpretation to negative patterns since their role in the pattern matching model can be defined solely in terms of inverse elements in the pattern algebra the theory can best be put into perspective by an application of negative patterns specifically pattern negation is useful in specifying patterns that are set difference expressions that is if we view patterns as functional specifications of sets of strings then the pattern p i q specifies the sets of strings of p and q pattern negation then matched by p but not by q ie the set difference is a generalization of the function of the primitive pattern abort in snobol et al example the following snobol pattern matches any character except an abort len using instead the concept of negative patterns we have len note that we could equally well write whereas the snobol pattern len abort would not have the desired effect introduction to inverse patterns we remark that given an arbitrary pattern p p is the additive alternation inverse of p if a multiplicative concatenation inverse of p z fail say pl could be defined such that p pl pl p null then patterns under i and would form a division ring we cannot hope to further extend the ring definition to obtain a field since is not commutative recall however that p sc independently of the context and the definition of pl if p fails to match in s ie then p z thus there does not exist a definition of pl that will yield a division ring useful a modified one and this section inverse patterns under is nonetheless an interesting is to the introduction of such a concept and patterns of p to develop a theory of inverse patterns we start by noting that are an important special case of a more general concept recall negative the definition where sc is an arbitrary this equation in a slightly p sc l context different way we get the expression on the right side of p sc this immediately suggests the more general definition defined by let p be a pattern and i be any integer then ip is a pattern and is where sc is an arbitrary context we observe that if p and q are patterns i ip i q jp i iq ii i jp ip i jp iii iv lp p and i and j are integers then from observations integers since there module is not finitely based on a true inverse but it concept i iv we conclude that patterns form a module over the are infinitely many primitive patterns including all strings this generated we can however derive a useful definition of linear dependence in the module the entity we will define is not most of the and of the stronger but first we note that in the module of patterns the following lemma holds lemma if p then ip fail implies that i o proof if p z fail there exists at least one context sc for which therefore if i o then ip sc z qed z definition only if let for each p and q be patterns context sc there then p and q are written exist integers i and i not both zero p q if and such that or equivalently ip is two they both succeed the context are a constant by the other patterns multiple are of if and only if for each context in which of the strings matched by one pattern in that the corresponding of the strings matched examples let p a q i a then q p and hence p and q are let p be any string q then for any context sc either or and hence p and q are patterns definition a pattern called a p is said to be of p with the properties that if there exists a pattern for all contexts src p pl sc pl only only if if p p pl null p w null note is not needed that here the restriction if we define p fail by which was required fail sc to define a division ring for arbitrary contexts sc to avoid expressions the operators defined thus far as t lowest we arbitrarily assign to we remark that patterns context sensitive patterns that is patterns of certain specified strings by a context sensitive pattern a sentence characters including a terminating period can be used when they exist to define that match successfully only in the context gives an example that is naturally described is recognized as being an arbitrary string of which is followed by at least two a snobol pattern to match is and complex x fail the concept transparent patterns of patterns yields equivalent but much simpler and more or len the pattern component and fails otherwise matches a period in the right context of two variable extension solution to the to the definition is conceptually more to the direction of the len primitive complex involving of scanning in the addition of the subject string a state and an len having shown questions of immediate indeed they do exist that patterns interest concern whether how they are characterized are a potentially useful concept the patterns do exist and if patterns example unfortunately it is not possible to define in such a way that will be as the following example illustrates let p ta i all then matching ta and psl by matching a suppose p is patterns p p s will be such that then as a result of the first defining of our choice of contexts ensures that both p p s and nonnull that is there exist nonzero integers i and j p p sl il and p p so j p psl evaluating now the left sides of these equations we have p p so ps p p sl the of p note that this result is independent of whatever definition we may choose for in general if a pattern p matches successfully in a given context the result applying p pl in that context will contain the position possibly with multiplicity and if p is not can contain other positions possibly with further as the preceding example illustrates it is not possible in general to deduce which of the positions was in fact the position of we have shown that if p and q are patterns it is not in general true that p i q is a pattern we remark that p i q will however be if and only if p does strings matched by q and vice versa exactly one of p or q of p i q not match in these any prefix or suffix substring of the cases p q is equal in each context of p and q guarantees to although alternation is preserved to under concatenation first we prove we can prove a lemma that lemma let p and q be patterns such that p m q and let r be an arbitrary pattern i p h r and ii r p r q proof we will prove only i since the proof of ii is quite similar zero if p q then such that thus for each context sc there exist integers i ip l p r i and j not both qed this result we can easily prove the following theorem theorem pattern proof if and this p and q are q pl is a result is easily patterns then p q is a of p q by considering similarly qed ql p p q ql pl m p null p pl null pl p q null p patterns give a proceed the results definition of to identify the class of this section there patterns do exist and are useful patterns motivated by the examples of patterns is a large class in the next section given above and of we patterns reverse patterns subject hence the essential characteristic of inverse patterns the direction of pattern matching this can be by the pattern and applying it in the string the extension to more complex patterns we give the following definition is their ability to effectively done most simply for string usual way to the reverse of the presents few difficulties and definition define its for every pattern p we state the existence pattern p by of a pattern and is reverse p c where sc is an arbitrary context although as we have seen pl is an symbol consistently in the sense defined and accurate in a restricted sense pattern then any inverse in the sense of the following definition of here it that is of p is notation has the we will equivalent we will use the advantages of later prove that if p is a to the standard definition contexts two patterns sc and cursor p and q are said to be if and only positions d d e if and only if d e if for all informally two patterns set of strings in every context are example let a q at i al i at then p and q always match the same strings eg if and only if they match the same pat and hence p and q are trivially interest matched operation in a pragmatic sense two patterns that are differ only since the of successful matches are often of little or no put another way the relevant question seems to be what were the successfully the number of times each match occurred is generally a question of importance snobol goes even further by halting the pattern matching after the first successful match provides a similar capability for snobol by introducing a state variable into the the direction of scan pattern matching a new built in function scan returns a primitive pattern that permits the direction of scanning to be changed dynamically during pattern matching and automatically during backtracking in addition certain primitives permit the cursor to be moved backwards without changing the direction of scan this approach has the that it adds considerable complexity to the pattern matching process by introducing the direction of scan as an additional parameter to each pattern component or equivalently as an added piece of context information the subject string further the built in function scan lacks generality in that its definition or the of an equivalent facility would be in any pattern matching facility not defined in terms of a procedure note that the model we have defined so far is entirely independent of the existence of such a procedure nor does the model the definition of a in the design of a language based on the model should such a procedure be desired arbitrary primitive our definition of is incomplete patterns p is however string patterns for we have not yet defined wellknown for strings and hence for for definition z let s be a string where si denotes the ith character in s then the implications of concatenation operators are following axiomatic properties this that definition and the definitions of the alternation should for all patterns p have the and i i q ii q iii p p if we define a mapping p from the ring i and ii state that reversal is an property iii states that reversal is a can easily prove the following lemma of patterns onto itself properties mapping given these properties and we lemma let p be an arbitrary iv v vi pattern and let i be an integer fail then proof prove iv and v are elementary iv consider results from the theory of group i fail thus fail using this result we have homomorphisms to and hence where i then fail proving p i v to prove vi consider first the case i p i i p i i i if i o property iv v to the above result applies qed and if i write ip p and apply property an immediate consequence as special cases is the following of property vi which which we state includes without properties proof iv and v lemma let p and q be patterns such that p q then if p is this then and pl is a of p we have yet to prove null m p similarly null m since clearly fails in any context if and only if fails and fails if and only if fails we conclude that is a of and hence is to we are otherwise unconstrained in defining and therefore give the obvious definition definition let p be any pattern then if there are primitive patterns other than strings under consideration their must be defined some primitive patterns such as the snobol primitive len are patterns some however are not for example is a pattern that matches any nonnull string of characters that is balanced with respect to right and left parentheses the of other primitive patterns can often be determined by modelling the primitive pattern using other primitives for which are known and the operations of alternation and concatenation some examples using the primitive patterns in snobol will illustrate the technique examples can be modelled as null i len i len i hence similarly null len i len i len i i le i p i if sn is any string can be modelled as where si denotes the ith character in s then s s i i sn hence similarly reverse reverse ­ s i s i s i sn i i reverse i i sn if we write then reverse breaks any s breaks reverse s reverse s then which matches all strings not containing have a break character as immediate left context break characters and if we model as then the example of break we see that matches immediate o any character not appearing in its argument all consisting solely of characters appearing in its argument in the strings returning that the mapping to the definition p pl is also of it follows an from the definition of of patterns accordingly p p ­ it can also be shown that pl p fail p p we close all the section with the proof of r are that if r is a pattern then lemma let r be a all contexts sc d s pattern and let implies z p be a of r then for proof suppose there p r sc only e e and nonzero exists a context sc such that d e and if there must exist some other cursor integer i such that ic now r sd pos tion since r d the assertion that p is a of r theorem for all let r be a contexts sc d pattern and let p and q be if and only if d e of r then proof suppose there exists a context a of r there exists that ic now such that by the previous d c and d e since lemma a integer i such r since d c this contradicts p and q in the above the assertion that q is a argument completes the proof of r unambiguous patterns proving actually condition we can now turn to the problem that if p is a is a of p the for of characterizing pattern then the following definition patterns and standard pl gives a simple sufficient definition cardinality a pattern of p is unambiguous is at most one if and only if for all contexts sc the theorem if p and of p and hence are unambiguous every then p is of p is and pl is a to proof let sc p p m null be an arbitrary context two cases arise in showing that case in this case the result holds trivially since p pl sc case also since the forward then for only the of those pattern direction can match successfully reverse s k some nonzero in the reverse hence integer k that matched direction and integer successfully we have n in p p sc p kp kc reverse c s and so p m null recursively defined proof patterns that p null is analogous q e d patterns many naturally context free patterns grammars have recursive definitions can be used to recognize in particular context free languages example consider the following arithmetic expressions context free grammar for a subclass of constant e t i e t t f t f f in snobol a pattern to recognize match f any t f t f e t i e e such expressions can be as in general recursive patterns are those defined by equations of the form p gp where g is an arbitrary domain of patterns by the domain equation function of patterns thus if we define the where patterns domain map strings pattern and counted x ds sets into counted sets then g is an element of the pattern pattern in this section techniques we give a mathematical semantics for such patterns using least fixed point in section we the use of negation in recursive pattern definitions on the that negation or multiplication by any negative integer is not a continuous operation containing as only defined a result elements by this we can restrict with nonnegative restriction by our attention ds note in this section to counted sets we will denote the that in ds bot since for all definition following patterns are extended to the domain s x ds as follows let p z fail table defines the be any pattern and sc values of p on x ds be an arbitrary context then the i bot i top i top bot top bot bot top we define fail in the extended domain by note and continuous the exception that under this of multiplication extension any pattern defined functions ie all functions by a negative integer is in terms defined a continuous of primitive in the model function patterns with returning of the form now to the problem of giving meaning to patterns defined by equations p gp where p and g are continuous and the notation we can write g using the extended definition of patterns f body to define a function fd d example let p a i p a then p gp where g pattern a q pattern i q a least p is thus fixed point a fixed using point of g and we can solve the equation p gp for its p we produce the sequence of domain elements where for arbitrary sc e x qs sc s sc s sc and form the limit which is the least fixed point of g a table of some gn for various and contexts sc will show that the least fixed point definition of the previous example does indeed match any sequence of one or more as values pattern of n in the src fail j t fail fail p g top top top summary in this the following section patterns contexts are defined points the main features as counted set producing functions of the algebraic model developed of contexts or counted sets of negation are defined alternation and concatenation are in terms of operations on counted sets functions of patterns and patterns under the operations element the additive identify of alternation and concatenation is fail and the multiplicative form a ring with identity is null unit the algebra cannot be further can show however that patterns extended to define form a module over a field or even a division the integers ring we patterns dependence in the module are defined in terms of a notion based on linear not all patterns are patterns then p q is further if p and q are but p i q need not be for an arbitrary formulated in terms equivalent to pl pattern p a definition of and it a method for defining of its standard is shown that any for an arbitrary pattern pl can be of p is is outlined is defined and is shown to be a simple sufficient condition for the semantics techniques of recursive pattern definitions can be defined using least fixed point the development in this paper has been and abstract with only references to programming applications in order to suggest interpretations or applications of algebraic features string manipulation language design some of the are explored in of the model in terms by choosing an of algebraic rather than an model we have been able to separate those issues inherent to the data structures and operations of pattern from those concerned with its efficient implementation considerations of the latter type include pattern matching heuristics and backtracking further the algebraic model allows the language designer the to incorporate the data and control structures best suited to specific language design goals in contrast such as snobol and have control structures concept of expression and statement continuations that are strongly by the which are in a sense the result of pattern matching in these languages in comparing the efficiency of pattern matching in the model presented here that of the snobol model certain definitional differences must be taken into account for example an optimization problem arises in patterns containing negative in those parts of the pattern structure containing negative the possibility optimizations designed to avoid matching remaining after a successful match w th of commutativity optimization available successfully matching should not be an implicit deferred and matching process of the alternation operator in the to snobol programmers of ordering however it can be argued part of the pattern specification explicitly when it is appropriate present model the by of that this optimization process but rather should be as part of the pattern on parallel and vector computers commutativity of alternation becomes an advantage and the need for the optimization discussed above since can be matched in parallel against the subject string since the order in which are matched is important in snobol there is very little to take advantage of hardware parallelism and on such machines the model we have proposed may very well prove to be the more efficient acknowledgements the thesis work on which this candidate under the computer science at the university of national research of paper is of based was done while the author was an j j in the department of this research was partially by the references g lattice theory vol an mathematical mathematical society society colloquium and k and j h an axiomatic language for string transformations cacm di a c di processing languages and generalized markov algorithms symbol manipulation languages and techniques proceedings of the ifip on symbol manipulation languages d g cd north holland j university of department of computer science unpublished j n a new approach to the analysis and synthesis of strings university of department of computer science j high level operations in automatic programming sigplan notices et al d manipulation and addisonwesley j r e language b a jacm il and j a i p snobol of programming a j f a theory of discrete patterns and their implementation in p snobol et la phd thesis de et al r e j f i p programming second edition prenticehall the snobol new control mechanisms and syntax for snobol university of department of computer n m l computation in finite and infinite d van prenticehall and r and a preliminary manual stanford research institute artificial intelligence centre technical note l algebra press scott d scott outline of a mathematical theory of computation proceedings of the fourth annual princeton conference on information science and systems n scott d theory data types and formal semantics symposium formal semantics prenticehall g f an algebraic model for string patterns university of computer systems research group technical report no r semantics and design of programming languages university of department of computer science technical report no v h computer programming with ii mit press 
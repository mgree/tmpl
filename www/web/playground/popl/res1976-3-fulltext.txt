automatic generation of efficient evaluators for attribute grammars kennedy scott k department of mathematical sciences rice university texas i n t r o d u c t i o n the translation process may be divided into a syntactic phase and a semantic phase contextfree grammars can be used to describe the set of syntactically correct source in a formal yet intuitively way and many techniques are now known for automatically constructing parsers from given cf grammars attribute grammars offer the of similarly the implementation of the semantic phase an attribute grammar is an ordinary cf grammar extended to specify the meaning of each string in the language each grammar symbol has an associated set of attributes and each production rule is provided with corresponding semantic rules expressing the relationships between the attributes of symbols in the production to find the meaning of a string first we find its parse tree and then we determine the values of all the attributes of symbols in the tree when an attribute grammar is used to specify the translation activity of a compiler the attributes will be such things as data types of expressions symbol tables for use in translating identifiers and machine code generated for statements using an attribute grammar to specify the translation performed by a compiler offers these advantages the semantics is given in a rather than algorithmic notation independent of any parsing scheme the description is modular given on a basis so that it is easier to understand and modify and the notation naturally expresses the idea of as well as the relation of a whole to its parts work supported by grant from the nsf division of computer research despite these advantages attribute grammars have not been widely used because of the difficulty of obtaining implementations efficient enough for practical use the problem is one of converting a semantic description into an efficient procedure for performing the translation attribute grammars leave the order of evaluation of semantic functions largely unspecified requiring only that a functions arguments be computed before the function is evaluated a suitable evaluation order must take into account both the data dependencies of the semantics and the shape of the particular parse tree until now automatic evaluation has been possible only through the use of a e t e r m i n i s t i c a l g o r i t h m if or by restricting the class of acceptable attribute grammars in this paper we present a method of constructing for a given attribute grammar a recursive procedure which performs the specified semantic evaluation these evaluators are produced by the data dependencies of the attribute grammar to find an acceptable evaluation strategy a wide class of attribute grammars can be handled and the resulting evaluators are efficient in that they make no use of nondeterminism or searching through the parse tree and may be generated as directly executing machine code our construction should therefore be useful in a practical system section provides an introduction to the basic concepts associated with attribute grammars sections and d e s c r i b e evaluators and how they are built here we characterize the class of attribute grammars for which the construction will work in section we compare our method to previously known techniques for implementing attribute grammars finally section contains a summary and discussion of possible improvements to our scheme a t t r i b u t e g r a m m a r s a variety of techniques have been used to introduce the idea of semantics into contextfree grammars such as indexed grammars a property grammars sl grammars jr twolevel grammars vw and grammars gh these efforts were concerned primarily with limiting the set of terminal strings generated by a grammar and only with specifying the meanings of those strings i r o n s i i n t r o d u c e d the idea of s y n t a x directed translation essentially allowing a single synthesized attribute to be associated with each nonterminal of this idea to allow multiple synthesized attributes were studied extensively by lewis and ls and by aho and ullman au knuth extended this formalism in an important way by allowing attributes to depend on the context surrounding a grammar symbol as well as on its attribute grammars have interest as a means of specifying syntaxdirected because of their declarative nature and expressive power in the remainder of this section we define attribute grammars and related concepts and illustrate their use many of our definitions are taken directly from bi an attribute grammar is an ordinary contextfree grammar augmented with attributes and semantic functions as described below grammar a reduced contextfree grammar g n vt p s we write v for v n u v t a production is written as p x x x w h e r e np a i and x k v for k we write pk to mean x k for we assume that the grammar is if necessary with a th production ss so that the start symbol s occurs in no other production a parse tree of g is a finite ordered tree whose nodes are labelled with symbols from v such that for each interior node t there is a production such that t is labelled with the symbol p t has np sons and the kth son of t is labelled with the symbol pk we say that p applies at t or e q u i v a l e n t l y that t is a node attributes for each xv there are finite disjoint sets ix and sx of inherited and synthesized attributes respectively for xs the start symbol and for xv we require that ix we write ax for ix u sx the attributes of a grammar symbol identify the various components of its meaning a production has the attribute occurrence ak if a c a x k for k n p a t t r i b u t e o c c u r are to be understood as variables which are used in writing the semantics for a production inherited attributes transmit information down the parse tree toward the leaves while synthesized attributes transmit information up the parse tree toward the root the start symbol may not have inherited attributes because it can have no ancestor terminal symbols may have no inherited attributes because they have no associated semantics the values of a terminal symbols synthesized attributes are given initially in a compiler this is the job of the lexical the term attribute is used to mean some as in an attribute of a nonterminal to mean some occurrence ak as in an attribute of a production or to mean a value attached to the parse tree as in an attribute of a node it should always be clear from the context which sense is intended semantic functions for each production there is a set of semantic functions as follows for every synthesized occurrence ak with k and for every inherited occurrence ak with there is a semantic function mapping certain other attribute occurrences of p into a value for ak the semantic functions specify the meanings of parse trees locally in terms of only a node and its immediate we do not consider the language in which the functions are written we assume only that we can identify the attribute occurrences referenced in a function and that the function can be translated into machine code to do the evaluation a semantic tree of an attribute grammar is a parse tree in which each node labelled with is a structured variable whose field selectors are the elements of ax in order to determine the meaning of a string we parse it and build a semantic tree and then we fill in the fields of each node in with the semantic functions the latter process is called the semantic tree an evaluator for an attribute grammar is a program which accepts a semantic tree and evaluates it in this paper we refer to the time when an evaluator operates as runtime thus we think of our construction method as a compiler which produces evaluators as object programs the of the attribute grammar formalism is specified by a defining evaluator which provides a conceptual model for evaluating semantic trees evaluation begins with all fields of the semantic tree undefined at each step some attribute of a node is chosen whose semantic function can be evaluated that is all of whose argument occurrences are already defined the chosen semantic function is executed and the corresponding field of the tree node is defined by setting it to the computed value the process continues until all attributes in the tree have been defined the defining evaluator is nondeterministic since at each step any attribute can be chosen which is ready example figure gives an attribute grammar specifying the translation of binary constants into the numeric values they represent f observe that the notation stands for the attribute occurrence ak if the nonterminal x k occurs only once in a production then the subscript k is omitted to represent the desired translation we have the val attribute for the start symbol n val is also an a t t r i b u t e of the b i t l i s t s l and the i n d i v i d u a l b i t s b however in p o s i t i o n a l n o t a t i o n the value of a depends on how many places to the left it appears the attribute pos is introduced to express this for instance the semantics for production says that the value of a is the power of two corresponding to the bits position on the other hand rule says that the value of a bit is always zero in this grammar val is a synthesized attribute carrying information up the tree toward the start symbol while pos is an inherited attribute carrying information down the tree from above figure shows the semantic tree for the string the fields have been filled in as by the semantic rules the effect of our attribute grammar in this case is to specify that the translation of is it is a matter of whether the translation of a string is taken to be all the attribute values in its semantic tree or just those of the root t r e e w a l k e v a l u a t o r s as the name suggests a evaluator is a recursive routine which traverses the semantic tree performing attribute evaluations as defined by knuth kn a tree traversal is a method of examining the nodes of a tree systematically so that each node of the tree is visited exactly once but we have in mind something a bit more general in particular we allow multiple to the same node and different nodes may be visited different numbers of times more specifically a evaluator is a recursive routine taking a tree node as a parameter in execution it is said to be its parameter node while at the node the evaluator may take actions of two vn i n i s il is i pos pos v t i sn ss sl sb val val val production semantics i ÷ ÷ i s n e g then else fi s ÷ false s ÷ true l b ÷ ÷ l l i b b ÷ ÷ ÷ b ÷ f i g u r e i n l po i po f i g u r e kinds it may execute semantic functions of the production applying at the node thereby evaluating some attributes of the tree or it may call itself recursively with one of its sons as a parameter it may perform any combination of such actions before returning our evaluators will have a particularly simple control structure upon reaching a node the evaluator will the situation and choose one of a fixed set of instruction sequences which it will then execute before returning each of these instruction sequences or will be a sequence of actions of the two kinds mentioned above there is no branching within a plan except possibly within semantic functions which we consider atomic within a plan no tests are necessary to determine whether an attribute can be evaluated since all such analysis has been performed during evaluator construction to select the proper plan for execution at a node our evaluators will have two types of information available first the evaluator will receive a control parameter from above when it is called this parameter summarizes the activity that has taken place above since the last visit and is used to allow evaluation strategy at a node to depend on the context in which it occurs second there is the situation at the node itself represented by the value of a field present in each node the flags are used by the evaluator to remember information between to a node in operation the evaluator moves from node to node performing attribute evaluations until evaluation is complete initially the evaluator is called with the root of the semantic tree as its argument in general a recursive call is made when some new inherited attributes of a son have been made available the effect of the call is to as much more evaluation of the subtree as the new attributes permit this may involve deeper recursive calls during a visit the evaluator may make multiple to a subtree of the node each time performing a partial evaluation thus a visit may contain multiple passes over the subtrees of the visited node because of prior dependency analysis our evaluators always know where to go next they do not have to search around looking for an attribute which can be evaluated the evaluator will eventually terminate by returning from its initial call at which time all attributes in the semantic tree will have been evaluated definition of a evaluator we now make precise the idea of a evaluator and its operation as well as some concepts a evaluator is a tuple q q e i goto plan w h e r e q is a finite set of states q p q assigns to each production p an initial state qp e is a finite set of entry states i is a finite set of containing a distinguished element d e n o t e d goto q × i e is a p a r t i a l f u n c t i o n assigning an entry state to certain pairs plan e is a total function assigning a plan to each entry state a p l a n is a pair q w h e r e n is a sequence of instructions and q q an instruction is either a a s e m a n t i c f u n c t i o n or b a s y m b o l of the f o r m v i s i t k i w h e r e k is an integer and i i a semantic tree with root r is evaluated as follows i e a c h n o d e of the tree is f l a g g e d with its initial state given by qp where p is the production applying t h e a l g o r i t h m e v a l u a t e r is performed t is a tree node and i c i i l e t q b e the flag of t let e g o t o q i e x e c u t e at t end to e x e c u t e p l a n q at node t i f o r i n e x e c u t e s i at t set the flag o f t to q to execute instruction fp at node t ak evaluate the semantic function and set the tree field corresponding to attribute occurrence ak to the resulting value to execute the instruction at node t i let t be the k t h son of t p e r f o r m the a l g o r i t h m e v a l u a t e t i comments it should be clear that the evaluation process does not make any use of the s t r u c t u r e of m e m b e r s of q e or i therefore these elements may be encoded as integers at runtime similarly since the functions q goto and plan have finite domains they may be implemented by suitable forms of table lookup for this reason we use the term to refer to the goto function considered as a set of pairs we say is a entry if e finally each plan may be compiled into machine code and directly executed at runtime overview of the construction our approach differs from previous work in that we compile an attribute grammar into a evaluation algorithm rather than propose a generalpurpose algorithm a priori we do so by a method which involves the simulation in a limited sense of events which could take place during evaluation in this way we are able to do all necessary dependency analysis in advance thereby eliminating the overhead of runtime analysis and avoiding search through the tree we make the assumption that the evaluators action at a node can be independent of the structures of the nodes subtrees this assumption is motivated by the of grammar nonterminals as abstractions with definite interpretations of their own the idea of semantics suggests that it should be possible to understand the semantics of a construct without any further knowledge of the abstractions it is built of we believe this is a reasonable assumption and we expect that most practical attribute grammars will satisfy it h o w e v e r in wa it is s h o w n h o w to extend our method to treat any the evaluator construction itself is presented in two parts is the process of building an instruction sequence to be used in a certain situation a partial simulation of a visit is which maintains the set of attributes known to be available at each step this is enough information to allow dependency analysis to decide which semantic function should be evaluated next by considering the possible dependencies between synthesized and inherited attributes of each son the method is also able to decide when a recursive visit to a should be made for a given initial situation the simulation produces a plan which may be immediately executed upon that situation a complete set of is an iterative process which ensures that every possible situation during evaluation has been for recall that when evaluate is called to visit a node it first the to find this entry state and then executes the plan corresponding to that state thus the evaluator construction must ensure two things the must have an entry for every combination of flag and parameter which can be encountered and plan must associate a plan with every entry state to start things off a entry is made corresponding to the initial visit to the root of the semantic tree and a plan is made for the resulting entry state by examining the made so far we can determine what entries a particular visit instruction may cause to be up if not already present this must be added to the and if the entry state does not already have an associated plan a new one must be made for it this process is repeated until no new entries can be found at this point the evaluator contains for every situation that may arise figure shows an example attribute grammar and a evaluator for it p l a n n i n g our intention is to avoid considering dependencies at runtime by doing this work during evaluator construction we make use of incomplete representations of runtime situations and actions containing only the information necessary to see that dependency constraints are we imagine that the evaluator has just at a node and found it in a given initial situation we then repeatedly select an action permitted by dependency constraints schedule it for execution next and determine what the new situation will be after it is executed when no next action is permitted stops this is equivalent to scheduling a return to the evaluators caller definition an evaluation state is a pair pa where and a is a set of attribute occurrences for p an evaluation state represents the situation at a node at some instant during evaluation if a node is in state pa then production production s ÷ a i a a b a ÷ a a b b b b ÷ b b semantic functions q q e i goto plan where q ql q q and qq qq i e el e e z ii i i i goto ql el q q q q q q q q q q q ii i i i e e e e e e e e plan e n el q e q e visit i q e b a q e e b b q e b a e q e skip q el q q figure p applies at the node and a is the set of attributes which are known to be available an evaluation state is the minimum amount of information about a nodes situation with which we can carry out dependency analysis we must know what production applies in order to know what semantic functions are involved and we must know which attributes are available in order to decide whether a function can be evaluated yet the elements of a evaluators sets q and e will be evaluation states if a node is with this will mean that described the nodes situation at the end of the last visit to it if upon at a node lookup yields the entry state ee this will mean that describes the nodes situation after taking into account any new inherited attributes made available since the last visit requiring that the evaluators action at a node be determined only by the evaluation state there as found by lookup introduces our assumption that the structure of a nodes subtrees is irrelevant since this information is not encoded in the evaluation states if we are to pick a next instruction based on the current evaluation state and to find the new evaluation state resulting from its execution we must be able to characterize each instruction in terms of the attribute occurrences it references and those it defines we discuss this matter next dependency characterization of instructions for purposes an instruction is characterized completely by the e n c y r e l a t i o n s b e t w e e n the a t t r i b u t e s it uses and the attributes it computes for a semantic function this is specified by the attribute occurrence which it defines and the set of occurrences which it references we denote the set of occurrences used in by d a k for a v i s i t i n s t r u c t i o n the question is more complicated the subtrees of a node may be viewed as semantic functions of a sort given some inherited attributes a son may be visited to yield some synthesized attributes unlike the semantic functions a subtree may be capable of partial evaluation that is not every output has to depend on every input it may be possible to visit a subtree with only some of its inputs available and return with some of its outputs computed a subtree may be visited several times before its evaluation is complete the dependency graph of a production pcp denoted is a convenient repre of the constraints imposed locally by the semantic rules for p the nodes of are the attribute occurrences of p there is a d i r e c t e d arc from ak p to ak if ak da ie if k ak is used in the evaluation of ak the arcs of such a dependency graph may be thought of as data flow paths figure shows two ways of the dependency graph for a rule from our example grammar the more elaborate form is intended to suggest a portion of a parse tree and will be used in the remainder of the paper to data flow up and down the tree if we have a parse tree of an attribute grammar we can construct a dependency graph which represents all data flow paths in the tree this graph is the result of together copies of the for p productions occurring in the tree as illustrated in f i g u r e if a subtree is from the rest of the parse tree some data flow paths through the root of the subtree will be data flows into the subtree through inherited attributes root and out of the subtree through synthesized attributes of the root for this reason we refer to these attributes as input attributes and output attributes of the subtree in a production the input occurrences are those of the form i where and the output occur are those of the form s where the dependency graph of a subtree may imply that certain input attributes must be made available before an output attribute can be evaluated these relationships are called the inputoutput dependencies of the subtree val pos val pos l ca i i pos li s f i g u r e i f i u r e we wish to associate with each nonterminal x of the grammar an io graph io x which will describe the inputoutput dependencies of subtrees with root x the graph will then serve as the dependency characterization of instructions in effect the io graphs are inputoutput assertions specifying the behavior of the evaluate routine we are guaranteed that after execution of a an output attribute of the kth son will be available provided that it depends on has arcs in from only input attributes that were available at the time of the call unfortunately different subtrees with the same root symbol may nevertheless exhibit different inputoutput dependencies so we cannot hope to characterize a nonterminal precisely by means of a single graph instead our will present a sort of worstcase picture of potential inputoutput dependencies in order to compute the graphs for each we first show the apparent inputoutput dependencies for a node of type p are related to the dependency graph for production p and the io graphs of symbols occurring in ps right side this allows us to establish a recursive definition of the which leads in turn to an iterative algorithm for finding them what follows is adapted from original erroneous circular ity test for attribute grammars recall that for each pcp there is a directed graph the dependency graph for production p suppose that for we have a directed graph gk whose nodes are a subset of then let be the directed graph obtained from by adding an arc from attribute occurrence ak to occurrence ak w h e n e v e r there is an arc from a to a in g k figure illustrates this idea definition the augmented dependency graph dg for a production is the graph where is taken to be the empty graph if x k e v t the graph dg is the dependency graph for ab ab xy xy x s x f i u r e production p extended to include potential dependency chains through subtrees it shows both the dependency constraints associated with the semantic functions of p and those associated with the use of the evaluate routine in visit instructions now let x be the left side of pro p any path in dg from an input of x to an output of x represents an apparent inputoutput dependency of x and hence must be represented by an arc in moreover the should be the smallest graphs satisfying this requirement since there is no other way for an inputoutput dependency to appear except through a chain of instruction dependencies we may therefore make the following recursive definition definition the set of io graphs is a set of directed graphs indexed by v n satisfying a the n o d e s of the g r a p h io x are the attributes ax and b t h e r e is an arc f r o m i to s in io x iff there is a path from i to s in the graph dg for some production p whose left side is x the following method may now be used to compute the set of io graphs initially let each have nodes ax and no arcs then repeat until no more arcs can be added to any if there is a production p with left side x such that has a path from i to s but io x has no arc from i to s add the m i s s i n g arc to io x the algo rithm must terminate since there are only a finite number of arcs possible at all it is clear that the resulting graphs satisfy the d e f i n i t i o n above a is trivial the if p a r t of b f o l l o w s f r o m the a l g o r i t h m s termination condition and the only if p a r t of b is true b e c a u s e o n l y such arcs are ever added to any the arcs in reflect all the actual inputoutput dependencies that could exist in a subtree with root x so we can safely use them during to predict the effect of a subtree all outputs can in fact be produced however not every arc necessarily represents a possible t dependency the may be io dependencies that no subtree could actually exhibit the example computation of figure illustrates this the reason is that an io x attempts to represent in a single graph all the io relationships that can be by any subtree with a given root symbol even though different such subtrees may exhibit different inputoutput dependencies two arcs in an may be by two different so that no actual subtree could exhibit both dependencies later in the computation of the io graphs some dg d may have a path from i to s which both of these arcs the result will be to add an arc from i to s in the io graph of ps left side nonterminal even though no such dependency could ever be found in a semantic tree the information loss due to merging all a nonterminals io relationships into a single graph may prevent evaluator construction by making it seem that evaluation is in certain situations when it is not for a wide class of attribute grammars this does not happen definition an attribute grammar is if no graph contains a directed cycle an grammar contains no circular dependencies in its semantics even assuming that the must be a grammar can fail to be either because it is actually circular or because the are too pessimistic the algorithm a plan for a given entry state is an instruction sequence which will all attribute evaluation in the subtree which is permitted by the dependency constraints the algorithm described below makes use of the discussed above and assumes that the attribute grammar is definition the semantic function fp ak is ready to evaluate in the current evaluation state pa if ak a but d a definition the yield of the kth subtree in the current evaluation state pa is the following set of attribute occurrences ak l ak a a and for every i with an arc from i to a ia ik ¢ a h ri n ri o r h xo x i cl xo o r el x ri ri o u i ii i o c ii · i · x j r n r r o ri q ii i q r x ii ii o ii q r ii that is a visit to the kth son will yield those outputs of xk which were not already available and which depend in on only available inputs algorithm make a plan for entry state pa initialize l e t s be the e m p t y sequence of instructions and let a a repeat the c u r r e n t e v a l u a t i o n state is pa evaluate if some semantic func tion is ready to evaluate then append the instruction fp ak to s add ak to a and go to s t e p if there is a k t h subtree whose yield y is nonempty then append the instruction to s where i a i a ix k and ak a let a a u y and go to s t e p done l e t q be the e v a l u a t i o n state pa the algorithm is complete and the resulting plan is sq end the heuristic used is to evaluate all possible semantic functions before any subtrees this makes as many inputs as possible available so that a lot of evaluation of the visited subtree can be done which to reduce the number of which must be made to each node we do not consider the question of which subtree it is best to visit if more than one have nonempty yields note that although semantic functions are evaluated only once a plan may contain several to the same subtree we note that the current evaluation state pa at a step in the simulation does not correspond precisely to the situation that will exist at that point in the execution of the plan at runtime in any particular execution at a node there may be some available which are not in a these would be outputs of subtrees which were not guaranteed to be in the yield since a particular subtree may not exhibit all the dependencies in its sometimes a visit instruction will result in evaluating some extra attributes the only effect of that some later visit which does the attributes will not have as much to do the selection of a plan at the will avoid duplicate work m a k i n g a c o m p l e t e set of p l a n s when a instruction is executed the recursive call to evaluate will result in the lookup where q is the state flag found on the kth son the process of constructing a evaluator involves finding all qi pairs that will ever be used to access the and making all the relevant entries in goto and plan we first introduce a mechanism to keep track of the order in which may be executed at a node then show how it may be used to determine whether a given visit instruction can cause the lookup of a entry not yet included in our partially constructed evaluator finally we present the evaluator construction in abstract form and sketch how it could be implemented more efficiently the history graph definition a history graph is a directed graph whose nodes are labelled with evaluation states such that a the n o d e s are p a r t i t i o n e d into two disjoint sets called the and the b an arc f r o m a q n o d e to an e n o d e is called an arc and is labelled with a c an arc f r o m an e n o d e to a q n o d e is called a visit arc and is labelled with a sequence of instructions d t h e r e are no o t h e r k i n d s of arcs a path through the history graph represents a sequence of events which could happen during the evaluation of a node an arc represents the of the evaluator at the node while a visit arc represents the execution of a plan at the node thus what happens at the kth son when a is executed the son is initially with state q the evaluator the i and finds that the corresponding entry state is e it then executes the plan for e which consists of the instructions sl s sn followed by setting the sons flag to state q the history graph of an evaluator contains the same information as its formal definition in terms of goto and plan each arc q i e corresponds to the entry and each visit arc n e c corresponds to the entry plan a history graph is not in general a connected graph it will have one connected component for each production in the grammar the component corresponding to will contain all nodes with labels of the form pa and represent all possible sequences of events at a node where p applies the history graph is useful because it makes explicit the order in which things can happen at a node even across the boundaries of single if we take any path through the history graph we can get a corresponding instruction sequence by in order the labels of the included visit arcs instruction occurrence ii precedes occurrence i if there is a path whose corresponding instruction sequence includes ii and i and ii is to the left of i in that sequence note that this is only a partial order new entries we are concerned with whether a given instruction can cause the lookup of entry not yet present in the evaluator being constructed the entry up will depend on the state q in w h i c h it finds the kth son and on i the from q and i we can compute what the entry state should be as follows pa where a a u i and q pa that is the corresponding entry state is just the old state augmented with any newly available input occurrences we see that the is merely a device to avoid the explicit use of attribute sets and set union at runtime by the answers to those computations that will be needed definition the entry is required b an occurrence of a instruction if the kth subtree could be with state q at that instruction and e is the e n t r y state c o r r e s p o n d i n g to q and i this is the definition we need to find new entries any entry required by an existing visit instruction must be added if not already present we still have to show how to determine what states a subtree might be with at a given point in the execution of a plan at any point in a plan a subtree must be with the state left by the most recent visit to it or with its initial state if it been visited yet at an instruction in the history graph a most recent visit to the kth subtree is a which precedes the instruction such that there are no other instructions there may be several most recent since they may lie on different paths to the point in question there may also be no most recent visit at all if there is a maximal path to the instruction such that there is no at all we say that the initial visit is most recent note that it is possible for both the initial visit and some visit instructions to be most recent at the same point the state that the kth son is with after execution of a instruction is uniquely determined by i and the production which applies at the son the reason for this lies in the way are constructed a plan performs all attribute evaluations permitted by the dependency constraints and the amount of evaluation that can be done is limited only by the availability of inputs to the subtree thus the set of attributes available at the end of a visit is determined only by the available inputs and not by the details of previous definition the state corresponding to production p and i denoted is q where q is the r e s u l t of m a k i n g a plan for the entry state pi is the evaluation state in which all attributes of a node are available w h i c h can be c o m p u t e d w i t h i n p u t set i to sum up we saw that in order to find the entries required by a instruction we needed to know what states the kth son might be with at that point we observed that it could be in any state that a most recent visit could have left it in the can be found with the help of the history graph and we can compute what states they might leave the son with specifically at a given point the kth son can be with state q if a q w h e r e p x k and some is most recent or b q qp w h e r e p x k and the initial visit is most recent evaluator construction we now present evaluator construction algorithm the main data structure is the history graph discussed above initially the history graph consists of one per production labelled with the initial state for that production and no arcs the functions goto and plan considered as sets are empty a first entry is made corresponding to the evaluators visit to the root of the semantic tree since the start symbol has no inherited attributes the is after that an iterative process of making and finding new entries is carried out until no further additions to the evaluator can be made definition the initial state for denoted qp is the state pa where a ak i t and in an initial state only those attributes are available which are given in advance the synthesized attributes of terminals construct a evaluator i initialize let the h i s t o r y graph consist of a for each labelled with qp let goto and plan be empty first g o t o t a b l e entry a d d an arc labelled from the labelled q to a new with the same label let q new g o t o t a b l e entry if some instruction requires a entry not already present then add an arc labelled i from the labelled q to the labelled e add the nodes if necessary let e go to s t e p new p l a n if t h e r e is an e n o d e labelled e with no arc leaving it then let be the result of making a plan for e add an arc labelled n from the labelled e to the labelled q add the if necessary let go to step end done let q be the set of all evaluation states labelling let e be the set of all evaluation states labelling let i be the set of all labels of arcs the constructed evaluator is q q e i goto plan the algorithm must terminate because each step in the loop adds to the history graph yet the potential size of the history graph is finite there are a finite number of evaluation states and hence of nodes in the graph no two or two have the same label each has only one and for each only a finite number of distinct labels subsets of a productions set of attribute occurrences are available for the construction the construction algorithm above is straightforward but somewhat if p r o g r a m m e d d i r e c t l y the t e s t in s t e p if taken involves all entries required by each visit instruction of the history graph on every pass through the loop in the remainder of this section we describe an optimized version of the construction which involves less work our purpose is not to propose a best algorithm but merely to indicate that reasonable implementations of the construction can be made our approach is to avoid by introducing some variables and updating them when necessary we associate with each node n a set containing information about what states each subtree could be with at that node each element of is a pair where k is the number of a son and q is a state the kth son could be with we will call these elements when the history graph is initialized each initial has its states set initialized to show that each son must be with an initial state that is if qn is an initial labelled with state then l and initially px k moreover we associate with each en a set of elements of a new set are that have been discovered but not yet used to generate new entries during evaluator construction the only that may require a entry are belonging to an with a nonempty new these sets help the work and avoid repeated of the entire history graph the new and states sets must be kept up to date when the history graph is added to a newly created node is given an empty states set a newly created also gets an empty new set when an arc is added from a qn to an en thus a new path to en and perhaps making a new visit instruction most recent any previously known will be saved in for later processing our first adds a segment to the history graph and performs the needed update make the goto entry i a d d the e n t r y to the let qn be the labelled q and en the labelled e add an arc labelled i from qn to en creating the nodes if necessary let u l e t be the r e s u l t of making a plan for e add an arc labelled n from en to the labelled q add the if necessary end the central activity of this version of the construction is considering an whose new set is nonempty each visit instruction of the nodes plan is examined in sequence to see if assuming a son is with a new state will result in requiring a new entry additions to the history graph may be made as well as new to be propagated along a new possible flag for a son at the beginning of a plan may imply a new possibility at its end new possibilities at a are not in a new set there but are passed immediately to successor for holding algorithm consider the en let c u r r e n t n e w e n let s t a t e s en s t a t e s en u let let e be the label of en for each in in order for each state q such that current make the goto entry if it is not already present delete all pairs from current add the pairs i let q be s u c h t h a t let qn be the labelled q then let current and u if d i f f t h e n for e a c h e n o d e with an arc from qn to en let u en end steps and of this algorithm propagate only the interesting ie new along for further processing later there are of course many ways to improve the algorithm the actual evaluator construction algorithm version two follows algorithm construct a evaluator i initialize let the h i s t o r y g r a p h consist of a for each labelled with qp let be empty for each qn let goto and plan be empty first segment make the goto entry q q new segment if for e v e r y e n o d e en go to step otherwise let en be an with consider en and go to s t e p done l e t q be the set of all e v a l u ation states labelling let e be the set of all evaluation states labelling let i be the set of all labels of arcs then the constructed evaluator is q q e i goto plan end c o m p a r i s o n w i t h o t h e r m e t h o d s three authors have studied the problem of attribute grammar evaluation the first implemented a general system based on parallel processes proposed evaluating certain attribute grammars in a fixed number of lefttoright passes over the tree and suggested extending this idea to a fixed number of then passes s y s t e m f was a m o r e or less d i r e c t implementation of the defining evaluator it could evaluate any attribute grammar but it was not a practical method of evaluation as noted a nondeterministic approach such as this is bound to be inherently less efficient than deterministic approaches was the first to describe such an approach b he by considering the possibility of evaluating an attribute grammar in a single left to right pass through the semantic tree a recursive routine traversed the tree in depthfirst left to right order performing evaluation of attributes to ensure that all the semantic functions of a node could be executed it was necessary to compute all of the nodes inherited attributes before it thus performed the following algorithm for each subtree in left to right order first evaluate all its inherited attributes then call recursively on it to finish its evaluation finally compute the current nodes synthesized attributes and return not every attribute grammar can be evaluated this way stated the condition that the semantic functions dependencies must satisfy no inherited attribute of a son can depend on any of its synthesized attributes or on any attributes of sons to its right this represented a very strong condition on the attribute grammar to increase the number of attribute grammars that could be evaluated proposed to allow the evaluation to occur in several left to right passes on each pass all attributes evaluated on previous passes could be used he gave an algorithm to determine whether an attribute grammar could be evaluated in this way and to find the attributes which could be evaluated on each pass the iterative algorithm assumed initially that all remaining attributes could be evaluated on the next pass the dependency condition was checked if any attribute failed the check could not be evaluated it was eliminated from the current pass and the condition checked again if the condition was satisfied all attributes not eliminated were assigned to the current pass and the process was repeated the algorithm terminated when all attributes had been assigned to a pass or when it was found that the next pass could not evaluate any of the remaining attributes in the latter case the attribute grammar could not be evaluated in a fixed number of left to right passes jl suggested a m o d i f i c a t i o n of method observing with that the lefttoright is not in programming language semantics he described an alternating semantic evaluator that made every other pass from right to left showed that certain situations could be evaluated in a single pass even though no fixed number of lefttoright passes was sufficient however this proposal did not the difficulty with evaluation in passes as we shall see below the major difference between this work and that of and is in the methods used to handle partial evaluation of tree nodes the difference is a consequence of choosing an evaluation order by examining dependencies rather than the order in advance eg left to right in what follows we will try to provide some insight into how the two methods really work and how the resulting evaluators differ partial evaluation occurs when only some of a nodes attributes are evaluated during a visit so that several are required to complete the nodes evaluation in syntaxdirected translation involving only synthesized attributes information flows only up toward the root of the tree attributes of a node can depend only on attributes of its subtrees and consequently any node can be completely evaluated in one visit the situation is similar if only inherited attributes are involved when both kinds of attributes are present though there can be information flow both into and out of a subtree and the semantics may cause these inputs and outputs to interact an input to a subtree may depend on one of its outputs requiring at least two to the node a first one to make the output available and then when the input has been computed a second visit to make use of it partial evaluation can be much more complicated than this since the interaction between inputs and outputs of a subtree may depend on the context in which it occurs and the inputs needed to produce an output may vary with the details of the subtrees structure evaluation in passes the strategy used by and handles this problem by reducing it to a sequence of evaluations the is a natural consequence of starting out with a traversal order given in advance the attribute grammar is checked for in the given order and if it fails it is simplified by deleting the attribute and its semantics if repeated simplification yields a grammar then the first pass has been constructed all attributes are now treated as constants and the original grammar so reduced is submitted again to this process if successful this construction results in the decomposition of the original attribute grammar in such a way that each is in a single pass provided that attributes of previous passes are treated as constants the resulting evaluator each node several times but in a highly constrained fashion each node of the tree is visited once before any is visited a second time each gets a second visit before any gets a third and so on in evaluation is done uniformly throughout the tree all occurrences of xa must be evaluated at the same time on one sweep through the tree evaluation in passes runs into when nested passes are required as in the e x a m p l e of f i g u r e the a t t r i b u t e g r a m m a r shown there is more easily understood if one knows that for b nodes the first visit a and yields bx while the second visit bb and yields by any semantic tree of this grammar can be evaluated by making two to each b node the c a t c h is in the s e m a n t i c s for r u l e because of the definition ÷ bob the f i r s t v i s i t to the son b i c a n n o t be made ul during the second visit to the b since bb not available until then nor evaluators can handle this grammar because there is no attribute of all of whose occurrences can always be evaluated in the first pass in our construction we treat partial evaluation directly instead of reducing the attribute grammar to eliminate it just as evaluation in passes is a natural of a priori traversal order our direct approach naturally arises from the idea of choosing a traversal order by examining dependencies we view the subtrees of a node as semantic functions of a sort unlike ordinary semantic functions they may be partially evaluated yielding some of their outputs when some of their inputs are available we use the io graphs of nonterminals to schedule to subtrees just as we use the dependency sets of semantic functions to schedule their executions a natural consequence of this is that a plan may contain more than one instruction to visit the same subtree that is a visit to a node may result in several to a this is just what is required to deal with nested passes and our construction has no with the example above in short the method of evaluation in passes treats partial evaluation by reducing the attribute grammar to a sequence of simpler ones that can each be evaluated in a single pass our method on the other hand determines the conditions for partial evaluation in a set of io graphs then proceeds with as if the subtrees were special semantic functions the result is that our evaluators are able to move around in the tree in a more general way and can therefore handle a larger class of attribute grammars b bb parse b graph production b b bb b b yb b xb ai b y ÷ b b l f i u r e ir j a b x y a b x y i b b a b x y i b b semantic tree after evaluation summary and c o n c l u s i o n s we are interested in the automatic implementation of attribute grammars because of their for specifying the semantic actions of compilers the translation from source language to target language may be described by an attribute grammar in a natural modular and way just as contextfree grammars are natural for specification of syntactic analysis we present a method for converting the semantic description into an efficient procedure for performing the translation which should be useful in a practical system three main ideas are the basis for the method proposed in this paper the first is the choice of generalized tree traversal algorithms as a framework for constructing evaluators a evaluator is a recursive routine receiving as a parameter a tree node to visit while at a node it may evaluate semantic functions or call itself recursively to visit sons such a sequential evaluator avoids the of simulating parallelism on computers the second idea is using dependency analysis to choose evaluation orders the body of a evaluator is constructed by scheduling attribute evaluations in an order which will satisfy the dependency constraints when executed enabling the evaluator to do its work without considering data dependencies at run time eliminating the overhead of a runtime scheduler greatly improves the efficiency of evaluation the power of this approach is by the third main idea the use of io graphs of nonterminals to schedule to subtrees the sons of a node are treated as special semantic functions which may be partially evaluated to yield certain output attributes when only some of the sons input attributes with the relationship between each nonterminals inputs and outputs being given by its io graph the process of dependency analysis is able to determine at which points recursive calls should be made this builtin knowledge of dependency constraints allows the evaluator to always go directly to the next point of evaluation so that nondeterminism or searching through the semantic tree is necessary the principle of our construction is to make a plan of action for every situation arise during evaluation the notion of evaluation state is introduced to model the relevant aspects of the situation at a node the algorithm performs dependency analysis in order to find a sequence of instructions that may be executed upon a given situation or evaluators are constructed by an iterative process which repeatedly new situations which can arise and makes to deal with them at the same time a is built up which the completed evaluator will use to select for execution the main data structure during construction is the history graph which gives all possible evaluation sequences at a node in the form of a flowchart the resulting evaluators may easily be generated directly in machine code the construction given here will work for attribute grammars which are for a grammar in this class an evaluators action at a node need not depend on the structure of the nodes subtrees the relaxation of this restriction to include into subtrees is d i s c u s s e d in wa and will be the subject of a future paper references a i n d e x e d g r a m m a r s a n e x t e n sion of contextfree grammars ieee conf record of th annual symp on switching and automata theory austin texas october aho av and ullman jd properties of syntaxdirected translations j c o m p u t e r systems sci v p p au aho av and ullman jd the t h e o r y of translation and v prenticehall nj bi gv semantics evaluated from left to right no de june b gv semantic equivalence of syntactically related attribute grammars no de november cu k a t t r i b u t e d g r a m m a r s a n d l a n g u a g e s no d e p a r t e m e n t e de may d ta a d e c l a r a t i v e s e m a n t i c definition of pl computer science department october f i f o l d s a d e c l a r a t i v e f o r m a l language definition system comp sci dept stanford univ december gh s and hopcroft j s c a t t e r e d context grammars scientific report system development california i et t o w a r d s m o r e v e r s a t i l e mechanical proc symp on applied math v pp jl m on attribute grammars and the semantic specification of program ming languages phd thesis comp and inf sci dept case university october j m live variable analysis attribute grammars and program draft dept of comp sci univ of n hill nc march knuth de s e m a n t i c s o f c o n t e x t f r e e languages math systems theory j v pp kn knuth de semantics of contextfree languages correction math systems theory j v p kn knuth de the art of computer vl addisonwesley park california ls lewis pm and re syntax directed jacm v no pp july na d and m removal of invariant statements from nested loops in a single effective compiler pass sigplan notices v no pp march r sl dj grammars and classes of formal languages jacm v pp january re and lewis pm property grammars and table machines information and control v pp vw van a et al report on the algorithmic language algol v pp wa sk the efficient evaluation of attribute grammars ma thesis dept of math sci rice texas april wt a d e c l a r a t i v e s e m a n t i c definition phd thesis comp sci dept stanford university wi wt formal semantic using synthesized and inherited attributes formal semantics of languages ed prenticehall 
procedure environments in sl e f r e d e r i c k c e david r and richard a department of computer science the university of sl is a programming language developed for experimental work in generalized pattern matching and highlevel data structuring and access mechanisms this paper describes the procedure mechanism and the conventions for the interpretation of identifiers in sl procedure invocation in sl is decomposed into the separate operations of context creation argument binding and procedure activation and allows sl procedures to be used as recursive functions or this decomposition has led to rules for scoping and for the interpretation of identifiers that are different from those found in other programming languages several examples of sl procedures are given including a based on the coroutine model of pattern matching i introduction the snobol programming language has been used as a basic experimental tool for recent research in generalized string pattern matching and advanced data structure manipulation until recently the approach has been to extend or modify existing snobol implementations in order to in these areas the formulation of the coroutine model for pattern matching and the introduction of scanning procedures based on that model have made this approach the procedure mechanism required by the coroutine model a more research than is provided by snobol and other existing programming languages motivated primarily by the requirements of the coroutine model the sl p r o g r a m m i n g language has been developed and implemented as a research tool for experimental work in the areas mentioned above the purpose of this paper is to describe the procedure mechanism of sl and the conventions that have been chosen for the interpretation of identifiers in sl sl provides a coroutine mechanism that is based on a generalization of recursive procedures in which ordinary recursive function use is a special case the conventions for the dynamic interpretation of identifiers have been designed to facilitate the insertion of procedural abstractions into prior or this work was supported by the national science foundation under grant builtin procedural abstractions for example the conventions allow the extension of the patternmatching by the inclusion of scanning procedures the dynamic interpretation of identifiers used in sl is conceptually simpler than that used for programming languages such as algol whose scoping rules are too restrictive for general coroutine programming for example procedures require special handling in algol in addition the conventions provide for the necessary communication that is convenient and suitable for applications requiring backtracking such as scanning procedures the sl p r o g r a m m i n g language experience with snobol has motivated some of the features of sl eg sl is a language in the same sense that snobol is a variable can have a value of any datatype at any time during program execution a mechanism is also included in sl some parts of the language however are derived from the to include facilities that are not commonly found in programming languages and for which snobol is for example the syntax of sl is and the control structures are similar to those in algol an expression returns a value and signals either success or failure as in snobol control structures are driven by these signals rather than by boolean values for example the expression if x y t h e n x x y else y y x first evaluates the expression x y if that e x p r e s s i o n s u c c e e d s x x y is e v a l u a t e d o t h e r w i s e y y x is e v a l u loop constructs are controlled in the same manner while e i do e repeatedly evaluates e as long as e succeeds a sequence of expressions can be together as a single expression u s i n g the b e g i n end c o n s t r u c t o t h e r typical constructs are included and have interpretations consistent with the mechanism procedures in sl are data objects and an identifier can be assigned a procedure as its value for example the expression f w h i l e x y d if x y then x x y else y y x succeed x end assigns to f a procedure that computes the greatest common of its arguments the decomposition of procedure activation in most programming languages the invocation of a procedure is considered an atomic operation in sl procedure invocation is decomposed into several distinct components available to the programmer at the level the invocation and execution of a procedure requires the creation of a context the binding of the actual arguments to that context and the resumption of the procedure represented by the context in sl the conventional function notation e n for the invocation of a procedure is decomposed into the steps tl c r e a t e f t tl w i t h e l e e n resume t the operator create takes a single argument of datatype procedure and returns an object of datatype context this data object is a context for the execution of the given procedure argument binding is accomplished using the with operator that binds the actual arguments e i through en to the indicated context the actual activation of a procedure is accomplished by the resume operator which takes a single argument of datatype context resume causes the execution of the current procedure to be suspended and the execution of the procedure represented by the given context to or continue the operations succeed e fail e result in the of the execution of the current procedure and resumption of the instance of the procedure these operations are equivalent to return in the recursive case the indicated signal success or failure and value are transmitted and become the signal and value of the resume operator this decomposition provides the for sl procedures to be used as recursive functions or while this decomposition is useful and necessary in some coroutine programming situations the abbreviated notation may be used for the usual en invocation the i n t e r p r e t a t i o n of i d e n t i f i e r s the interpretation and scope of identifiers that appear in a procedure are determined by declarations in many cases a procedure invoked in the standard recursive fashion needs some mechanism for communication in contrast a coroutine often requires that some data be from any other coroutine the declarations in sl are motivated by the need for dynamic communication between instances of procedures and the need for identifiers whose values cannot be modified by any other procedure public and private identifiers declarations have the form v u v n e v vn public identifiers allow for dynamic communication between instances of procedures a public identifier is accessible to the procedure in which it is declared and in any other procedure whose context is within the dynamic scope of the context for the procedure containing the public declaration when sl procedures are used in the standard recursive fashion the interpretation of public identifiers is equivalent to the dynamic scope of identifiers in snobol private identifiers are available only to the procedure in which they are declared the value of a private identifier cannot be examined or modified by any other procedure this type of identifier is used for example in situations where a procedure must remember information in order to be able to reverse effects during backtracking unless otherwise declared the formal parameters of a procedure are considered to be private identifiers free identifiers free identifiers are those that do not appear in any of the declarations in the procedure in which they are used the interpretation of this type of identifier is dynamic and occurs at the time of the creation of a context for the procedure that contains the free identifiers the interpretation is obtained by examining the current state of the creation history tree the creation history tree provides information concerning the history of the creation of contexts during the course of program execution the tree grows whenever a create operation is performed and is upon the destruction of a context the actual tree consists of among contexts that result from the create operation an example of a creation history tree is s h o w n in f i g u r e i the n o d e s of the tree in figure i represent instances of contexts for particular procedures an arrow indicates the between a context and the context that caused its creation the subscripts on b f i g u r e i a c r e a t i o n h i s t o r y tree denote specific occurrences of a context for the same procedure contexts with a common ancestor but that do not share a common are referred to as parallel contexts serial contexts are those in which creation history follows lines b i and b are serial contexts b i and b are parallel contexts the context for the procedure in which public identifiers are declared is said to be the of those identifiers as described above public identifiers are available to their and to any procedure whose context is a descendant of their in the creation history tree the dynamic interpretation of free identifiers is determined by the history of serial contexts a search is performed along the for the first context that contains a public declaration for the free identifier ie for the of that free identifier if the search is successful the free identifier in the particular instance of the context refers to the public identifier located in the in figure l assume that the procedure a that is the procedure represented by a contains the declaration public x and that procedures b and e contain x as a free identifier at the time of creation of the contexts b i and e the interpretation given the free identifier x is the common public identifier x in the c o n t e x t a in this case the c o n t e x t a is the of the public identifier x during the execution of b i and e x can be used for communication b e t w e e n a e and b i as another example consider an identifier y declared public in both d and e but that is free in b in this case the interpretation given to y in b refers to y declared public in d whereas in b the free identifier y refers to the identifier d e c l a r e d in e communication between the serial contexts b and b w h i c h are i n v o k e d in a recursive fashion can be by reference to a free identifier such as x in b that is d e c l a r e d p u b l i c in a this interpretation of free identifiers allows procedures with instances of either serial or parallel contexts to communicate via public identifiers declared in procedures that are represented by their common ancestors in the creation history tree since private identifiers are not considered during the interpretation of free identifiers their values are from any other procedure activation the root of the creation history tree is a context for a main procedure in which conceptually all builtin identifiers are declared public and are initialized to their values before program execution begins the root context contains for example identifiers that have builtin procedures as their initial value unless explicitly declared otherwise when these identifiers are used as free identifiers in procedures the interpretation made is the value of the builtin identifier in the root context the search of the creation history tree may fail to provide an interpretation for a free identifier there are several possible solutions to this problem perhaps the most reasonable solution is to consider this situation a programming error an alternative is to provide an implicit public or private interpretation for the identifier if an implicit public interpretation is chosen either the active context or the root of the creation history tree could be chosen to be the of the identifier e x a m p l e s of a procedure since a procedure is a data object public identifiers provide a convenient means for the dynamic of a or builtin procedure within a subtree of the creation history tree for example assume the procedure represented by bi b and b in figure i contains the expression j lengths and length is a free identifier in b at the time of the creation of the contexts b i and br an interpretation for length is assuming that the procedure represented by e does not contain a public declaration for length the interpretation made is the builtin identifier length whose value is a procedure that returns the number of characters in its argument if the identifier is declared public in the procedure represented by d and assigned a procedure as value the effect is to cause the of length in the instance of procedure b represented by the programmer monitor the use can use this facility of certain procedures or extend the domain of a procedure or operator to different types of arguments a generator of random number generators the values of private identifiers in a context for a procedure characterize the state of that instance of the procedure as such they provide a mechanism for the of a given instance of a procedure for example consider the procedure defined as follows p r o c e d u r e p r i v a t e repeat begin s p cm succeed s n m i end end the procedure computes a random number using the linear congruence method a context for computes the next random number within the range i to n in the sequence defined by the parameters s p c and m a context for is parameterized by the values of the arguments to and generates the next random number from an independent sequence every time it is thus any number of generators may be created using a common procedure it is the context for each instance of that is the generator for example the expressions gl create with g create with g create with assign to gl g and g three separate contexts for each of which generates a distinct sequence of random numbers to obtain the next random number in a sequence the execution of the desired context is eg x resume g the data structures that are usually needed to effect the type of desired for are unnecessary in sl private identifiers allow the data to be implicitly stored as a part of the context for the procedure moreover since a context is a data object a procedure activation and its associated data can be manipulated as a single object the patternmatching part of the motivation for the procedure facility in sl comes from the coroutine model of pattern matching the conventions adopted for the interpretation of identifiers facilitate the interaction between the builtin and scanning procedures and scanning procedures in addition the procedure mechanism is sufficiently general to allow the to be written in sl for experimental purposes without any of its capabilities an sl implementation of the given below illustrates the need for the conventions as defined the patternmatching has two arguments a subject and pattern the pattern contains the information necessary to direct the analysis of the subject string in the coroutine model the analysis is performed by scanning procedures which are invoked as it is the use of public and private identifiers in the scanning procedures that is of interest in this example further details of the coroutine model are given in r e f e r e n c e s and patterns in as in snobol are data objects a pattern can be as a tree of nodes in which each node has three fields and arg the field contains the scanning procedure which is an object of datatype procedure the and arg fields contain arguments supplied for the scanning procedure when the pattern is constructed a pattern is constructed by a procedure and the actual matching is performed by the associated scanning procedure for example constructs a pattern shown in figure whose field contains the scanning procedure which attempts to advance the cursor position by n characters during matching a scanning procedure is called with a single argument the node in the pattern that caused its invocation arg i j arg f i g u r e the p a t t e r n c o n s t r u c t e d by unlike pattern matching in snobol such as alternation concatenation are themselves scanning procedures that perform only control operations the procedures for these operations in sl are denoted by the operators and respectively and are the associated scanning procedures for example figure illustrates the pattern constructed by the expression p len len pattern matching is by the creation and resumption of the scanning procedure given in the root node of the pattern passed to the matching proceeds as scanning procedures in the pattern are a successful match is by the resumption of the with a success signal thus the can be written in sl as follows scan subject private pattern public cursor private e cursor o e c r e a t e s p r o c p a t t e r n w i t h p a t t e r n if resume e then succeed else fail end · figure a pattern communication between scanning procedures and the is provided by the identifiers subject and cursor which are declared public in scan the value of subject is the string that is to be scanned and the value of cursor indicates the position in the string that is to be examined by a scanning procedure the interpretations of the free identifiers subject and cursor that appear in scanning procedures are made when a context for a scanning procedure is created and refers to the public identifiers in the in the creation history tree the use of subject and cursor in scanning procedures is illustrated by s l e n p r o c e d u r e p r i v a t e p private c c cursor c u r s o r c u r s o r a r g l p if cursor cursor then succeed c u r s o r c fail end note that is more general than the corresponding snobol primitive since its argument may specify a negative integer thereby causing the cursor to be by convention a scanning procedure is with a success signal as a request to search for alternatives it fails if it cannot find an alternative in addition before a scanning procedure can fail it must reverse any effects such as cursor movement that it caused during matching private identifiers are used within scanning procedures to retain values that are necessary in order to reverse effects during backtracking in the procedure for given above the private identifier c is used to save the previous value of cursor does not alternatives so if it is after success it cursor to its previous value and fails subsequent resumption of a scanning pro that has failure is a programming error scanning procedures that perform control operations such as and do not examine or modify subject or cursor they other scanning procedures in order to implement their specific control relationships for example the scanning procedure for a primitive version of can be written as follows p r o c e d u r e p r i v a t e p private e e c r e a t e s p r o c a r g l p w i t h while resume e do succeed e create s p r o a r g w i t h while resume e do succeed fail end this primitive implementation of does not provide for reversal of effects caused by arguments that contain alternatives a complete version of is given in reference the procedure creates a context for its first argument and its execution as long as it succeeds succeeds if the first argument fails indicating that no further alternatives exist creates a context for its second argument and its execution as long as it does finally signals failure only after all of the alternatives for both arguments have been a scanning procedure may invoke the since subject and cursor are declared in scan each instance of scan becomes a for new occurrences of these identifiers the free identifiers subject and in scanning procedures that are invoked in the course of pattern matching controlled by the nested instance of scan refer to those identifiers in that this is i l l u s t r a t e d in f i g u r e w h i c h shows a creation history tree containing two instances of scan indicated by s i and s and six instances of scanning procedures ci through c ci causes a nested invocation of scan thus s i is the of the subject and cursor referenced in ci c and c while s is the of those identifiers in c c and c f i g u r e a c r e a t i o n h i s t o r y tree for the the builtin is implemented in the same fashion as scan viz subject and cursor are treated as public identifiers in each instance of the builtin thus the concept of public identifiers and the interpretation chosen for free identifiers are what permit scanning procedures to adapt themselves to the builtin mechanism they also make possible the replacement of the builtin by a procedure such as scan which is able to interact with either builtin or scanning procedures c o n c l u s i o n s the determination of the scope of identifiers is a persistent problem in programming language design the static scoping conventions of most highlevel languages such as algol are due in part to the atomic nature of traditional procedure activation it is that in order to support the decomposition of procedure activation described in this paper the static mechanisms are and additional language features are required in order to perform functions such as backtracking the decomposition of procedure activation into separate components gives the programmer the control at the level that is necessary for applications that involve sophisticated processes this decomposition and the implications of program manipulation of procedures and contexts as data objects have motivated the scoping conventions and dynamic interpretation of free identifiers used in sl the effect is a means for communication as well as a method of avoiding interference initial experience indicates that the sl procedure mechanism does provide a research tool of sufficient generality for in the areas mentioned at the beginning of this paper the facilities allow significant language extensions to be made without changing the base implementation of sl for example the can be written completely in sl without loss of generality as illustrated by scan the ability to create and manipulate procedure contexts independently of argument binding or invocation allows the programmer to adapt the general mechanism to a specific experimental application references i d g and b a model and stack implementation of multiple environments communications of the acm vol no i october j n a generalized facility for the analysis and synthesis of strings and a model of an implementation snobol project document d the university of february f c and j n a procedural approach to pattern matching in snobol proceedings of the acm annual conference november r e extensible pattern matching in snobol proceedings of the acm annual conference october r e and d r an overview of the sl programming language sl project document the university of j c jr advanced data structure manipulation facilities for the snobol programming language phd dissertation the university of may knuth d e the art of computer programming volume algorithms addisonwesley reading mass p c j and b an implementation of backtracking for programming languages proceedings of the acm annual conference august 
on the covering of left recursive grammars a free university department of mathematics amsterdam the abstract in this paper we show that some ideas on the elimination of left recursion in a context free are not valid an algorithm and a proof are given to show that every proper context free grammar is covered by a keywords cover grammar parsing contextfree introduction there exists a wellknown method for left recursion in a contextfree grammar the motivation for eliminating left recursion is for example that certain parsing algorithms do not work for grammars however with this usual method the of the original grammar cannot in general be in a simple from the of the grammar obtained by this method that is the new grammar does not cover the original grammar there has been some research on the covering of grammars by grammars which are in a certain nor form in general the possibility to cover a grammar depends on the definition of cover which is used examples of those definitions can be found in ip and and we will discuss them as far as necessary for our purposes in the next section in en some remarks can be found from which one could conclude that elimination of left recursion changes the structure of a grammar in such a way that there is no covering grammar however in our and not only in the case of elimination of left recursion the relation between changes of structure whatever is meant by structure and covers is not so close as suggested this point is also discussed though rather in the next section in the case of of left recursion we show in section that this can be done in such a way that the grammar obtained covers the original grammar in the remainder of this introduction we give some definitions and notational conventions in section we discuss the definition of cover and the usual algorithm for eliminating left recursion in section we give our algorithm for eliminating left recursion which is just a slight variation of the usual method and prove its correctness and its covering property moreover we give an example of the use of this algorithm and we conclude in section with a result which was inspired by a more practical consideration of the elimination of left recursion we review grammars some basic concepts concerning formal this material can also be found in definition a cfg for short is a g where n is the alphabet of z is the alphabet of terminals n n i the empty set n u v s e n and the set of productions p is a finite subset of n x v instead of writing aa k we write a a in p let u v c v then u v holds if there exist x y w v and a e n such that u v we write if xe u v we write u v and if k the closures on v of these relations as the set are written as while the transitive s and r lg x z s and k closures are x is the generated by g if u u u b ur then this sequence is called a derivation of ur from uo if relation instead of a is used then the relation this sequence or the e is said to be a derivation or a rightmost derivation respectively if in a leftmost or a rightmost of ur from uo for each o i r ui is obtained from ui by applying production iii ai yi then in the case of a leftmost the left parse sequence rl is of u r from uo and in the said case to be a of a rightmost derivation the sequence no is said to be a right parse of ur to uo if u s then each ui o ir is called a form a cfg g is said to be ambiguous if there is w c lg such that w has at least two left a nonterminal a is said to for some a e v x where definition let z and e be alphabets a function f from xl into z is extended to a morphism from z into z by the conditions fe e and an fan where e is the empty string and ai s i n is in z the homomorphism f is called each a e i fa e x u s fine if for definition a cfg g n z p s is said to be reduced if each element of v appears in some form and each nonterminal of g can derive a string of terminals cfg g is said to be free if there is no derivation of the form a a for any a e n g is said to be if there are no productions of the e where a s in p in the sequel we will only md consider a cfg grammars which are reduced g is said to be if it is reduced a nonterminal and a is said to be if a a for e v a cfg g is said to be left recursive if g has at least one nonterminal a cfg g is said to be in normal where if g has only productions a c z and a c n or s of the e form a aa elimination of first we give the usual method for left recursion our is a proper grammar g n x p s where algorithm n al a an let the be ll p where ki no j j s p begins with a if k replace these productions by ai and ci is a new if i n then halt otherwise set i i replace each production of the form by the productions ai where aj all the if j i go to step otherwise set j j to step in general we want to compare the of the original grammar g with the of a grammar g obtained from g by transformation therefore we give a definition which can be found in we assume that the productions of each grammar are for identification we identify these numbers with the productions definition g n xp let g n s be two z p cfgs s and such that lg lg in the following two conditions x and y are variables with domain left right let w q lg and let h p p be a homomorphism such that i if t is an for w with respect to g then hm is a for w with respect to g and ii if it is a for respect to g then there exists r such that r and is an of w with respect to g if in i and ii both x and y are replaced by left then g is said to g if both x and y are replaced g by right then we say that g if x is replaced by left and y is replaced by right then we say that g g the of complete cover given in can shown to be equivalent to the definition of right cover given here if the h is fine example g with the only g with productions production s ab h is defined by h g cannot cover g with a which is fine in this paper we will only make use of a fine homomorphism therefore the definition of right cover used here and the definition of complete cover in are equivalent now we can ask whether it is possible that a grammar gf obtained after eliminating left recursion from a cfg g covers g therefore we consider the ing two grammars g and g only the productions are displayed g with productions so sl g with productions o sl co cl g is obtained from g by eliminating left recursion according to the algorithm it can easily be verified that g neither nor right covers covers g in this g but that case we have is not true g lefttoright in general which can be seen by eliminating left recursion from the grammar g with the following productions so sl aa ao al now consider the grammar g with productions sc sd do dl e co cl in this case we have g g where the h is defined by h h h h h h and h which was already indicated between parentheses after each production displayed above g is not and in the following section we shall show that this is not by notice that the parse trees of g do not differ very much of the parse trees of g the parse trees have the same skeleton however g is in normal form while g is not this will turn out to be essential at this moment it is necessary to look at some marks in the literature first we quote from pi we would like to say g covers g if given a parser for g one can construct a parser for g the motivation for this is that parsers typically handle grammars in some normal form presented with an arbitrary g it may be possible to trans form it into a grammar g t which is in this normal form in what cases can a parser for g be used to produce a parser for g for example simple top down parsers will not rules which allow a and string x however ax for some nonterminal given a grammar g there a is a grammar g equivalent rules to g which has no such can one construct a parser for g given a parser for g we shall prove that the answer is no given our definition of covering however the proof is introduced ing remark p with the follow we now on the proof of another negative result by a grammar which cannot be co by any grammar in form thus the elimination of left recursive changes the structure of a grammar sufficiently that it cannot have a covering grammar and then a proof is given that cfg g we above cannot be by a cf in to us it is not clear why one can conclude from this that the elimination of left recursion plays such an important role we can find the same in from which we quote p we should observe that the condition of cycle freedom plus no is not really very restrictive every contextfree language without e has such a grammar and moreover any contextfree grammar can be made and by simple transformations what is more if the grammar is unambiguous then the modified grammar left and it recursion is a more condition in this sense while every contextfree language has a grammar there may be no covering we do not know whether the first part of these remarks elimination of is correct however for the second part elimination of left recursion in the reader is referred to the cfg g which we already discussed is on the contrary a grammar for above and which which we can find a covering grammar in the next section we shall show that this remark is not correct on the covering of grammars in this section we give and prove the correctness of an algorithm for the elimination of left recursion in a cfg such that the cfg ob the original grammar algorithm input a proper elimination of left recursion cfg g n z p s g is left recursive output a cfg g which covers g the following notations are used let n a a ar the notation j k means that the production j is mapped on a production k of grammar g initially we have for each production k k this notation if necessary is extended to j p k ka kp or we say that the productions jl mapped on the productions k k of the ks l i s p may be e kp jp are some set i let the ai productions be b bn ii im where each bi j s n begins with a terminal or some ak such that k i o go to step replace these i ca by s s ee a i im am an im m mn where c d and a are nonterminals newly introduced if i r let g be the resulting grammar and halt otherwise set i i let be all of which the hand sides begin with nonterminal a we distinguish between two cases a ad b a qj is defined suppose we have ac j j jj s and xl s s sp where x p nonterminal may be a terminal replace each production ik or a k q by rk and add productions for s k p h qa j jj h q j q k e e sl where h and q s l p are newly introduced nonterminals b j is not defined suppose we have a x x j ss sp where x nonterminal p may be a terminal replace each production a ay rk by or a rk and add productions h j where h j nonterminal sk for s l p is a newly introduced i go to step otherwise j j to step set end of the algorithm to prove the some additional correctness notations of this algorithm let a c v then we need we have la is the language generated from a su is a sentence in la is a right parse of sa to a ra is the set of right of in lu to a example let g be cfg with s abc aa productions cd then n and if for a certain n n o then n for this sentence notice that since in general g may be ambiguous that is one sentence may have more than one right parse is a set of right however the proof is such that without loss of generality we may assume that is the representation of one of the right in and therefore we can handle as a string in the parse use a i a trees or we display we will if possible a a b cl where a xx xn rather than a x r x a b xl x x n theorem proper left recursive contextfree is by a free grammar proof let g n i p s be a proper recursive cfg we use the notations given above and in algorithm hence n aa ar the cfg obtained after applying algorithm is gn s we have to show lg lp g g and g is in the algorithm a sequence of grammars is obtained in the following way the algorithm starts with cfg g g hence i in the algorithm step produces cfg g hence i and j in the algorithm step is applied and gives cfg g for i step is again applied obtained for i and j step and cfg g is is applied result g and for i and j step is once more algorithm applied halts and cfg g is obtained if has been reached the hence each g il is by applying constructed step from g kk of the algo rithm each i and k i is from g where of j k ­ by applying step claim the transitions from to by step where i k and from to by step k j and c k s i are preserving proof of claim notice that initially we start with lg and g g g and since the relation is transitive we can obtain g g first we are concerned with step transition of g to g i k kk in g we have kk productions which b lb we label with a in l a we obtain am and the productions n c c i i dl d i a a a b b b n c we can verify that this transformation is language preserving by comparing trees in and in with roots ai and that since ci di and a are new nonterminals which can only be derived from ai these trees can be considered independent ly from the rest of a parse tree a aa a a a l l parse tree in ada al u parse tree u in suppose we have a sentence w in la then this sentence has the form w sl where s l s n the are between and m and in a leftmost derivation p successive p o have been used let p then to ai is of the form in g a right kk parse for w and in g we obtain for the pa up right parse the form a oo hence h if we define up c with sm hc hd c where e can be verified by considering the case p o each other production of mapped on itself by h is now we treat the transition of a cfg of the a cfg where by step t j in the productions are labeled with y y we first consider case a of the algorithm hence we have in the productions cl c d d al a am bb bn t t notice that the values of m n and q depend on i and j of the algorithm since our notation will be clear we omit indices in we obtain by step a for each production where k q the productions which we label with k yk cj jj e we also obtain productions b if we observe the parse trees for respect consider to g and lj subtrees g it is lt with roots again a sufficient a with to in g lj in g lt for every combination i j i step a of i and j i s r and is done once at most it will be clear from the possible and that the transformation parse trees in g lj in step ha is language preserving to observe the we only consider the that in the figures given above j dd be treated similarly is used the case a c can dd if we have a sentence w in then it is of the form w s xl sa and a right parse of w to a with respect to g is ij bk rs a c of the yk form and a right is parse of w to ai with respect to b c now it is clear that we can define the morphism h such that hb b c g where lj hc c yk s k k q each other production of is mapped on itself by h the definition c can be verified by considering the case ac now we consider case b hence cj is not suppose we have the following in g lj we label for these p a p productions we obtain by step with bl b b for each b p production yk where k q the productions with labels yk i and we obtain also the productions b h i p t now in the same way as was done in case a one can verify that to obtain a one has to define hb b i p yk e p and k q and each on itself other production of g has to be mapped it by h since now we can conclude that step and step are language and cover preserving we conclude g g notice that with algorithm we obtain immediately the for g and g since every production obtained after a transformation is immediately related to the production of g as indicated between parentheses after each production in the algorithm claim g is proof of claim first we notice that since l obtained in step of the algorithm may be the empty string g does not have to be proper we make the following observations observation let and denote the languages obtained from ai in g and g the transformations on the productions in step and in step are such that for each i we have since g is a proper grammar we have and ci in g ai e and ci e for each a observation for each d introduced we have di e to show this we first in step prove the following property suppose we are in algorithm at the moment we want to do step for non terminal ai let ai yk be a production in where i k then we have the following property if yk the proof of then li this property ai in g is by induction on i basis a production then a yk for k is also in g c then since g is proper e ence induction suppose this property holds for all p such that p i we prove that we may conclude that we may conclude that this property also holds for i where i s k in if a if y e is also in g then we have ai l ing is not in g hence this pro is constructed in step of the algorithm and therefore it is of the form h j k to obtain production this production we started with a in g where i jl and in notice that the use of indices here is some what different of the use in the algorithm if they are not necessary we omit the upper indices of the nonterminals h and q see step by ji is meant j with index i step we used the productions aa j j yn g g jl jl g respectively jn jn according to step we have jp of if p q and thus by the induction hypothesis a jr for k s n and a a k a jl s n therefore we have ai aa i completes the e proof of the property in g ir k now let k i in this property then if di e in g and hence g which contradicts in g we obtain a a in the fact that g is a proper contextfree grammar for each ai we have ai is not recursive we prove this also by induction the following two properties of the algorithm after step is executed for i all ai productions begin with either a a terminal or a nonterminal ak k i or b the begin with a terminal or with a nonterminal ki after step is executed for i and j all begin with a terminal or with a nonterminal a k recall is the that n al a a number of in the r of which proof the m sides begin with ai see step of algorithm we define the score of an instance of to be ri the score of an instance of is ri j where s j i we prove and by induction on the score of an instance of these statements basis for i we only have instance the transformation in step is indeed such that if m o all begin with a terminal or with a nonterminal ak for k i and if m then the begin with a for convenience we give the productions in g g jj etc instead of the productions a c jl jl and c j etc induction or a nonterminal ak for k i assume and for less than s such that r and ri j s since rj s all begin with either a a terminal or a k or b cj and the begin with a terminal or a since the transformation in step is such that each new begins with the of an aj or production and if this symbol is a non terminal j we see that each begins with a terminal or a nonterminal fork j assume and for less than s and let i be such that ir s since ir j s we have that all with a terminal or a a k hence for k i if in step m o we have that all begin fork with i a terminal or a nonterminal if m we see that after a k the transformation all begin with the first symbol of the which begin with a terminal or with a nonterminal a for k i this completes the proof that each ai is not observation from the two properties in tion it observation is clear that a nonterminal and it each i h j follows os j that a cannot r from for each i neither ci nor pi can derive c moreover d h o s j r since this would j mean there is a nonterminal a o s k r which k can nonterminal h j a can only tie introduced in a derivation or are by the productions productions with and ad since lefthand ci c a da side a and di e the only recursive qi e is that however which is not true possibility for a to be left a can h and then also therefore d can for each i a h and also di are not verified that for each i easily can be ci is not observation for each i we have hi and qi are not we omit again the upper indices the proof of this statement is by in on i first we assume that the ds in step are not equal to e basis let is defined j be the smallest integer such let aj x o in step that h j or ac ji obtain and in step or and qj respectively since there are no other nonterminals defined before can only begin with h p a terminal or a nonterminal a s k s r a nonterminal k cannot a nonterminal h p p induction we prove that hi cannot a k r a nonterminal h p the nonterminals if p i therefore we assume h for t i cannot t left derive suppose a nonterminal if p t p hi is introduced for an that that is in step we transformed a production y where q i of g and after all steps fr this production have been executed the result is a k where x is a terminal or a nonterminal fork k the last production which was applied in step is then of the form ax or and moreover we obtain the production hi or and qi if begins with a terminal or a nonterminal s k r then nonterminal h p the other since p a cannot k hi is not possibility is that begins a k a with a nonterminal induction hypothesis this completes the h where p p h cannot p proof of the i then induction by the h step now assume e then we can have h derive hi a it is however a easily possible cannot give a proof of this statement analogous to the proof given above where instead of the s of step we have to consider the us of step since the nonterminals we immediately obtain h are not that the nonterminals qi are not this completes the proof of observation since we must conclude that all the nonterminals are we have finished the proof of claim and therefore of theorem before closing this section we give an example of an application of algorithm we use a grammar which was also used in p the cover homomorphism of g to g is obtained between after each production hence we immediately relate every production obtained in the mation to a production of the original grammar g example consider the cfg g with productions a aa a aa we follow the steps of the algorithm il remains i j replace where by a h replace i aa by ac i ca ee ad i da e e a i j where by j replace where ec and c aa by h qa h q e e qa h q s h q e q replace by ee ad ec the resulting while g see below the original grammar has pro had product ions the usual method yields productions the usual method was given in section the cfg g has the following productions e ee ha ad ee ee a h ee h ee q al q h notice that g is not proper since he lefttoright cover in the preceding section we saw that each grammar g can be by a grammar g if we look at the parsing problem then we want to eliminate recursion since a certain parsing method will not work for a grammar we want to make the grammar for this topdown parsing method and this means in general for a parsing method which produces left however our is only concerned with right fortunately we can give the following theorem this theorem can also be found in in a slightly different form theorem let cfg g g then there is a cfg g such that g covers g proof let g n x p s g n z p s by h we construct a new grammar g n s s and where n n p s sis and each r is not already p pi up where in n p i i is inp and pn l if t i rx li is a parse tree of is inp l g for a sentence w then there is a corresponding parse tree t of g for w which is obtained from t by replacing each occurrence of a subtree t in t of the form a by a subtree t ax a of t of the form ar xi these occurrences of subtrees in t and t of these forms are said to be corresponding in t the productions i and i are said to be connected notice that if rr is a parse of w with respect to t and r is a parse of w with respect to t then for each occurrence of i in t there is only and if in t similarly one corresponding for each occurrence pair i of i in m there is only now the proof is rather one connected of simple let t be a parse tree of g for w and t its corresponding parse tree of g a left parse n for w with respect to t in which productions i and j occur can be written in all one of the i following forms j i i or b v i i j j or symmetric cases first j where i and i are connected and j and j are connected for these cases the right with respect to t can be written as a m j i for case a and b t i j for case b where i corresponds to the connected pair i and i and j corresponds to the connected pair j and j for i j a form c n z i j i j cannot occur in a left parse for i j there are no problems as can be seen in what follows since the order in which i and j appear in n is the same as the order in which i and j appear in tr we can define a homomorphism h such that for each i and i hi i i e and then g covers g with homomorphism h the composition of h and h gives the f of g right covers g that is fi hh i and fi e for each pair i and i in p d since in this theorem g is not if g is not a topdown parsing method can be used for g and the left with respect to g can be mapped on the right with respect to g we showed that some remarks concerning left recursion in the literature are not true an algo rithm was given to transform a grammar g to an that g g we showed grammar that the g such use of right in a practical in this algorithm is not restrictive situation in which we want to to have the possibility to apply there a topdown parsing are some problems method which yields we did not consider left can the elimination of be done in such a way that the result is a covering grammar according to some remarks in that we gave in section we can conclude that if a cfg is ambiguous then elimination of can not lead in general to a covering grammar and if a cfg is unambiguous then there is a covering grammar however the following grammar with productions and l is not ambiguous and we conjecture that this is not by an free grammar more we can ask to prove the conjecture that g of section cannot be by a cfg in even if we do not restrict ourselves to a fine i am to lam for some helpful comments the research reported in this paper has been carried out at the university of technology i thank ms for her and careful typing of the manuscript references aho av and unman jd the of parsing and vol i and ii prentice hall and gray j and ma on the covering and reduction problems for context grammars j assoc comput no a on the covering of to appear in j comp syst 
static analysis of programs synchronized via the priority protocol martin d d germany peter d germany abstract we consider programs for embedded realtime systems which use scheduling with task dynamically according to the immediate priority protocol for these programs we provide static analyses for detecting data races between tasks running at different as well as methods to guarantee transactional execution of procedures beyond that we demonstrate how general techniques for value analyses can be adapted to this setting by developing a precise analysis of affine equalities categories and subject descriptors f logics and meaning of programs specifying and verifying and reasoning about programs f logics and meaning of programs semantics of programming analysis d software engineering verification general terms algorithms theory verification keywords interprocedural analysis abstract domains concurrency introduction there is an inherent in concurrent realtime software between synchronization needed to preserve data consistency and execution needed to meet hard execution of tasks within a time frame yet allowing tasks to complete critical sections requires sophisticated synchronization primitives which limit the worstcase waiting time of tasks using common binary can result in a task waiting an amount of time for a task to complete a situation known as unbounded priority inversion as an example of unbounded priority inversion consider a task q which acquires a lock needed by a task q when q is ready to execute it will q but as soon as q attempts to acquire the lock it must wait for q to complete its critical section it is acceptable and necessary for the permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ austin texas usa copyright c acm sake of data consistency that a task wait for a task to complete execution of a critical section however the problem is that an task q may the task before it the lock then q is indirectly blocking the task q for an arbitrary amount of time since unbounded priority inversion the possibility of hard operating systems for embedded systems provide more sophisticated synchronization primitives than common typically such primitives are based on priority inheritance a task which blocks a task inherits the priority of that task for the of the critical section which caused the blocking this bounds the time a task can be blocked the original priority protocol ensures that a task can only be blocked for the of a single critical section in systems a simplification of this protocol the immediate priority protocol is often used this variation is also known as the priority protocol to distinguish it from the original protocol under this name it is included in safety critical java a proposed subset of realtime java the immediate priority protocol is used by the operating system which has been adopted by the software architecture an global standard in the domain it is also present in the library where it is called the priority protect protocol in this paper we will follow the usage and simply call it the priority protocol pcp the pcp relies on the concept of resources each resource r obtains a priority which is the maximal priority of tasks the resource r the scheduling of tasks then follows the dynamic priority of tasks ie the maximum of a tasks static priority and the of all resources it has acquired in this way a task a given resource will immediately inherit the priority of all tasks which could request that resource as this blocks tasks unbounded priority inversion is avoided in this paper we develop static analyses for programs synchronized via the pcp we provide methods for subtle due to the concurrency induced by interrupts specifically we focus on data races and transactional behavior of procedures moreover we explain how interprocedural value analyses can be to take and interrupts into account we this with an algorithm for inferring affine equalities the pcp was to run on systems which are the de standard for embedded realtime systems the program in figure is used as a running example throughout the paper it consists of one main task t and two interrupts i and i with and respectively higher numbers denote higher the program uses resources r and r since ie i z i ir ie i y i x i ir te t x t y t t · · · ··· t t t t t ··· ··· t zt t t t tr figure example program r is used by t and i its priority is while r is used by t and i so its priority is the interrupt i of priority the variable z to the fixed value the interrupt i increments the counter y and the counter x the main task t the counters x and y then it attempts to swap their values by means of an auxiliary variable t which receives the sum of x and y before the swap the result t is stored in the variable z this example is designed to exhibit both a data race and a behavior the resource r is held during the initialization of the main task consequently the dynamic priority of this part is the maximal priority ensuring that no interrupts may occur then the resource r with priority is acquired which will only protect against the interrupt i while i may still occur note that the interrupt i is of the resource r and yet resource r a task from being by i because the static priority of i is less than the priority of r this effect is typical for priority based synchronization an analysis which treats resources as locks though could not the possibility of i the initialization code resulting in false alarms the assignment z t may the assignment in i if i occurs at t or earlier or it might itself be if i occurs at t or later this a data race moreover at t variable y is with a value that might have become due to an occurrence of i in the example this will result in failing to correctly swap the variables x and y note that this occurs although all accesses to x and y are protected by the resource r we call this behavior the paper is organized as follows in section we present a concrete semantics of pcp programs based on execution paths we formally define the concepts of behavior and data races for programs in section we show how to analyze resource sets to determine and consequently possible interleavings in section we use the resource framework to detect races and in section behavior section shows how to extend the framework to allow dataflow analysis and we this by computing affine equations for the example program section presents the experimental evaluation of our methods for race detection and finally we discuss related work and conclude the core pcp model and its semantics our model consists of one task main with which program execution starts a finite collection of interrupt routines which we also call tasks ie task main and auxiliary procedures proc which may be called by all tasks the main task as well as the interrupt routines are distinguished procedures which may not be called otherwise for the sake of the analysis procedures are specified by means of controlflow graphs as in figure every procedure f has a designated entry node fe and return node fr the collection of all control flow graphs of procedures in proc is denoted by n e where n is the set of nodes and e the set of edges let ne and nr denote the set of all entry and return nodes respectively each edge is labeled either with a basic statement s or with a call f f proc for simplicity we consider procedures without parameters only each basic statement s is either a basic command cmd such as an assignment to a global variable or a pcp statement such as resource acquisition let res denote the finite set of resources used by the program for r res the pcp statement acquires the resource r and r we assume that at the exit node of each task all resources have been released this can be enforced eg by all resources potentially used by the task additionally we assume that we are given functions p task n and u task res which map tasks to their static from n and of the sets of resources possibly acquired during their execution in particular we assume that pq for each q to each resource r res we then assign its priority pr which equals the maximal priority of a task r ie pr r for a subset of resources r res we also write pr as a shorthand for r r where p execution paths an execution path of a pcp program is a sequence of controlflow edges labeled by basic statements into which corresponding to procedure calls or interrupts are nested the nesting of a call to the procedure f is indicated by means of the start and end tags f and f respectively interrupts are indicated analogously samelevel execution paths reaching a program point v on the same level are defined as follows · is an samelevel execution path reaching the entry nodes qe of procedures · u cmd v is a samelevel execution path reaching v if is a samelevel execution path reaching u · f f is a samelevel execution path reaching v if is a samelevel execution path reaching u u f v is a call edge and is a samelevel execution path reaching the return node fr of f · q q is a samelevel execution path reaching v if is a samelevel execution path reaching v and is a samelevel execution path reaching the return node qr of an interrupt q likewise a reaching execution path reaching a program point v not necessarily at the same level is defined as follows · is an execution path reaching the entry point of the main task · cmd v is an execution path reaching v if ¯ is an execution path reaching u · ¯ f f is an execution paths reaching v if ¯ is a execution path reaching u u f v is a call edge and is an execution path reaching the return node fr of f · ¯ q q is an execution path reaching v if ¯ is an execution path reaching v and is a samelevel execution path reaching the return node qr of an interrupt q · ¯ q is an execution path reaching the entry node qe of q if ¯ is an execution path reaching u and either there is a call edge u q v or q is an interrupt we write s and r for the set of samelevel execution paths and reaching execution paths respectively for samelevel execution paths we define the resource set after the path in terms of the resource set r before the path r r r ru cmd v r r r ru v r r r r ru v r r r r r q q r r r if q task r f f r r r r if f task this definition is extended to reaching execution paths f r r r if f task q r r if q task where is a samelevel execution path and ¯ is a reaching execution path the path semantics the concrete semantics collects for each program point v the set of execution paths reaching v taking static and resource sets into account each task starts with an empty set of resources we assume that procedures cannot be at their entry points if a task is while executing some procedure its resource set before and after the interrupt is identical while procedure calls may change the set of currently held resources let p denote the maximal static priority of all tasks and p the interval p for a procedure f let f p res s denote the function which assigns to each static priority i at which f can be called a function which takes a resource set r before a call to f and returns the set of samelevel execution paths of the procedure f including all execution paths of interrupts which possibly may have occurred likewise for j let j s denote the set of execution paths of all interrupts with static priority level j for an edge e labeled with a basic statement the concrete semantics is a function e res s which for each resource set r returns the singleton set e r e in order to put up a constraint system to characterize the sets of samelevel execution paths of procedures we require composition operators which take resource sets and static into account the composition of mappings m m res s must ensure that the sets of execution paths are according the sets of resources m m r mr mr r for interrupts we need to filter out execution paths which cannot be due to high dynamic let sj denote the set of execution paths of interrupts of priority j then we define the application of sj with a mapping m res s sj m r m r sj j pr r where the priority condition checks that the acquired resources allow the interrupt to occur the functions f p res s f proc and the sets j then can be characterized as the least solution of the following constraint system s i i s sv i u s v su i u s v e s sv i f i su i u f v e f i hf i s j q j q pq j su i j su i u ne j i here the function i is given by ir the auxiliary variable sv i for a node v of some procedure f and a static priority i describes the function which for a given resource set r at procedure start returns the set of all samelevel execution paths reaching v within f when executed within a task of static priority i the auxiliary operator hf takes a description m of the samelevel execution paths of the procedure f and it into the opening and closing tags corresponding to f ie hf m r f f m r for realtime systems it is reasonable to assume that every procedure has at least one samelevel execution path ie that f i r is nonempty for every i and r if this is the case the set of all program points which are definitely unreachable can be computed by standard means and then removed from the controlflow graphs that property s is satisfied s each program point v of a procedure f is samelevel reachable ie sv ir for every i and r this property therefore will be generally assumed in order to put up a constraint system to characterize the sets of reaching execution paths we require an operator to apply the effects m res s of edges or procedures to sets of reaching execution paths s which takes sets of resources into account we define m s ¯ ¯ s m likewise the application of a set of samelevel execution paths s of interrupts of priority j to a set s of reaching execution paths is defined by s j s ¯ ¯ s s j the collecting semantics of sets of reaching execution paths then is given by the least solution of the following constraint system r r rv i u s v ru i u s v e r rv i f i u f v e i ru i u f v e r ru i j i u ne j i rj i pq u ne j i q pq j here the operator for a procedure f task when applied to a set s of reaching execution paths the opening tag f to each reaching execution path in s ie s ¯ f ¯ s the operator when applied to a set s extracts the set of all reaching execution paths ¯ from s where the priority of the resource set is less than j ie ¯ ¯ s j the constraints s r provide values for entry points of all procedures in proc and the entry node of procedure main respectively s and r take care of all edges by applying the semantics of the edge ie the edge to the collected sets of paths procedure calls are handled by the constraints s and r in s as well as the first part of r the samelevel executions of the called procedure are composed with the executions before the call additionally the second part of r describes execution paths entering procedures the constraints s and r deal with interrupts they correspond to implicitly introducing extra loop edges with interrupt calls at every node where an interrupt may occur given that the dynamic priority of the executing task is sufficiently low interrupts are summarized by static priority levels similarly the entry sets of the reaching execution paths are summarized into one set for each static priority level according to our assumption entry nodes are from constraints s and r data races and behavior let and denote the set of all variables accessed by the basic command cmd and samelevel executions of procedure f respectively for clarity of presentation we do not distinguish read and write accesses then a data race at some global variable x occurs if program execution reaches an access to x at a dynamic priority j while x also might be accessed by some interrupt q of static priority j definition a pcp program contains a data race at variable x if there exists a reaching execution path ¯ u cmd v q q rv i for a basic command cmd with x and a samelevel execution path of the interrupt q with x in the example program of figure a data race occurs at the variable z the interrupt i has static priority and accesses z while the main task t accesses z at a dynamic priority of and can therefore be by i at t or t a possible run of the example program reaching the data race would be te t t t t z t t i ie i i z i i ir i there are no further data races in the example program since the variables x and y are only used by the interrupt i which has a static priority of and all accesses to these variables occur at a dynamic priority of at least a procedure f is considered as transactional or atomic if during every execution of f no interrupt may occur between the first and last access to global variables which accesses any of the accessed by f definition formally f is at static priority j for a resource set r if there exists a samelevel execution path f q q f f jr where the following holds · jr is a samelevel execution path which contains no interrupts · is a samelevel execution path of the interrupt q without further interrupts · and contain edges u cmd vu cmd v with and · contains an edge u cmd v with to this situation we use again the program of figure the first access of the main task t to a global occurs before program point t while the last access is after t in between eg at program point t the dynamic priority is at this node t can be by the interrupt i which changes the variables x and y also used by t therefore t is not transactional a possible run of the example program this behavior would be t te t t t i ie i i ir i t z t t t tr t analyzing resources in this section we present an analysis of sets of resources possibly held at a given program point the results of this analysis are fundamental for determining the minimal dynamic priority guaranteed to hold at this program point as well as all subsequent analyses of the program the analysis determines for each program point a set of possible resource sets the complete lattice thus is given by res sets of sets are ordered by subset inclusion at join points we therefore take the union of reaching sets for analyzing samelevel executions we associate to each procedure f an abstract semantics f res res unlike the collecting semantics f does not depend on the static priority in which a call to f is made the static priority determines the interrupts which may occur during the call of f but interrupts do not modify the sets of currently held resources in order to set up the corresponding abstract constraint system we define an abstract semantics from res res for edges u s v labeled with basic statements we define u cmd v r r u v r r r u v r r r additionally we require an abstract composition operator which for abstract mappings m m res res returns the function defined by the following equation m mr mr r mr as with the concrete semantics we compute the effect of procedures depending on resource sets they are called with the functions f res res f proc then are given by the least solution of the following constraint system s s sv s sv s f i u s v su f su f proc u s v e u f v e where the function i is given by i r r no constraints have been included to deal with interrupts the reason is that interrupts do not change sets of held resources for determining the sets of reaching resource sets we require an abstract application operator which applies a mapping m res res to a set of resource sets s res as follows m s m r r s for the sets of resource sets reaching a node v at static priority level i we consider the following constraint system r j r rv j u s v ru j r rv j f ru j i ru i q task j pq u s v e u f v e u f v e note that the constraints r not only provides an abstract start value for the entry node of main but also for the entry nodes of all interrupts q this is because every interrupt may occur for example at the exit node of main and will always start with the empty resource set note further that for reachability we have kept the information i about the static priority at which a node is reached in order to be able to determine its possible dynamic in order to relate the concrete and abstract semantics of programs we introduce appropriate abstraction functions res s res res and ¯ r res these are given by m r r r m r ¯ x ¯ x the following theorem states that the resource sets computed by the above constraint systems not only safely the set of resources by the collecting semantics but the computations are precise wrt the concrete semantics theorem let f j sv j and f sv denote the least solutions of the constraint systems s and s respectively then for every procedure f static priority i and program point v f j f sv j sv let rv j and rv j denote the least solutions of the constraint systems r and r respectively then for every program point v and possible static priority j j rv j proof for the proof we observe that for every edge e u s v e e also for composition of functions m m res s we have m m m m since furthermore the abstract functions e as well as the operation are completely distributive ie commute with arbitrary least upper bounds the first assertion of the theorem follows by fixpoint induction a similar argument applies to the second statement of the theorem let n denote the sum of the number of program points and control flow edges and o the number of resources used by the program recall that p is the number of static priority levels then the number of constraints in the systems s and r are bounded by op · n since the height of the lattice res res is exponential in the number of resources the least solution of these systems can be computed by a standard worklist algorithm in time op · n · co for some constant c typically the number of resources used by embedded con are quite small a practical implementation still may functions f only for those i r of static task i and resource sets r for which the procedure f may be called at runtime also elements in res can be naturally modeled by boolean functions which in turn can be efficiently on if these are represented through ordered binary decision diagrams the example program in figure does not use any procedures which means we have to look at the constraint r and r only furthermore each node is only reached with the static priority of its task therefore we directly obtain the following results node ie i i ir result r r node ie i i i ir result r r r node result node result node result te t r t r t r t r t r t r t r tr t r t t t analysis one interesting class of pcp programs consists of all programs where the set of held resources at a program point v does only depend on the set of resources held at the entry point of a procedure f but not on the concrete execution path reaching v more precisely we demand that for every procedure f and set of resources r the set sv j r is a singleton set r these programs are said to have resource sets such programs can be analyzed more efficiently while still being precise wrt our model the analysis presented above can be further abstracted to compute not all possible resource sets but the set of definitely held resource the domain is then simplified to res ordered by superset inclusion and intersection as the least upper bound since every program point is reachable by some samelevel execution path no bottom element is required to denote we consider the abstraction functions m res res res res and res res given by mm r m r s where is defined as res the resulting analysis is called must resource analysis the abstract functions e m res res for edges e u s v corresponding to this analysis are given by u cmd v mr r u v mr r r u v mr r r note that these now are functions of the general format gr r k g for suitable constant sets k g let f denote the set of all these functions this lattice is well known for analyses since also the abstract composition of functions as used by the constraint system s for must resource analysis becomes ordinary composition of functions must resource analysis for pcp programs can be performed by means of an interprocedural approach similarly the abstract function application becomes ordinary function application let sm denote the constraint system over the complete lattice f corresponding to s theorem assume that f sv and f m are the least solutions of s and sm respectively where sv r for all program points v and resource sets r then for every procedure f and program point v m f f m the proof is analogous to the proof of theorem the non emptiness assumptions are required as the functions from f only commute with nonempty least upper bounds since res in the analysis results of the example program of figure presented above every set of resource sets has only one element this is the case because the example program is applying m in this case just removes the extra pair of set brackets for the interrupt i we obtain eg node ie i i ir result r r for programs with resource sets satisfying assumption s we obtain corollary assume that all resource sets are assume that f sv i and f m are the least solutions of the constraint systems s and sm respectively then for every program point v possible static priority i and resource set r f ir f mr sv ir the least solution to the system sm can be computed in on · o if operations on resource sets bit vectors are counted for o in case a program with resource sets consisting solely of tasks each program node needs to be analyzed for only a single context the static priority of its task and the empty resource set however a node inside a procedure can be reached not only with different static but also with several distinct resource sets in order to deal with this situation we propose to combine the summary functions f m which can be computed in polynomial time with the constraint system r this is possible since by corollary the functions f can be from the functions f m by f r f mr data races in this section we apply the results from the last section to detect data races in pcp programs one can think of a task using its dynamic priority to against interrupts interrupts use their static priority to attack other tasks note that it is the static priority of an interrupt q which whether q may interfere with the computation of another task executing at a given dynamic priority level we there refer to the dynamic priority level an access as priority and the static priority level of an access as its priority definition assume that rv i denotes the least solution to the constraint system r we define pq x q pr i u cmd v e x r rv i where and denote minimum and maximum respectively these functions map global variables to their and respectively we have theorem if the program satisfies assumption s a data race occurs at x if and only if proof first we assume that we are given an execution path s v q q rv i for some static priority i where ¯ is an execution path reaching program point u is a samelevel execution path of the interrupt q u s v accesses the global x and also contains an access to x let r denote the resource set held when reaching v along s v and j i pr denote the corresponding dynamic priority since the interrupt q may occur after the execution of ¯ we have j pq by theorem r rv i therefore j pq conversely assume that this means that there is an interrupt q of priority which has a samelevel execution path containing an access to the global x furthermore there is an edge u cmd v accessing x together with a static priority i and resource set r rv i such that pr i pq since ru i all resource sets possibly reaching u and cmd may not change resource sets r is also contained in ru i therefore by theorem there exists an execution path ¯ reaching u at static priority i with r it follows that cmd v q q is a reaching execution path from rv i and we have a data race at x if the program has resource sets and all accesses are reachable an equivalent result can be achieved using the analysis rm in a general setting this would still yield a safe overapproximation of data races for the example program in figure and are as follows this means that x and y are safe but there is a data race at z which is due to i being possible at t more generally we can say that an access to x or y is safe at a priority of and higher while z requires priority or more analyzing behavior occurs when a fragment of a program which is meant to be executed atomically is by a task which accesses data manipulated by this fragment a write access of the task may result in inconsistent data for the program fragment while a read access may supply the interrupt with inconsistent data in the example in figure the main task switches the value of x and y and whenever accessing either one it holds the resource r exclusive access however it the resource between the two operations which allows the interrupt i to modify x and y however the old value of x is still stored in the local variable t which is used later to y this is an instance of the behavior described by definition these problems are avoided if the priority is sufficiently large not only for a single access but for the whole program fragment in question there are several subtle points to be taken into account one point is that a procedure may have leading and parts which do not access these parts should not influence the priority of the procedure another one point is that there can be calls to other procedures which might release a held resource and then perhaps acquire it again this the priority of the caller no matter where in the callee the temporary decrease in priority occurs tasks without procedures let us first consider pcp programs with tasks but no procedure calls thus transactional behavior may refer to tasks only assume that q is such a task with static priority j assume further that for every program point v of q we are given a set res of definitely held resources when reaching program point v in particular these sets allow to compute a lower bound to the dynamic priority of q when reaching program point v this value is given by pv pq let p p equipped with the reverse natural ordering for convenience we denote the ordering on pairs from p by as well for each program point v we determine values p where the first component of is the minimal dynamic priority on execution paths reaching v between the first and the last access to a global it equals if and only if no global has been accessed so far the second component is the minimal dynamic priority after the first access the pairs are characterized as the least solution least wrt to the ordering of the following constraint system let a a in let a pv a in a a u s v controlflow edge with let a a in let a if a then pv a else in a a u s v controlflow edge with let be the first component of then the task q is transactional if and only if holds for all x accessed by q where is the priority of the global x as defined in definition in case that the pcp program has resource sets also the reverse implication holds we will not prove these statements here since they follow from f x a a a a y figure priority ranges the corresponding properties of the more general interprocedural setting presented in the next subsection instead we consider our example applying the analysis to the example program from figure we obtain the following results showing only selected nodes node t t t tr ir ir in each task the return point is reachable from every program point of the task therefore the are given by we conclude that i and i are transactional since the sets of variables accessed by i and i are disjoint but t is not since the priority eg of z note that if z is removed from the program our analysis still detects that the task t does not swap x and y tasks with procedures in presence of procedure calls the dynamic priority when reaching a program point v of some procedure f may depend on the static priority j of the task which executes f as well as the set r of resources held when f has been called let denote the set of resources which are definitely held when reaching program point v then a lower bound to the dynamic priority of v is given by j moreover two values per program point do no longer suffice for analyzing since we cannot procedure parts before the first or after the last access to a global when a procedure is called therefore we determine four values a a a a the first two components correspond to the two components which have been used in absence of procedures thus the priority a is the lowest priority between the first and the last access to some global variable and a is the lowest priority after the first access to a global as before a receives the value of a at every access to a global at the return node of a procedure the value of a denotes the procedures priority additionally we compute the lowest priority obtained before the last access to a global variable in component a for that the component a tracks the lowest priority encountered the component a then receives the value of component a at every access to a global this is illustrated in figure let d denote the set of all a a a a p where a a a and a a a let the ordering on d again be the extension of the reverse natural ordering on the minimal element wrt this ordering thus is given by which the empty set of samelevel execution paths the abstract effect u s v t p × r d of a controlflow edge u s v is defined by u s v tj r j pr j pr j pr j j p rr p r s otherwise the tuple u s v tj r collects the of the execution of s with resource set r at static priority j the following constraint system characterizes the for triples u j r of nodes u static priority level j and resource sets r the resource set r denotes the set of resources held when the current procedure has been called similarly for procedures j denotes the static priority of the calling task st j t j q task j pq j rt j pr f task j p st sv j rt u s v t j t su j rt u s v e st sv j rt f tj t su j rt u f v e st f t j r j rt where abstract composition t d × d d is defined by b b b b t a a a a a a a a b a b a b a b a b a b a b note that a represents an execution path containing an access to some global if and only if the second component is less than let c c c c b b b b t a a a a the abstract composition then is defined by case distinction on whether the represented execution paths contain accesses to or not assume for example the fourth case ie that a and b thus the right represents an execution path containing an access while the left represents execution paths which do not access in this case c a because first and last accesses in both are contained in furthermore c ab as the dynamic encountered during the entire path occur after the first access to a global the third component is c a since the last access to a global occurs in finally the fourth component is c a b since this component provides the minimal dynamic priority encountered during the whole path the other cases are analogous with the exception of the first case which takes care of bottom values we have proposition the abstract composition t d × d d is distributive in each argument ie for all a b c d c t a b c t a c t b a b t c a t c b t c proof let a a a a a b b b b b and c c c c c consider the first assertion of the proposition if a b then the same case of the composition applies to as well as to c t a and c t b and the assertion follows by commutativity and associativity of the minimum accordingly assume that a and b if c we obtain c t a b a b a b c a b a b c c t a a a a a c c t b b b c b b c by inspection of each component the assertion can be verified if on the other hand c we obtain c t ab a b c a b c a b c a b c c t a c c a c a c c t b b c b c b c b c in order to prove the assertion it only must be proven for the first two columns that a b c c b c a b c c b c recall that a since by assumption on the in d c c and c c these equalities hold this completes the proof of the first assertion the proof of the second assertion is analogous assume that sv j rt and f t j r is the least solution of the constraint system st assume further that is the priority of the global x as defined in definition then we have theorem assume that assumption s is satisfied ie all program points are reachable by some samelevel execution path for a procedure f of a program with controlflow independent resource sets a static priority j and a resource set r let a a a a f tj r then the procedure f called with resource set r at static priority level j is if and only if there exists a global variable x with a proof for a given static priority level j and an initial resource set r we assign to each samelevel execution path not containing interrupts a priority tuple b b b b t j r d where b is the minimal dynamic priority between the first and the last access to a global in b is the minimal dynamic priority after the first access to the end of b is the minimal dynamic priority from the beginning of to the last access to a global and b is the minimal dynamic priority through by the definition of u s v t and t the tuple t j r is inductively defined by t j r j pr tu s v j r u s v tj r r t t j r t f f j r t j r r t t j r we extend the mapping t to sets s s of samelevel execution paths by ts j r t j r s note that according to this definition ts j r if and only if s let sv j r denote the set of samelevel execution paths at static priority j and initial resource set r reaching v which do not contain interrupts these sets can be characterized by a constraint system s which is obtained from constraint system s characterizing all samelevel execution paths by removing the constraints s by definition the operator t preserves the least element since by proposition t is also distributive in each argument it follows that j r j r sv j rt for all program points v now assume that the procedure f is at static priority level j and initial resource set r ie there is an execution path f q q f f jr such that jr is a samelevel execution path containing no interrupts is a samelevel execution path of the interrupt q both and contain an edge accessing a global and contains an edge which accesses a global variable x thus in particular pq let t j r b b b b since the interrupt q may occur between the two global accesses in and we have pq b from the definition of t we obtain that b b b b a a a a f tj r therefore pq b a ie i z i ir ie i y i x i ir te t x t y t t f tr fe f f f g f f ge g zt g gr fr figure example program with procedures conversely assume that f tj r a a a a and there is a global x such that a this means that a and that there is an interrupt q with pq which has a samelevel execution path which accesses x since a a recall that j rt j r j r t j r j r therefore there exists an samelevel execution path j r such that a equals the first component of t j r since a there exist at least two accesses to in moreover can be into where and both contain at least one access to a global and the dynamic priority after equals a since pq a interrupt q may occur between and thus by definition f is not transactional when called at static priority j with resource set r for programs with resource acquisition this analysis still yields a safe overapproximation ie transactional procedures may be considered as possibly but not the other way round alternatively the resource analysis s could be used to obtain more precise results consider the example program of figure where the part of t after the initialization has been wrapped into the procedure f and the nodes t to t of the original example program have into procedure g the procedure g is transactional since it only contains one access to a global variable the procedure f holds the resource r at all nodes between its first and last access to a global variable however the call to g the of f since it r the analysis presented above captures this behavior for the procedure g called at static priority with resource set r we obtain the following summary g tj r when applied to the tuple reaching f we have t since tuple entries may not increase this tuple is then carried over to fr and with we see that f is not transactional linear equalities for pcp programs the resource analysis presented in section need not explicitly deal with interrupts the reason is that interrupts neither change sets of held resources nor affect the current of tasks values of on the other hand can be affected by interrupts fortunately interprocedural analyses can be adapted to resource aware value analyses of pcp programs rather easily as a example we extend the approach presented in for analyzing linear equalities to take resources and interrupts into account the goal of this analysis is to compute the linear closure of extended states of the collecting semantics for simplicity we restrict ourselves to pcp programs with flow independent resource sets let x x xk denote the set of global variables where k x is the number of global variables we consider affine assignments of the form xj t · xi with ti q we write v for the complete lattice of linear of matrices over the q each matrix a describes the effect of an execution onto the global state thereby each global state is represented by a vector v v qk where v and for i vi records the value of the variable xi we write v for the complete lattice of linear of k vectors over the q the extra component v allows to affine transformations a set s of transformation matrices is abstracted by the linear space span s v of all linear combinations of matrices in s the concrete resource sensitive semantics u s v l res of an edge is then given by u s v lr ij t t tk u s v lr ik s xj t · xi otherwise where im denotes the identity matrix note that the resource parameter is not used here but might be in another instance of the framework and is therefore given for completeness the resource sensitive semantics of an execution path is defined as follows l ik e l l · e l f f l · l f fs s l s l · · l the concrete resource sensitive collecting semantics ru il res qk of a program point u and static priority level i is then given by ru ¯ x r x qk ¯ ru i as in we approximate this by its span ie ru il r we define the abstract semantics e l res v by e l r span e lr since in the end we are interested in equalities holding at a program point we can model assignments xj by assignments of all constant values for the abstract semantics we therefore have xj l r span ij ij to each procedure f we assign an abstract function f l p res v which summarizes the abstract effect of f these effects are characterized by the least solution of the constraint system sl i rl i sl sv i rl u s v l r l sl u i rl u s v e sl sv i rl f l i sum r l su i rl u f v e sl su i rl j l l su i rl u ne j i r sl f l i r hf i rl j l q l j q pq j for two sets of matrices m m v the operator l v × v v is defined as follows m l m a m a m by using the transformers for resource sets we can statically check the priority condition including the resource set in formation and therefore for this instance we do not need a operator performing this check instead we use l for interrupts as well since we consider global variables only the op hf which transforms the abstract semantics of a procedure into the abstract semantics of its call is simply the identity for tasks the resource set parameter r is always the empty set and the static priority i is the static priority of that task thus if the pro gram does not contain procedures the summaries can be simplified to vector spaces of matrices in the second phase we compute for every program point v and static priority i a mapping rl v i res v for any given resource set r this mapping is meant to return the linear hull of all concrete states x qk possibly reaching program point v within a task with static priority i given the current resource set equals r the set of all functions res v forms a complete lattice wrt the partial ordering on functions induced by the partial ordering on v from a basis b of rl u ir for a program point u with static priority i and resource set r we obtain the set of valid equalities t k i ti · xi as the set of solutions of the system t · b tk · bk b bk b in order to describe the effect of a procedure f for this second phase we rely on two · the summary f m computed by samelevel must resource analysis which records how the execution of f may change the sets of held resources and · the summary f l computed by the samelevel analysis of linear transformations in the first phase which for each static priority i and resource set before the call returns the vector space of possible linear transformations this yields the following constraint system rl l m rl rv il e l e ml ru il e u s v e rl rv il f l i f ml ru il u f v e il rl ru il jl il j l il i u f v e u ne j i u ne j i q pq j here m is the mapping which assigns the full vector space qk to the empty resource set r and the zero space to all resource sets r the operator l res v × res res × res v res v is defined by m hl r r hr a m r x r since we consider global variables only the function is the identity function ie in the constraint rl a modified version of the application and the enter operator are required which take into account that an interrupt q can only be enabled if the static priority of q the dynamic priority at a given program point therefore we define m jl r a m v r j pr r r j pr if r otherwise in any case we have the following theorem theorem assume that the pcp program has resource sets and satisfies s let furthermore sv i f and sv i rl f l f m as well as rv il denote the least solutions of the constraint systems s sl sm and rl respectively then the following holds for every program point v static priority i resource set r and procedure f span l sv ir sv i rl span l f i r f l i r for every program point v static priority i and resource set r span ¯ lx ¯ rv i x qk r rv il r for the constraint system sl we have at most n · p · o constraints using the techniques from this implies that the least solution can be computed in time on · p · o · k this is a smooth of the results obtained in to the case of programs with interrupts and resources note that a practical implementation may explore the given constraint systems in a demanddriven fashion such that only those resource sets are considered which actually are necessary for computing the reachability information as pro by the least without auxiliary solution of rl for the procedures this means special case of that the factor tasks only o can be completely we our analysis for the example program in figure due to their nondeterministic nature interrupts may occur often creating an infinite number of program executions for a given program point each corresponding to linear transformations of the state vectors since we are only interested in the linear hull of these transformations it suffices to maintain a basis of the gen of matrices accordingly we obtain the following summaries for the interrupts i and i i l span i l span these transformations can be applied to compute the of possible values for each program point of the main task for t we obtain rt l span the second vector is due to the potential occurrence of the interrupt i the interrupt i has no impact since i is not enabled and there are no restrictions on the value of z at t from the basis we obtain the system of equalities · t · t · t · t · t · t solving this yields the equality x y overall we have the following equalities node t t t t t t t tr i ir example equalities x y x y x y t x y z z t z this means that at the end of the main task t and the interrupt i the equality z holds moreover the equality xy holds although interrupts may freely occur at nodes t and t finally the local variable t equals once it has been written note that the equalities for z and t cannot be guaranteed in i since i may occur at node t where both variables may still be uninitialized note that while this analysis directly into the framework it is also possible to use analyses which for example use infinite lattices evaluate branching conditions or even are unable to provide closed function summaries for infinite lattices one would use a demanddriven local solver and possibly the branching conditions could be added to the flowgraph and the framework semantics extended to treat them as while allowing the concrete analysis instance to fully evaluate them finally summary functions can be handled by them this technique is used in the analyzer and proved to be very useful implementation the data race and analyses from sections and respectively have been implemented in the analyzer for multithreaded c this analyzer framework is based on a local fixpoint engine and provides basic analyses such as constant propagation and alias analysis which then can be with additional specific domains and transfer functions the analyzer between read and write accesses in order to avoid warnings beyond the approach presented in sections and takes conditions into account whenever possible by that the analysis may some execution paths and therefore may raise less false alarms the test suite consists of sample programs from the implementation together with our own examples program robot is part of the control software of a two robot which uses resources to the with remote control commands the programs test are examples for scheduling pe resource synchronization res tasks tt and communication each of these tests uses two tasks and one resource programs example and example fun are from figure and figure respectively program consists of two tasks which set a variable to and via a single resource program counter consists of an interrupt which increases two fields of a struct if an integer flag is set and does nothing otherwise as well as a task which the flag then the struct and the flag the integer flag itself is protected by the resource the results of running the analyzer on these examples are summarized in table we ran these experiments on a cpu machine with under the analyzer verifies that the two programs and test are free of data races the data races in both versions of the example program are discovered as well as the unsafe access to counters in pe test and tt test the race in robot occurs since the initialization task is not out for counter race warnings are produced for the fields program robot pe test res test tt test test example example fun counter size lines lines lines lines lines lines lines lines lines time s s s s s s s s s race trans table result of analyzing example programs of the struct since they are accessed both by the task and the interrupt without protection with a resource while we verify that the integer flag accesses are safe the analysis presented here approximates conditional branching with nondeterministic branching and therefore does not relate the flag value with the accesses to the struct other analyses provided by the analyzer however may split the execution path based on the value of the flag and thus may separately analyze the cases for a set and an flag regarding the analyzer verifies that the tasks of test and are transactional it the violation of of the running example and also produces warnings for pe test and tt test where the race occurs between accesses to the counter in res test a variable whose accesses are otherwise protected by a resource is read after the release of the resource thus our definition of in robot on the other hand the accesses to may be involved in data races but are the only accesses to in their respective procedures accordingly is not violated for counter a is produced since the resource is released between and the flag all examples are small and therefore analyzed in time in order to get an intuition how the analyses we evaluated the analyzer on the benchmarks chain n while the for the asymptotic complexity of our analyses grow exponentially with the number of resources they depend only linearly on the program size therefore we do not expect the program size to be the major for scalability but the number of and interrupt levels thus we vary these latter parameters in the benchmarks for n program chain n has x xn n interrupt levels and n resources which are used to copy the value of the variable xi into the variable xi the running times of the analyzer for the instances n are shown in figure for each of them the analyzer verified absence of data races and of all tasks the increase in run time for these instances is slightly worse than linear even for interrupt levels and resources the runtime is still quite acceptable the source code of our analyses all benchmarks and a script to run them are available at related work while the and inheritance protocols have been formally studied these papers focus on rather than data consistency that is one assumes the program is correctly synchronized and characterizes the impact of synchronization primitives on hard as a function of resource usage in contrast we are interested in detecting erroneous use of these synchronization primitives already simple analysis problems for concurrent programs with recursion and synchronization are undecidable practical approaches therefore either the interaction runtime in seconds number of interrupts figure of the analyzer on chain n between threads as in model checking or ignore synchronization some also place restrictions on concurrency in a number of papers et al ­ discuss model checking of pushdown systems synchronized via locks where the usage of locks must be well nested this approach has been generalized to pushdown systems with dynamic thread creation with the exception perhaps of dynamically changing pcp programs extended with dynamic task creation can also be cast within the more general model of multiset pushdown systems for these et al show that control point reachability is decidable their approach is based on petri net reachability and does not support the inference of more complicated invariants such as linear equalities et al observe that every priority system can be transformed into a pushdown system beyond that they additionally represent the corresponding to synchronization protocols as exponentially large pushdown systems in case of pcp as well as for priority inheritance with resource usage these two systems can be combined into one pushdown system from that they conclude that reachability is decidable for pcp as well as for priority inheritance with resource usage our approach cannot be applied to priority inheritance directly while for pcp our analysis is exponential only in the number of resources not in the number of interrupts abstract effects of interrupts has also been considered by et al for analyzing stack overflow in assembly code their summaries describe the stack consumption of an interrupt together with the set of interrupts which become by the execution their model does not deal with specific protocols such as pcp additionally and present a transformation technique to turn embedded code into code and apply race detection tools to the transformed code they introduce artificial interrupt locks to make interrupt visible to the analysis they assume fixed static and from the possibly by the thread analyzer in contrast our approach directly exploits the properties of the pcp protocol for concurrency and explicitly deals with dynamically changing this allows us to handle the set of possible interleavings precisely flanagan et al present a type system for atomicity in concurrent java programs a transactional procedure as defined in this paper is atomic in their sense since every execution of a transactional procedure that is possibly has an equivalent serial execution ie no interrupts occur during its execution this atomicity condition is relaxed by et al who provide a set of problematic access patterns and show that they are complete ie the absence of all these patterns guarantee that the execution is wrt the critical variables and critical sections our notion of for a procedure f considers all potentially accessed global variables as critical for f where the critical section of f is the section between the first and last access to global variables et al provide a static analysis for java programs to verify the absence of such patterns in a given program et al give a static analysis to detect atomicity violations ie accesses to values of stored in a local variable that has the critical section conclusions we have provided practical methods to analyze data races and in pcp programs moreover our analysis of linear equalities can be considered as one instance of an analysis framework which generalizes the functional approach of from programs with procedures to programs with procedures interrupts and resources following the pcp protocol other instances of this framework can be obtained by providing specific domains v and v for summary functions and abstract states respectively together with transfer functions for the basic statements and specific versions of the operators hf j and we have implemented the analyses of potential data races and within the static analyzer preliminary experiments with typical examples as well as a scalable benchmark are still experiments with larger and more complicated realworld examples are desirable we would also like to analyze further kinds of concurrency in pcp programs and explore in how far the given approach can be generalized to more general programming models eg pcp programs with task creation acknowledgements we thank gordon and for interesting us in pcp programs as well as providing example programs and valuable insights from a users perspective this work is supported by the joint project mu and se the third author is partially supported by grant references c k and a using atomicity to detect concurrency errors in vol of lncs pp ­ springer m f a and t analyzing asynchronous programs with in vol of pp ­ architecture specification release url t p scheduling of realtime processes realtime systems ­ a m and t regular symbolic analysis of dynamic networks of pushdown systems in concur vol of lncs pp ­ springer p cousot and r cousot comparing the galois connection and approaches to abstract interpretation paper in pp ­ springer b formal analysis of the priority protocol in pp ­ ieee press j and a podelski efficient algorithms for pre and post on interprocedural parallel flow graphs in popl pp ­ acm press c and h a faster solver for general systems of equations sci comput programming ­ c flanagan s n s qadeer and s a modular verification of multithreaded programs theoretical comput sci ­ c flanagan s n m and s qadeer types for atomicity static checking and inference for java acm trans prog lang syst ­ m s flow analysis of computer programs t j j d k m and j java for applications in v and a gupta on the analysis of interacting pushdown systems in popl pp ­ acm press v f and a gupta reasoning about threads communicating via locks in cav vol of lncs pp ­ springer v y yang s and a gupta fast and accurate static detection for concurrent programs in cav vol of lncs pp ­ springer n p t and t reps a decision procedure for detecting atomicity violations for communicating processes with locks in vol of lncs pp ­ springer n s and j one stack to run them all reducing concurrent analysis to sequential analysis under priority scheduling in vol of lncs pp ­ springer p and m conflict analysis of programs with procedures dynamic thread creation and monitors in sas vol of lncs pp ­ springer p m and a predecessor sets of dynamic pushdown networks with constraints in cav vol of lncs pp ­ springer m and h precise interprocedural analysis through linear algebra in popl pp ­ acm press group operating system specification version url m a and k formal specifications and proofs of inheritance protocols for realtime scheduling j ­ g contextsensitive analysis is undecidable acm trans prog lang syst ­ j and n interrupt verification via thread verification ­ j a and k eliminating stack overflow by abstract interpretation acm trans embedded comput syst ­ l r and j p priority inheritance protocols an approach to realtime synchronization ieee trans comput ­ sept m and a pnueli two approaches to interprocedural data flow analysis program flow analysis theory and applications pp ­ et al platform for r r url m f tip and j associating synchronization constraints with data in an objectoriented language in popl pp ­ acm press v and v data race analysis univ sci sect comp ­ 
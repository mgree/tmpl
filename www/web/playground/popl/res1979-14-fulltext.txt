the functional power of parameter mechanisms university texas to introduction the effects of parameter transmission to re procedures have been investigated eg in t io widely and have been shown to be a consideration in such topics as program verification hard design and the use of the fix point rule of computation it is the ease in most of the works above that the of only one or two mechanisms for parameter transmission are at issue us to question whether or not there exist other parameter mechanisms which would be as powerful as the mechanism but have fewer effects to be in conjunction with other language features motivated by this same line of a analysis of several wellknown parameter mechanisms using the techniques of iii in program using these techniques on program schemes no arrays whose actual can be arbitrary expressions has shown call equivalent by value copy but each weaker and reference all to be than call by name der assumes all basic functions and predicates to be total also using the techniques of tive but on program schemes which are augmented with finite arrays whose actual parameters can be expres sions including arrays and array cells and whose basic functions and predicates are partial has shown that call by value copy and reference are all but each to be weaker than call by name when an index equality test an equality test on array indices is added to the schemes all the parameter equivalent mechanisms are shown to be in addition when the index equality test is allowed shows that arrays are as powerful as the infinite his finite arrays i program deals with abstract called program schemes which in general are algollike and consist of assignment else go to and halt statements in program schemes the domain and basic functions and are left unspecified an tion is applied to the scheme two program schemes are considered equivalent if and only if for any interpretation they both halt with the same value or both diverge introduced by and but the relationship is not established when the index equality test is removed even when basic functions and predicates are total to summarize and distinguish only the mechanisms call by copy and reference from the mechanism call by name and at times finds no at all among any of the mechanisms because and used the traditional techniques of tive their results are ty results at with constructive proofs that are step by step translations to be performed on arbitrary program schemes whose defined functions algollike procedures a particular param mechanism transforming them into program schemes whose defined functions a different parameter mechanism since application of these results requires the translation of entire programs rather than just the translation of defined functions these results could be useful to a compiler writer but clearly could not be used to effectively translate dual procedures one parameter mechanism into procedures another mechanism in addition users are likely to use these results in their programs to simulate parameter mechanisms not implemented in the language they have chosen hence we propose that and results do not yield a strict son of the various parameter mechanisms from which a reasonable hierarchy of power can be established for users and language designers be cause the features of each mechanism can be by translations made on the surrounding scheme prior to the act of parameter transmission the various parameter mechanisms are distinguished at three points defined function operations formed at the time of call but before execution of the defined interpretation function begins of formal parameters method by which a reference to a formal parameter is resolved defined function termination operations per formed after execution of the defined function but before execution immediately fol the point of call when and showed that two were equivalent in power by how to translate any program scheme whose defined tions used one mechanism into an equivalent program scheme whose d th defined function interpretation of for parameters and defined function termination for functions in the two program s were made with respect t o different sets o i and domain values we suggest that to more accurately measure the relative of the various parameter mechanisms two should be considered equivalent in if and only if any defined using either of the mechanisms can be translated into an defined function using the other mechanism since the translation involves functions only the two functions if equivalent the same tation with their respective defined function interpretations of formal parameters and defined function taking place on the same sets of variables and domain values we believe the relationships among parameter mechanisms on function equivalence rather than on program scheme equivalence is more valid as the various mechanisms are within the same calling function environment hence their interpretations respective of formal parameters and defined function are all made with respect to the same environment hence we introduce into the theory of program a new formalism which we call function through which we introduce function classes and the concepts of function equivalence and function class equivalence function classes are defined which contain defined functions the function class to which a defined function belongs determines defined function tation of formal parameters and defined function termination for that defined function our function class definitions allow for the case that all functions in any program scheme belong to the same function class or for the case that any function in any program scheme may belong to any function class note that only the semantics of parameter transmission for a defined are specified by its function class the syntax of a function is still specified by the same grammar which defines its surrounding program scheme the equivalence of two defined functions is defined with respect to an underlying class of program schemes we specify a basic grammar which we modify as necessary to define the classes of underlying program schemes considered because assumes basic functions and predicates to be partial and because assumption of total basic functions and predicates is not crucial to the results in of interest here we assume basic functions and predicates to be partial definitions we a grammar based on and grammar in which we use and modify to define four classes of program schemes class has no arrays and allows only the variables as actual parameters to defined functions the class pr has no arrays and allows arbitrary expressions as to defined functions the class include allows arbitrary expressions including arrays and arrays and array to defined functions the class merely adds the index equality test our grammar allows a defined function to have which can be invoked only by that defined function or by other within that defined function the semantics of parameter transmission for defined functions depend on the class to which the defined function belongs and any of a defined function must belong to the same function class as the defined function a program scheme s represents an abstract program while a program scheme s with an tation i computes a partial function where the result of the scheme is called in most of our proofs we an interpretation and then consider the free interpretation corresponding to that interpretation definition an interpretation i for a scheme s is free if of i consists of finite strings of symbols the basic function symbols of s and input variables of s and q the function associated with the basic function symbol fi is a function fi of rank with the property that for strings tl f each input variable x is initialized value x i to the definition free interpretation free interpretation follows if the predicate symbol an interpretation corresponding whose predicates predicate associated pi is a predicate i the to i is the are defined as with the pi of rank and x x domain of if then x are elements of the x x rp is true in if if and only if pi ls true in i we now introduce equivalence the concept of function definition a defined function g is equivalent to a defined function g with respect to a class c of program schemes if and only if for every program scheme s e in which g appears if we a replace the function definition of g by that of g and b replace each occurrence of g by g to obtain program scheme s e c then s z s similarly the condition must hold with the roles of g and g stated informally two defined functions are with respect to a class of program schemes if they can be used in all program schemes within that program class based on this concept of function equivalence we next define function class equivalence and other function class relationships which are analogous to program q is added to every undefined value ie the basic function might return to the value when we say a is undefined we mean s diverges on not q scheme class equivalence class relationships and other program scheme definition as powerful if an a class of defined functions c as a class of defined functions c for every defined function g e c there equivalent defined function g e c is definition a class equivalent to a class of cc ifc c and c of defined functions defined functions c c is c definition a class of defined functions c strictly more powerful than a class of defined c c c if c c and there exists some defined function g e c for which no defined function exists in c is definition two classes c and c are incomparable if of defined c functions we initially define five function classes based on the following parameter mechanisms which are wellknown and widely considered out the literature value eg and algol w copy eg in some versions of fortran call by eg in algol w reference eg in and some versions of fortran and eg w the five function classes are and and each contains all syntactically correct defined functions as specified by the grammar for the class of program schemes being considered however the defined functions in are transmitted parameters by value and similarly for the defined functions in and formal definitions of each function class can be found in proof methods some of our proofs are construction proofs which specify an effective translation of a defined function in one function class into an equivalent defined function in some other function class these construction proofs are used when we want to show that one function class is as powerful as some other function class or that two function classes are equivalent the of our proofs ever show that one function class is not as as some other function class or that two func tion classes are incomparable these proofs involve negative results ie results which show that for some particular defined function one function class there no equivalent in defined function in some other function class we begin these proofs by applying a lemma on redundant basic functions and predicates in defined functions which is analogous to theorem on redundant basic functions and predicates in program schemes i the lemma establishes that if we want to find defined function equivalent to some given defined function g then the defined function to be found need not have any basic func tions or predicates other than those in g so we carefully choose a particular defined function g in the function class we believe to be more and assume there exists an equivalent defined function g in the function class we believe to be less powerful by of the lemma we can pick g so that it contains no basic functions or other than those found in g we next select one or more pairs of program schemes and for these schemes the two program schemes in each pair differ only in that one member of the pair contains g and the other member contains g since g and g are assumed to be equivalent the two program schemes in each pair must be equivalent for all interpretations so by careful selection of these schemes and interpretations we can determine somewhat the behavior of gf having determined enough about the behavior of g we finally choose a pair of schemes as described above and an for which the two schemes cannot halt with the same value thus our assumption of the existence of g is the critical aspect of these proofs is a sufficient tion of the behavior of g to arrive at a this determination is made of course as a result of very careful selection and manipulation of specific program schemes and interpretations for these schemes details of proofs can be found in the following definition contains notation that will be useful in our proofs definition let s be a program scheme ing the defined function g if in s we replace each occurrence of g by g and replace the function and definitions of g by those of g to scheme s then we say that s is the of s with respect to g and write s sg g variables as actual throughout this section we consider defined function equivalence with respect to the class of program schemes without arrays which restrict actual parameters to simple variables this hypothesis will be understood and will not necessarily be whenever function and class relations are shown with respect to the class of program schemes we show that is strictly the least powerful class and are equivalent and and are strictly the most powerful classes the relations indicating equivalence to the definitions of the function point because of the restrictions are due merely classes at this on actual theorem s where based on the definition in of the effect of call by value a construction can be given for an arbitrary defined function in to be translated into an equivalent defined function in we then use the fact that there can be no side effects on actual parameters to defined functions in to show that is strictly less powerful than the other function classes theorem proof based on the definition in of effect of call by a construction be given for an arbitrary defined function to be translated into an equivalent defined tion in the can in func now consider the program scheme s e vu u xl x if g e then for all i while if g then for all i let g e assume there exists defined function g e such that g g s sg g now g must contain some code which causes rather than to be a let returned to generality tions other actual parameter assume that g than fl and no v without contains no predicates loss basic hence of func the code in g which modifies the value returned to v contains no predicates but is code since g contains no predicates the same sequence of statements is executed upon each call of g now in the formal parameters are treated as local variables and are to their actual parameters sequentially left to right at the time after of return hence for g is invoked then we must necessarily have x or x after final assignment in g hence we can assume that after any call of g that x assignment in g after x s final consider the scheme s e vu w xl x fx ad let s g for now all i while e for all i hence s z s g z g but this contradicts our assumption of hence there exists no defined such that g u g qed the existence function g of g e arbitrary expressions as actual parameters throughout this section we consider defined function equivalence with respect to the class pr of program schemes without arrays which allow expressions as actual parameters this thesis will be be understood and will not whenever function and class relations are shown with respect to the class pr of program schemes the hierarchy of power of function classes established when actual parameters were only ly the same results hold strictly more powerful than and are now s except that the other incomparable only still classes to show that call by name cannot be simulated by the other mechanisms we will specify a function al which can be computed by a defined function in but not by any defined function in any of the other function classes this functional was first described by and and has since become known as the behavior of can be stated as follows ux if there exists u c such is true that otherwise where r and l are basic functions and p is a basic predicate requires a search for a domain element satisfying some predicate where the domain may be thought of as a binary tree and assert that cannot be computed by recursive functions using call by value and state that the proof is based on the intuitive notion that recursive equations using call by value can scan only a bounded number of nodes in the binary tree and an interpretation may be for which some crucial node does not get tested using this idea we will show that there exists no defined function in or which computes because of complications which can arise when more than one formal in a function in the class to the same actual the class will be considered separately in a corollary to the next theorem theorem mechanism where proof sketch has specified scheme using call by name which computes based on that program scheme we specify function with in computes a program defined which assume there exists a defined function in or which computes leaf test without loss of generality assume that defined function contains only basic functions r and e and basic predicate p now consider the computation interpretation of this defined function on a free where all px are false some defined function g is called recursively if leaf test is computed and this defined function must be in a loop since the only predicate is p false ments will thus the same sequence be executed in the interval of successive calls of g call this interval a cycle of computation or simply a cycle let cycle o be the sequence of statements in the interval following the first call of g through the first recursive call of g let cycle j be the sequence the jth of statements in the interval following through the recursive call of g let the rank of g let z z n be the formal parameters of g and let xl xn be the actual parameters to the recursive calls of g if we think of the domain of as a binary tree then the domain elements are the nodes of the tree hence the values of the actual parameters to g are nodes of the tree actually the domain will represented by two trees the root node of one is q and if the argument to is x q then x is the root node of the other we first show that the values of all to any after the first recursive call of g are descendant nodes of the values of the to the previous recursive call of g we next the actual parameters of g by show ing how they are partitioned into three sets according to the way in which their values are determined in the first and hence in each cycle of computation the first set k is the union of the sets below which are defined where i n r t i t occurs in each cycle where t n u s rl if x z occurs in each cycle k i u rl j n does not occur in each cycle ie xi is assigned some constant node in each cycle k t j i xt occurs in each where u i t n j u rl cycle s e k we characterize the set k by showing that by the nth recursive call of g the values of all x r e k become fixed r and never change the next set p is the union of the sets below which are defined where i n p t jk mn j ad jl and d jk are distinct xj ki zj and x z j xj z x j k z occur in some order in each cycle pi t o i xt uz occurs in each u e rl s e p ­ p cycle x e means the value that the expression m has at the beginning of a cycle is the value that is passed as the actual to the next recursive call of g e p t j i xt u e rl occurs in each cycle j we characterize the set p by showing that for each r e pl the the jn recursive the values call values of xr begin after of g and for each r e p of xr begin after the recursive call of g the last set i is the union of the sets below which are defined where i n i ts i j l m ki are distinct ki zo ll and uu e rl i il k and xj o x j zj x u z j j x j ki o occur in some order in each cycle u e rj occurs s c wi in each ­ w cycle w t jl xt l occurs u c rk in each cycle we characterize the set w by showing following for m o the for each r e wl the value of xr to the recursive mt in a tree call of g is on at least for each r e w j the value of xr to the recursive call of g is on at least level m in a tree by of values using a graph to represent the assignment to we next show that our of the is complete ie that r r e p or r ew we then determine a level that if r e k or r c p then the x are above level r l in a tree such values l of all of all xr before j nl the values the jth recursive call of g are above level l now if r e w then the value of x on the r level m means the level the width is m nodes in a binary tree where recursive call is the greatest of g is on at least ki as defined for and j is the greatest j such that level l where k all w i n w for all i dj li lj nl such j exists j o ad i no such k exists then w and w can be in the remainder of the proof in addition we assume that for each r e w the value of xr on the first call the recursive level t t l call of g is on at most since n l st there exists at least one node on level t such that this node is not the value of my actual parameter call of g we then to the recursive show that there exists such a node say q such that neither q nor any of its descendants is the value of any actual parameter to this or any future call of g and that none cf qs proper descendants has been the value of any actual parameter to any previous call of g but qs proper descendants must be tested with predicate p during a cycle of computation or before g is ever called only a finite number of nodes say w be tested by p before g is ever called and only a finite number of nodes say m can be tested in each cycle these nodes may be fixed nodes in which case the same nodes are tested by p in each cycle so clearly already been tested before cycle values of actual parameters to g descendants of nodes which are the values of actual parameters x r k p r since all possible values of these parameters have already appeared in calls to g before cycle then clearly all descendants of these argument nodes have already been tested by p before cycle descendants of nodes which are the values of actual parameters xr r c w then before cycle o and from cycle o through cycle nodes are tested by p now a path in a tree from node q through of its proper descendants includes at least one proper descendant node of q which could not have been tested with p before cycle but this node cannot be tested during or after cycle because it is not of type or above else it would already have been tested has been shown not to be of type and by cycle is shown not to be of type therefore this proper descendant node of q is never tested with p now if we consider another interpretation which differs only by making predicate p be true on this node alone then the computation of our defined function will never test that node and will diverge as before whereas should halt on this interpretation our assumption that our defined function in or computes corollary proof function function since in g s can be computed by a defined assume there exists a such that g computes gx function body let s e pr be the following x gx u gx function body program scheme clearly g computes computes now all in s g and its has shown that scheme s s pr if and only if s defined functions are in there exists a program x of s such that s e s and in s are in if and only all defined functions therefore s computes if s computes now consider g e the following defined function gx of s clearly s computes if and only if g computes therefore g computes if and only if g computes but theorem showed that there exists no defined function in which computes and hence g do not compute therefore g our assumption that some g e computes qed theorem we know by theorem and again based on the definition in of the effect of call by the construction used in theorem can be used to translate an arbitrary defined function in into an equivalent defined function in theorem and are incomparable and handle that are simple variables in a similar manner but are distinguished by their respective of which are not simple variables for a defined function in these are evaluated once at defined function and this value is used whenever a value for the formal is required whereas such an actual to a defined function in is not evaluated until and is repeatedly evaluated when ever its corresponding formal is encountered it is possible to specify code for a defined function in which would simulate the effects of call by reference on an actual that is not a simple variable but the type of actual simple variable or not can vary from program scheme to program scheme and it is not possible to vary application of the simulation code accordingly arrays and array cells as actual parameters throughout this section we consider defined function equivalence with respect to the class of program schemes with arrays which allow arbitrary expressions including arrays and array as actual this hypothesis will be understood and will not necessarily be whenever function and class relations are shown with respect to the class every function class is found function class to be incomparable to every other we found it particularly that the class turned out to be not only no more but also no less powerful the other function classes call by value than guarantees that no array cell will its value changed of any actual array the other mechanisms cannot make this guarantee since a defined function cannot save all values from an infinite array or even a finite array for which the bounds are unknown and the formal array can be passed as an actual to a defined function which changes the value of some array cell which is clearly beyond the scope of knowledge of the original function theorem incomparable name and are where mechanism e proof we know so consider the following defined g e by theorem function ga x ha halt assume there exists a defined function g e such that g g without loss of generality assume g contains no basic functions or predicates hence g consists of code ie the same sequence of statements will be executed upon each call of g and assume without loss f generality that g has no sub functions now consider s e where above the following h program s and g is as defined v io v do while v fv i il ai v end u ga io do while pu u i il end ha io do while pa i il i ai ha i end now when defined will be either for some i s sg g or q since for all i let g does not contain p or h then clearly g must invoke h otherwise consider an interpretation i for which the do while by statements control defined structure can be simulated by our grammar is false is false is false and py is true then v while therefore g invokes h s under i if diverges now the formal array a in g must be the actual parameter to h rather a array say b in which only a finite number which is fixed and independent of the interpretation since g consists of code of cells of a can be stored otherwise let cell am be one of the cells not stored in some cell of array b and consider an interpretation for which is false k m and is true otherwise is false otherwise py is true is false and py is true otherwise then v while s under f diverges therefore a must be the actual parameter to h now g must pass values in a to h that passes to h the distinct ai and aj where i the same g does values j and sequence of distinct otherwise assume g a and an in cells l g passes the values and a in al then cells ar and as where an interpretation i for r s which p al is false pa is and py is true otherwise then is defined while s diverges and assume without loss that g passes the same sequence of values in a to h that under f i of generality perhaps g does now only the same array cells of a which are fixed and independent of the interpretation since g consists of code say cells o through n be to their values when g was invoked so g must invoke h only once otherwise consider is an interpretation false j n i for which is undefined for all z and py is true otherwise p is false is true is false k j is true otherwise then v while diverges therefore g invokes s under h once f but consider interpretation ih again now v ie the value of while ie the value hence s j s g g which contradicts our assumption of the existence function follows of g therefore g e such similarly when g qed there exists that g g s no defined the result and and and are incomparable are incomparable call by copy and call by are distinguished by their defined function termination actions with respect to array cells which are actual parameters if an actual parameter is an array cell the defined function termination action for the class causes the index of the actual array cell to be evaluated immediately before the value of the corresponding formal is assigned to the array cell hence the array cell index is evaluated in terms of the current ment at defined function termination rather than in terms of the environment at defined function so in the actual parameter list i at where t is an expression if the expression t contains i and if i is assigned a new value at defined function termination then this new value will be used in evaluating t as the index of actual at at defined function termination in contrast if an array cell is an parameter to a function in the class then at defined function its index is saved so that at defined function termination the value of its corresponding formal will be assigned to the same array cell that was the actual at defined function hence the array cell index used at both defined function and termination is in of the ment at defined function actual array cell indices are handled similarly in in theorem mechanism where now that the function classes are augmented with arrays we cannot use the result of theorem to show that where mechanism s or the result of corollary to show that because and have a scheme defined which we can represent augmented with arrays as a which computes result is needed distinguished from hence a new approach we note that call by the other mechanisms for name when this ls an array cell with a simple or variable index and the simple or variable both appear as actual parameters to a defined function through the index parameter a function in the class can reference and hence modify the value of any cell of the array theorem and and are incomparable are incomparable are incomparable and and when two call by copy or formals have the same corresponding at defined function each formal is given a of the actual and these formals are used as two completely independent copies of that one actual parameter but when two call by reference or name formals have the same corresponding actual both formals refer to the single instance of the actual when are not arrays call by reference or name can easily this difference by making copies of each formal parameter and using these copies throughout the function however now that can be arrays copies cannot be made of infinite arrays or even of finite arrays whose bounds are unknown theorem and are incomparable proof by theorem and by theorem the index equality test throughout this section we consider defined function equivalence with respect to the class of program schemes with arrays and an index equality test with respect to the class every function class is still found to be able to every other function class in general the proofs incomparable which show the function classes with respect to the class also hold with respect to the class some is needed for the proofs of the previous section which use the fact that a defined function g containing no predicates consists of code causing the same sequence of statements to be executed whenever that function is invoked even though g now may contain index equality tests which can cause branching for given arguments the same sequence of statements will still be executed upon each call of g if no actual parameter to g contains an array index at the time of call of g and if no defined function invoked by g returns an array through parameters or as the function value as is the case in the proofs under discussion then by lemma of the same sequence of statements will be executed upon each call of g hence the results of section also hold for this section parameter mechanisms in combination our results show as fewer restrictions are placed on actual parameter types that the among the mechanisms increase once arrays are added to schemes are found among all the mechanisms so that each parameter mechanism considered separately is seen to lack certain therefore we next look at certain combinations of parameter mechanisms and consider the combinations reference and value e g in pl call by reference and copy eg in some versions of fortran name and value eg call by name and value eg in w call by name reference and value eg in which are represented respectively by the function classes and the semantics of parameter transmission for a parameter passed to a defined function in say value depend on whether the parameter is passed by reference or by value if the parameter is passed by reference then the defined function interpretation of formal parameters and defined function termination as specified for the class hold for the parameter and similarly if the parameter is passed by value a new class of formal a is defined which includes rd parameter dec statements in defined functions these declarations specify whether the formal is passed by value copy reference or name however the declaration type must be one of the parameter mechanisms of the function class containing the defined function in addition in keeping with the language implementations on which our function classes are based array parameters to defined functions in a and passed by reference will always be b will always be passed by name in the equivalence results which follow with respect to the defined function class will be understood figure these results are depicted in g figure function class relationships with respect to theorem proof we first show let g be an arbitrary function in defined name x xi m value x x j jn q where i i rg m k ­ rg then struct g c such that and we can con g g where g is defined as g xl g x g t t c q name yi y z m q value yj yk nq body where is the body of g with each occurrence each statement of x replaced w by replaced by the state ments kl where t lx kl k q ing w otherwise note all arrays which are formal parameters in defined functions in are passed by name hence in g no z t replaced by an array name and if z is not t replaced by a simple or variable ignored then the statement which is the desired y t t effect is to show consider defined function g of theorem and let g where formal array parameter a is declared a value parameter since all formal array parameters of any defined function in must be declared name our result follows immediately from theorem qed theorem call by value formals can be simulated easily by call by copy formals but all call by copy formals are evaluated and have their values saved at defined function while only call by reference formals which are not simple or sub variables or arrays are evaluated and have their values saved at defined function this difference in defined function action distinguishes the classes and theorem and are incomparable and are incomparable and are incomparable and and are incomparable theorem shows that call by name cannot be simulated by any other parameter mechanism at defined function the indices of call by reference array cell are evaluated and the value is fixed as the index of the array cell actual throughout execution of the defined function this is not the case for call by name or array cell hence the classes including call by name or and the classes including call by reference are found to be incomparable corollary proof obviously the proof of theorem shows that there exists no defined function g e such that g g where g e and all formal parameters are declared reference clearly gs therefore qed of g theorem the proof that is similar to the proof of theorem to prove that we show that defined functions in using call by reference and call by copy can be simulated by defined functions in using call by name and call by reference simulating call by reference is clearly no problem however in when the formal parameter list is examined from left to right at defined function all copy parameters are evaluated and assigned to their formals when they are examined if these copy parameters are all passed by reference in then simple and variables be evaluated when they are examined at defined function so in order to ensure that the parameters passed by copy in are evaluated in the proper sequence in in we will have as many defined functions as there are parameters and each is passed to every function parameters will be passed by reference to these functions in the same order in which they would be examined in parameters which would not yet have been examined in are passed by name thus delaying defined function parameters which would already have been in could be passed either by reference or name so we have chosen to pass them by reference when a parameter is reference for the first time in if the parameter is declared reference in then the defined function calls proceed however if the parameter is declared copy in then the value of the reference formal is assigned to a variable which is used throughout the remainder of the function and whose value is to the reference formal prior to defined function termination the function calls then proceed conclusion comparing our results with we see that the techniques and of function did allow us to derive a new propose more precise mechanisms characterization most of of and translation constructions were quite inefficient and in il states about his results that if our constructions cannot be more optimal then this suggests that there is a difference between these classes of program based on different parameter mechanisms which we have not had the mechanism to recognize we suggest that function is this mechanism it forces the defined function interpretations of formal parameters and defined function for the under analysis the same environment to be made with thus providing respect to a stronger yet still quite reasonable notion of equivalence this stronger notion of equivalence has formed the basis for our results which differences in the mechanisms which referred to while yielding efficient and easily implemented trans between defined functions in classes where translations are shown to exist references ak on the properties and tions of program schemes stanford ity clarke em jr programming language constructs for which it is impossible to obtain good axiom systems proceedings of the fourth acm symposium on principles of programming languages rl and david on classes of program siam j comput a function computer science the university of tr phd thesis de least proceedings fixed points of the symposium held in lambda calculus and computer science theory march from lecture notes springerverlag in computer science by g and j de wp recursion and parameter mechanisms an axiomatic approach proceed of the second symposium on automata languages and programming july aug from lecture notes in computer science springerverlag by ac on the of content exchange through the parameter trans mechanism sigplan notices h on correct procedure param transmission in the higher programming languages informatica finite array computer science the university of tr phd thesis manna z and j fixpoint approach to the theory of computation acm ii m s and c e tive conference record of project mac conference on concurrent systems and parallel computation acm new york plotkin gd callbyname callbyvalue and the lambda calculus theoretical computer science el the use of associative memory in implementing callbyname param computer science pennsylvania state university tr l an analysis of parameter evaluation for recursive procedures phd thesis university and hoare car a contribution to the development of algol comm acm 
record of the fifth annual acm symposium on principle of languages a forward move algorithm for lr error recovery thomas j frank of studies university in information of california ca sciences ct a algorithm and some of its formal properties is presented for use in a practical syntactic error recovery scheme for lr parsers the algorithm comparable to a prefix just to the right of a of error for purposes the algorithm is presented as parsing arbitrarily far beyond the point of error in a parallel mode as long as all agree on the read or reduce action to be taken at each parse step ic practice the is achieved by adding to the lr machine based on the formal properties of the move up propose an error recovery algorithm that uses the right context the performance of the recovery is in a specific case nd in key words and phrases error recovery syntax errors cr categories over the past years much effort has been into the science of deterministic parsing that is determining tb e phrase structure of a sentence generated hu by a contextfree a single scan from left to right the t uo of this research are the uk and lr k grammars and their parsers respectively and bottomup techniques unfortunately the more parsing techniques have the more difficult it has to achieve flexible error it seems that the more the parser knows the input possibilities and itself via state transitions to restricted parts of itself the more difficult it is for it in the face of a detected error to back out and get global information necessary for error and recovery in the gf of graham fact that the next move of the parser can depend on the entire correct prefix already analyzed makes it difficult or impossible to start up the parser after th error detection point this paper is a contribution toward giving lr parsers some such global capabilities we show that it easy to extend them to start up after an error far is and to parse arbitrarily right context this context can then be used to guide the selection and evaluation of repair attempts thus ue decompose the notion of error recovery right context and a repair strategy gy graham and propose an error recovery scheme for deterministic bottomup parsers that involves t about the point at which an error detected to the left and a move to the right such context is valuable input and to an error show repair strategy graham how the is done for simple precedence and give an error repair strategy that uses the context ue have adapted the general idea of and to lr parsers by which we mean lr k parsers and all their variants k k etc some of the has already been reported io thesis see also the present paper results and empirical implementation some adds some results of the algorithms from and some a recent briefly we found the i back to be in it in of a cases we of trying every to do only context for what is consistent with as long as possible to only when ve know of no r way to proceed developed a parallel of the forward for lr parsers that and proof of results and we show how to it so that in practice the parser simply has some extra recovery states that work just as the other states do but are entered only in mode several theorems were developed primarily relating to th derived valid during the forward move and dr ha ve so mp similar results which we note as the issues arise move we first present the forward in its parallel form then that we state several properties are relevant to error repair of these properties ways that the forward context may be used in a repair strategy perhaps the most of these indicates used to that the forward efficiently verify is consistent context may be that a repair with the input text parsed by next that are we used present in the several repair strategy he starts with the simplifying assumption of but a single err or of insertion replacement or deletion of a single terminal symbol be effect of delayed versus immediate detection is discussed treated and then for clarity multiple errors and simplicity are the algorithms ain presented without regard to are then discussed in the text finally we show how to a practical implementation present statistics on how states are needed for some well programming languages we extra known we demonstrate our error recovery performed on the example algol program of graham and gr we terminology parsers ba for strings a or notation grammars alphabet and and v is a finite set of symbols v the set of all denotes v of symbols from v s v tf x is a string first x the first symbol of x and rest x denotes x oe its first typically not put parentheses around arguments to functions when the is clear as above a contextfree nonterminals start respectively ie and v each production is a pair aw left pg and gh h in and n part written a w is the the rightmost relation is in which replaced at each and step is is its its transitive closure closure we assume a production s q p where s n and neither s nor appear in any other production the s generated w by g is lg w t an lr parser ie an or other such parser aj is a where for k is a finite star t function set of state s r start q stat e is the k x v into k k is the maps k ve also x v into write p if this as p the h p from derive the and reduce me function pi mapping accept stat e actions grammar a singleton k x v into m where x read u p pd indicates for a given and th input parser symbol may all take possible if the g is lr pd yields at set pd is defined as accept i h and q j q k u s for some in figures we represent lr parsers as state diagrams i r which states are connected by arcs with elements of v according to for each state in which indicates a possible choice of a reduction by production p we list p and its lookahead g h v i p q figure a state diagram the er for a arithmetic expression in this figure for read i and p i l pi fig a simple arithmetic expression grammar and its parser as a and pi take n a a lr parser constructor algorithms generalize to in lookahead inclusion sets also give means of implementing the results of this paper should their in so m he too difficult also note that in figure to bb no nonterminals ir lookahead sets to the nature of the grammar a pg p in an lr parser is a of states i r qn that ql g n nl g n me define top p qn me say that p u n ue define notation p we alternate for p is w given the parser diagram we abbreviate a thus denotes start alone we say that w accesses q iff top the concatenation of two paths and if for q where top q and q and h is then accessing for q h the each state is unique an lr parser is a where z is a path and r g t example the first three symbols the sentence iii have been reduced e by the parser of figure it is the configuration t il pair for of to in the parser moves from one configuration to the next by reading or reducing thus ve define a py as an element of the set read u p i denotes a move from one configuration to another is its transitive closure and i is its closure we sometimes use for if c co by move n we sometimes e c c we define as follows given possible some consider values of m r case read let h first l r read case a w if for some then aw the case accept or or there is no c such that c ie the parser instead halts or input to proceed makes no or the by parser where is w h w we ah s hy note that s accept lr parsing algorithm is from the relation an lr cq th easily a final note vp present algorithms that ma y ways via socalled se if return results in a return value a two different andor via eg the tests the result with the three input of f which is called actual parameters x y and z and the two result parameters a and some will happen to a and b according to the definition of f returning indicated from such by a statement a such function is as return true u v an error is detected we wish to perform a that the input after the point of the error detection the parse cannot depend upon the left context already developed on the stack to proceed that left context since it that causes is precisely the parser to detect algorithm the error that ue an starting no left context our move formulation of the parsing input qx until it left context must to refer proceed to the at that point it halts and we use the developed context in an error repair strategy h the an algollike symbol or construct productions are can these language in appear in a suppose the constructs stint for id exp step exp do stint stint while exp do stat exp where we terminals erroneous phrase nonterminals and left now consider the for x step begin j x end where ue have expression in the omitted th construct limiting the head at j x move if the symbol end to started with reduces its input begin zt goes no further than this because it tp know left context to determine whether at this point it must reduce by production or each of which end in not the reason the forward move can parse this much of the input is because in both places that do appears in grammar it is followed context to th necessary to to ao by thus left of the is reduce j x end this occurs often enough in programming languages that it is not for the forward mov to ma ke quite some progress in input text before it needs to refer to left context the essential idea of our algorithm is to carry out all possible of the input text as long as all to the next move to make ie agree as they must all manipulate the stack in the same way at each parse step and no parse to left context we present the first as which we push sets of states the se sets having states of states a stack ra keep upon than track of the parallel at each step of the forward move we of each state in the set of the top of the stack what its decision is with regard to the next symbol in the input if all the states in that top state set that accept the next input symbol agree as to the next move this next move does not refer to left context then we make that next for in the case of the move we push or the stack the set of all the reached from any state states in the that to can be state set by taking a transition on the next input symbol of course manipulating sets of states is not practical but we how the forward algorithm can be easily converted into an algorithm that states only essentially ii ke the conversion of a finitestate machine to a deterministic one the converted algorithm is as fast as the lr parsing algorithm let states algorithm initialization consume he the set k of we now present the algorithm step that at least one symbol by repeated parse all the the forward has causes of the steps parser an it to input m r the input the forward context developed and the input not consumed init q z be the stack consisting only push r q rest first q r r q q e on repeat h first r q op z of z and u po select no push q i q ol z qf and q q q push qc i q a ql and q le top z on z else return w does not on the stack q qk accept we an error ql otherwise return end notice that the repeated parse steps of parser are identical to those that normally follows save the manipulation of the the sets of states instead of states an d the check just prior to a that the entire right part on the stack essentially follows all paths that allow halts the parsing of the input in case text when it t wo paths end up in states that how to continue the parse or in case a w when all in states a reduction paths end up over the or entire cse accept input or in case another error i e we read when no path the we can be the set computes by represents all the possible ways that tbe states in the top state set q wish to t the input h note that states q as q accept h i e for which have no effect on the decision unless all states in q cannot accept h case we extend each path as far as we can even though other paths terminate a ew below that of illustrate the an where the parser figure halts of hy of concern cases and s example string he state stack the execution th input ii i let the erroneous input the parser the stops with of on the of step just made init read stack after step io best input il of p i t p e t read p e t p ol po l the algorithm halts here because u u t p expression have been result t e t of the between the parentheses could arbitrarily long with the same halts input is stack the parser step stack rest halt are less than above the p e and there three items on the stack n possibilities example we of reducing face the by three different productions e t is the prop er precedes reduction the t only if what immediately is a u or nothing e e t is the proper what immediately precedes reduction only if the t is lt and t p t is correct only if wp ii the t but no context exists to the left of t th us we cannot continue parsing and must halt different situations which it can decisions the t without read as making effect in the at to a guess the three parser in yield three to do with tn example w attempt to reduce with pe but find that w does not ii on the stack the gives us an of what the user intended however and may error provide useful information r strategy called for an as we explain in the next section the initialization guarantees that step of the algorithm produces a forward context of th at least if we not cause to read the first it consider all reductions that have the first in their lookahead sts possible choices between a read and reductions might have case caused to halt immediately in making no progress we also for the remainder of this paper that we never invoke on the input consisting of otherwise we would immediately read l in step init in section ue the state sets of fh as states this allows us to extend the concepts of transitions and paths to text sets hence if u from string uv and produces forward context u we uv uv the relation l that can from is the same as that of the lr parsing algorithm but to prevent confusion between the lp parsing algorithm and fa we prefix moves of fa by v as above uv u satisfies important properties that we explore in this section essentially u is such that during a parse of any sentence in uv u must be reduced to u we formalize and indicate the of this property in this section do so we define some new terminology is any prefix of where s for some y v a wp and v in the string by the stack at any point during lr is a valid prefix a y is a suffix of a valid ie valid are prefix of the by the stack for example for the grammar of figure e so any prefix of ee is a valid prefix eg e and any suffix of e is a valid fragment e g we now define the concept central to this paper n d iff u in pf v is a derived suffix x u u and x uv for some u v in t for every and y such q read i that thus during ending in uv must reduce the requirement a of any at so me the parser u to the valid u that the first i is i read rela ts to the fact that reads as its first move in the context of error this concept the suppose the parser an error and halts in with uv a suffix of a and that an error ir algorithm y as a possible replacement for z we could verify that by actually the parse but if many such y s were to be tested uv each time would be y the of having t of uv is that in u we have a partially version of u and need repeat this partial parse for the property states that u must b reduced to q no matter the string to the left of uv a necessary that not sufficient i is as follows let y be such that y uv i and uv read it must be the case that this is by definition of and due to the fact that y only if i any yt then this requires then i a i for only that we y and whether a path exists from top y u determining the existence of the path is considerably than u if u is much longer than u and gives us an test to determine if the proposed enough stack to cause repair the parser y is good to consume u for algorithm computation convenience just described we that performs and u a path and forward context a boolean whether value indicating can consume ij and either the successfully computed path or an error message while for p the productions and for some path z y z ie moves gy first moves read f false now ue must le able y gi to find path exists return else return false giving path en d in error reduce u a path f t he the not that the is the when the computation of is on first u rather than first u namely if pa th exists produce the same result if not t g first j rather than first u cause the to be earlier might lot equal to read capability me get this because earlier first detection u may be a nonterminal representing not only first u but also some text to its right and hence first u may be a member of lookahead of which first j is not a member sets further that takes path as its first argument rather than just paths eventually at intend this is because we to use it with paths produced by also our is in context theorem pn returned by the proof of which is that the forward is a uv if a of uv for some sentence suffix i cv then u is this theorem results intuitively the fact that uv initial left context thus u reduced to u no matter what context of u with must the from no be left we in as much as refer to formalize this that it can until it left context below must we u v is f of three sentence conditions suffix i the x al iff the that u is a of x where u u and x uv for some u v q t u is any other of x where u ut and x for some u there exists v t y such that read thus by the definition of an l y i as far up so the derivation tree of as possible v must be a suffix of v so that u ie u derives the longest possible prefix of x fv v then we see that u is reduced as much as possible since then u u n would that produces as far the as it could into input reduce as much as it could does not always compute th this is because is restricted to the parsing therefore technique to as the lookahead parser an algorithm to might n all of x perhaps some contextually symbol located the end of x that could help it parse earlier text an on an machine might be by one based on an machine for the same but given the limitation of th base parser fa does as it can these restrictions are encoded in the following theorem that in terms its base theorem sentence if and a sequence consider suffix uv of a there integer r of mr that i el read ii there exists some state qq k and u v such that ly h and iii there ex no valid prefix y k r and configurations c and c such that then y u v r corollary makes moves as possible in theorem applied the greatest where r to a sentence number r of is as defined apart from the of in error satisfy other useful properties the property is helpful in selecting error let uv be a sentence suffix and u be the of uv returned by m i y lj v for some a valid prefix c c in other moves that configuration since each step for words moves contains all the the parser may make from some intuitively knowing y at represents the set of all possible yes the utility of the next property is illustrated as follows example of the previous a in the by production two for the algol section moves indicating and reduce by production where u do the next move says that if wp find y such from con that ion the parser move h v then h must be one ot two reductions either puts a constraint on y it end in her td exp step xp until exp or x sometimes use the elements guide us in selection of up may thus of we call these long because if per during the forward move they would attempt to pop the state set in the example fa in case such long reductions can sometimes provide instant to some errors xn this example a of the stack with the set moves shows that we should up the stack by inserting the exp continue practice we search the stack the point of error detection for some state that can read the left part of either production we call this technique forcing we mention this further in the next moves may contain elements that are not such as or a rt reduction but we do not yet know best to make use of this information ne formalize the next move property as suffix u and x s be a uv v let x be vf of x such and moves then a that q sentence u u u moves for a similar u y v a valid result m i prefix see i c for some c dr we can further use the next no ve property to help errors if i uv but halts in case ie then uv is not a sentence suffix that ls an error has occurred in the text uv because there exists no y such that s more ly since we are dealing with parsers the error has in the of the first symbols of uv in summary we have shown that provides an test for stack sometimes points us directly to the repair we need to continue the parse and sometimes finds a within which an error has occurred we do not how in the general case to come up with stack in a more specialized case in which we assume knowledge of the types of errors ue have a of designing stack us pair using vl given and its formal properties we now proceed to develop an algorithm that finds a uses ble configuration in which to the parser in our initial analysis we make the error assumption viz the z in question from a sentence via a single an a replacement or a deletion of a le terminal symbol z and s replacement z and s deletion z yx s yx but not s but not s but not s yx in the next few we assume an lrk as opposed to or parser and we even assume that the parser detects the error at the point of then we generalize and discuss the consequences suppose the parser detects an error in configuration thus t is an symbol in the left context by suppose further that we have reason to believe that an insertion of t occurred how could we that p straightforward way is simply i e to if delete t a nd zx i resume similarly if we thought the was the replacement of some terminal te by t we must resume with and if the deletion of t just prior to t then now in the error recovery context we have no as to which of the above may so we must try them all furthermore if none of them work we can for an parser and that the occurred left of the point of error detection ie the parser incorporated the on its stack in the case of an or k parser even if the correct is the above may not work since the parser have made reductions ignoring the by looking at or symbol that the corresponding parser would not have in these cases will involve some form of up the parser but before considering those implications let us consider the use of fa to reduce the cost of to limit apply been reduced the to to repeated of x x segments until ul it we has jn we call th is process which can be defined as follows x g x u such followed that by s x v u v furthermore not having that will extended found a we forward trying the deletion or replacement may t to the u u by using for m nl if t cannot above thus producing m nl we have he attached to v m n if t can be attached to ll but the resulting nl cannot be attached to u m if t ul u get combined but ot algorithm and nw is specified what we mean by by the following algorithm the symbol to he attached the sequence of to it to output a value the resulting sequence and of let p be a path such that g p while c is not null g pt be a path variable p first c p the n p pi c c p ends in then false not anything irrelevant else true p c q true giving p end and ln an above wp have assumed the operation augment on sequences that a sequence of length n by adding a element the left to the front left of a sequence of length n the right operand none of the detection suppose that or succeed an easy to proceed is to start the stack on q symbol at a tim trying and of path symbol h then if none of these succeed h to the previous and trying in front of h just as we did for the symbol which has now least me as follows this entire ce the configuration g the configuration le h and h first r z z r while is not try empty do then c be a configuration variable g try zi c hf return c h op z g z then return s c ie give up by g en d pop z gives c note that we return from when w try a repair that succeeds with c however the if error configuration is detected by having we exit from the isolated the loop to within a the text from the token of the associated with the symbol h up to the original symbol a message should be to this effect perhaps in this case we should just delete all the text in the and call error recovery recursively we have above to as suggested in section at this point investigation and development the overall algorithm is needed down the stack is of course an attempt at caused by in some cases the will not have affected the phrases around it a replaced symbol for example may still be on the stack or simply reduced then a deletion replacement or insertion df a single symbol precisely the in fact to increase the of a repair we have found it to try nonterminals as well as terminals ie as and this off when for example a has affected only one phrase on the other hand a only detected can have caused an arbitrarily large amount of to occur on the stack in th sense that many reductions may have occurred that would not have on the string for example inserting a before an operator in the right part of an assignment statement x x y z it typically results eg in the text to the left of the being to a then ue are left with an ex the right o the to in such up would like to partially symbols on the stack then try the another example is the plt the assignment ii here the conditional is statement may statement up x y z fi reduction which look like to the else of x when an the n ii y z to statement occur with a i or parser but not with an parser ue are still approaches to from such potentially approaches t which and we are something looking formal for can be said restrictions that since might limit such that research is incomplete ve from discussing the ideas here other forcing mentioned than to note that stack in section above appears t have good potential ultimately ay scheme used have a significantly greater potential parsing for after making a upper repair will have done the lower level parsing than it has of spurious repair for causing error several e g if the left bracket symbols finally note that we give up by the parser it is done ie by returning configuration to it this the is not since we have already partially parse the input beyond the point and we are only giving of error detection up the to parse the remaining upper thus the to detect some other parse errors all of now in practice the remaining we not input but rather ue stop at a point after it has produced at least say symbols of forward context we consider a then if after the repair all of the forward context can be parsed then we return and the to the parser the resulting stack input for purposes however ve continue the presentation in terms of the simpler if approach of partial parsing to the end of the program the practical modification s a re not to make but they the presentation try z v a state and a sequence a boolean value a configuration stack of q return false en d try nothing irrelevant th algorithms presented above are in several ways we have already rather than allowing it the program being to proceed to the end of parsed now wt consider the possibility of several to one program ln this case may in error before the desired number of symbols thus we simply accept the first that successfully reaches the subsequent detection point it may happen that will not detect a subsequent error to its lack of upper level parsing any such error will have to be after a repair is x was created for y z then by an suppose else and inserting a gg and suppose one relevant production is gg an error is at the yt is is invoked after the first the parser be ready to reduce to look but no reduction can be made due to incomplete parsing to the left so calls again starting at the second then the inserted g is not again the solution of choice is to take the repair that results in getting the into the extended context before detecting a subsequent error semantics given scheme it ls this error recovery to be worth trying to continue to that static semantic analysis andor code even after the t error is encountered since parsing proceeds in a order le on e in a compiler whose parser builds an tree which is to be traversed subsequently to parsing for her analysis and code generation ue may during and simple led to th subtrees together appropriately for subsequent of course will result in a tree but that in just presents an error detection and problem to the subsequent processor if a formal technique such as an gram mar the static techniques analysis der may prove is adapted to semantics of on trees can be used to the see g and and thus our algorithm useful too nonterminals in lookahead sets allows us to construct an improved version of fa is applied to a sentence suffix it may halt by an case ie the terminal symbol is to resolve the parsing however immediately applies to that symbol and what follows resulting in a that may begin with a that j sufficient to resolve the this is because the represent arbitrarily long lookahead ie the that was reduced to it and perhaps one beyond due to the usual lookahead it review recursively us then to the decision at the end of the prior each time a new one is computed th at begins with a this approaches the parsing of the style as suggested by knuth put x a sentence a sequence of suffix derived x g return else u v be such that i v s be an empty stack of paths push u on s while v l u vi be such that v t uv from x first u j n the s is not g z be a path variable s then u g push g on exit from ut pop s s exit loop gg gg z gi q return the the paths sequence on s of followed by by even this algorithm can he improved each time we at the beginning of the begin with tt representing while loop we no knowledge of left context but ve do know the left in this case viz the possibilities are restricted to those by the top state in th top with then of we where path of q on the with state s ma top of its stack with set rs q i s yx y y v x j y q y accesses ql the states from which first x can be read after y is reduced to some y are in the idea of using a restricted rest art state has been suggested by ai ai for use in although his states are different from ours and do not apply to lrk parsers in general in this an algorithm sets but making it section that practical we states as not state thereby computes sets dynamically by referring to the states cases read and a w of see here is no reason why we cannot these state sets and the transitions between them this rise to a separate set of states for we compute these states as follows let k be the set of parser states the set k of states is computed by beginning with k repeatedly add to k the successors of state sets in k where for s g v the of q k is q i q s p and q q use to the thus computed transition function for ks now we define the decision function where q is a state in kr and h a terminal in terms of the states q simply ij observe that the of moves in is just this same computation thus algorithm below achieves the same effect as f algorithm as in as in init g z be the stack consisting only of push on z r rest r t let h first r q top z and moves select g moves read push on z r rest r gg a w if possible it zl q pop wi states off of z push a top za on z she qk accept ua r an error otherwise pdl end end it should be that and are equivalent is as fast as the lr parsing algorithm save the check i case a w that states on the stack now that states rather state sets we can suggest a space optimization suppose for some q q k q ag this often if q is a then s q once fa pushes is also a transition a q on its stack an until it g it will behave as if it had pushed state q on its stack thus we may share state q in kc with state q in k states in k having modified transitions to instead into have can be the same transitions into q such sharing reduces the storage required for the recovery package the following satisfied hy but not only by the singleton states in kt determines whether stat e occur for any q q k q e k q may share with q iff for every y in v and a path if y a path from q to q then from g to q for every h in other words the that q and other than criterion must tie singleton to the see same sets this states satisfy let in k this to a t and tl a t b t both members of k let q k note that to u tl tl then if for every h e v may he shared with tl this is the same as requiring production h that t in the state lookahead to be a for subset of the lookahead for state t production states be shared occur in practice a that but they t in can are nontrivial to determine states are easy to find when generating shows the state k with shared with states in for the state diagram of due to state of extra states parser is only upon the grammar need an increase and for t percentage needed over th original about for pascal we of for the significant differences between our approach and that of and dr is that they compute the states k via the lr algorithm using actual sts of lr items see aj and they do not show how to compute the lookahead sets needed by for or parsers our technique works equally well for l or any other parser stop t j et a t p p top o wo i ei o q fig transitions singleton with the reductions omitted state diagram representing between states in k states in k have been corresponding states in associated with have since never considers shared k been them s conclusions the proof of an error algorithm is in its performance in a practical environment quite a part from any nice theoretical properties it have were kind enough to share with us a ta pe containing erroneous pascal programs tie ran our preliminary up i array j k b a b k l tj j k l end fi line token ls expression declaration s tt was inserted after and before nw error fo s lg g error for hard fo error follows forward repair error forward repair error forward gg line token h primary was inserted after and q line token else inserted g error after c and before error i line token primary cl a ii error is was replaced with tt after nk k and line token lan error was a i and before line token at w m was inserted expression primary after qs expression and before error line token w variable term expression primary error q was inserted after n follows forward rep line token variable b primary error was inserted w expression after sc an gm forward repair line primary was token ij variable ltl expression expression after and before expression then error error forward repair line token statement expression then ­ was deleted after an before end o f parse figure of error recovery algorithm of graham and on program implementation on pascal grammar mechanically from diagram son of the them gi a more syntax each repair ra by the if it the text as a human reader would have if not but it still in a reasonable program and no spurious spurious if it errors in fact in one or more none in more than one spurious error and if no repair was but we the parser to parse via rather he results than good i j total ve have counted spurious errors in these statistics note that were good or with some we to reduce the and responses in number the cases both us of parsing and sometimes affect recovery from other errors he have no idea how much different these statistics might be for more errors made by programmers with the language as another concrete of the algorithms performance we present in figure the erroneous algollike sample program used by graham to illustrate recovery the algorithm gr of their error we used the same algol subset grammar as they our are identical to without the need for a for symbols or a pattern algorithm we rate each repair as except the insertion of the identifier between and on line which we rate since we have no idea what the human might have done ue should stack note that the in a good repair except in the critical case of the deleted in the program above some question as to whether thus there is that technique is should at its least computational b delayed techniques have cost until it no clearly more research no intended are we do not even implemented nor have in order have we tried and errors currently adding the improved states johnson aho v parsing june u s c co au aho v and d unman theory and pa rs inl vol nj der com m frank simple lrk july der nsf information of california frank sciences proposal to ca david simple computer lrk science univ az c and g for dept of of dp c david for error recovery and of computer science univ of az and g parsers dept gl practical syntactic ac ej jj error hu john e an d jeffrey d gg to automata addisonwesley reading holland in cd n amsterdam north a nd generator db wh prenticehall nj jj inc h o of the michael lrk f parsing to include automatic error recovery thesis univ of at ca fi june i recovery for lr parsers thesis information sciences university of california at ca david e parsing for department of science of glasgow glasgow 
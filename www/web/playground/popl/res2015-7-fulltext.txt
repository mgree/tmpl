popl consist well easy to complete contextsensitive analysis in presence of callbacks wang lu key laboratory of high software of university department of computer science university of texas at san tx usa department of computer science university of texas at tx usa abstract building a summary for library code is a common approach to up the analysis of client code in presence of callbacks some reachability relationships between library nodes cannot be obtained during summarization thus the library code may have to be analyzed again during the analysis of the client code with the library summary in this paper we propose to summarize library code with tal reachability compared with the summary built with cfl reachability the summary built with tal reachability further contains conditional reachability relationships the conditional reachability relationships can lead to much analysis of the library code during the client code analysis with the library summary we also performed an experimental comparison of contextsensitive analysis with the library summary and contextsensitive analysis with the library summary using benchmark our experimental results demonstrate that the former has an x speedup over the latter on average categories and subject descriptors f logics and meanings of programs semantics of programming languages program analysis f mathematical logic and formal languages formal languages classes defined by grammars or automata general terms algorithms languages keywords tal reachability cfl reachability contextsensitive analysis analysis tree languages introduction libraries is in modern software development the existence of various software libraries makes it possible for developers to reuse products of numerous previous software developers as a result a modern software application is typically composed of a large volume of library code and a small volume corresponding author permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than acm must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january copyright c acm of client code for example a typical java based application from benchmark suite involves controlflow graph nodes while of them are from libraries the size of used library code in an application becomes a burden for various program analysis tasks one common approach to this problem is to build a summary for each used library based on the library summary the analysis time of the client code becomes much the summary for the library can also be built once and reused many times for analyzing all its client applications analysis aims to identify the chains in a program and has many applications such as slicing and impact analysis for contextsensitive analysis a typical way to build the summary of a library is to use cfl reachability where a cfl typically the language is used to filter out invalid paths in the dependence graph however the possible existence of callbacks an for the library code with cfl reachability when there are no callbacks the analysis of a client application can be confined to the client code with only queries of the summary of the library code that is to say it suffices that we know all the reachability relationships between library nodes after the library code in presence of callbacks even with the library summary the library code should still be analyzed as well as the client code because callbacks may new reachability ie dependence between library nodes to further our research let us consider the following example for contextsensitive analysis package library public abstract class public final int x int y x int z return z private final int x int y x int z return z abstract public int x callbacks are invocations of the in the client code from the library code due to the convenience of libraries many major programming languages provide some mechanism eg dynamic binding to support callbacks c x c y l x l r l l y x l l z r l x l y x c l z r c y c r l figure graph for the example as shown in the above code there is an abstract class defined in the library the abstract class provides a public method named method for its clients and requires its clients to implement a public method named method which may lead to a callback the client code is listed below where extends the abstract class in the library with an implementation of method resulting in a callback package client class extends public int x int y x return y public class main public static void args p new int x int y that it is required to determine whether the value of y in the main method after calling method depends on the value of x this problem can be turned into the problem of determining whether it is reachable from node c to node c in figure where the nodes are from the code and the ith line in code is labeled as in this figure the edges labeled with ii i correspond to direct data dependence by the four method and nodes l l and c represent the result values immediately before the method returns denoted as r r and r obviously it is reachable from node c to node c if we use cfl reachability to analyze both the library code and the client code ie the value of y depends on the value of x however when only the library code with cfl reachability as nodes c c and c are not available yet it is unknown whether it is reachable from node l to node l only when the client code is available can it be determined that node c is reachable to node c then the library graph should be analyzed again to determine that it is actually reachable from node l to node l with this information node c can be determined to be reachable to node c note that nodes l l l and l are essential here to determine this reachability relationship even if we already have the summary of the library code without these four nodes we cannot know that it is reachable from node l to node l note that is marked as dashed line because it is the to an abstract method figure graphical representation of our solution the basic idea of our approach is to further calculate conditional reachability relationships as well as reachability relationships when the library code below we define conditional reachability in definition definition conditional reachability let g be a directed graph and x y i and j be four nodes in g it is said that there is a conditional reachability relationship among x y i and j denoted as if it is reachable from x to y when a new reachability relationship from i to j is added for of presentation if y we also state that there is a conditional reachability relationship from x to y depending on the reachability from i to j figure the graphical representation of similar to the reachability relationships in cfl reachability conditional reachability relationships can also be labeled with different symbols to distinguish conditional reachability relationships of different types for the motivating example there is actually a conditional reachability relationship from node l to node l depending on the reachability from node l to node l ie ll if we obtain this conditional reachability relationship when the library code we can immediately determine that it is reachable from node l to node l after we analyze the client code to obtain the reachability from node c to node c that is we turn the conditional reachability relationship into an one in fact calculating conditional reachability during summarization has the following two benefits first we can save some computation when analyzing the client code as such computation has already been performed when analyzing the library code in our example the computation for determining ll actually involves some computation for determining the reachability from node l to node l under cfl reachability second since we have the conditional reachability relationship during summarization some nodes ie nodes l l l and l in our example in the library graph become unnecessary for analyzing client code thus we can further avoid some unnecessary computation involving these nodes when analyzing the client code of course calculating conditional reachability would extra computation during summarization as a conditional reachability relationship involves four nodes in the graph it is beyond the power of cfl reachability to calculate conditional reachability therefore we turn the problem of conditional reachability relationships for the library code as a problem of calculating tal reachability languages each of which can be defined with a grammar tag are a family of contextsensitive languages that can represent much context sensitivity in natural languages as there are constructs denoted as secondorder nonterminals in this paper in a tag to represent two strings with some symbols between the two strings such a construct can be used to represent to avoid ambiguity we also refer to the reachability relationships calculated via cfl reachability as reachability relationships note that the meaning of context sensitivity in the formal language theory is completely different from that in program analysis conditional reachability where the reachability between two library nodes depends on the reachability in client code based on the definition of conditional reachability we can summarize a library that contains at most one callback on any path if multiple callbacks exist our approach a small number of selected library nodes in the summary and uses these nodes to chain multiple conditional reachability relationships in such a case the library is not because some analysis is still required on the selected library nodes during the client analysis phase however the client analysis phase can still be significantly as validated in our evaluation because only a small set of library nodes need to be analyzed to evaluate the performance that our approach achieves for analyzing client code we compared our approach with the approach that cfl reachability to summarize the library code using java applications as our evaluation results demonstrate that the analysis of client code using the summary achieves an average x speedup over the analysis using the summary contributions and paper organization in summary this paper makes the following main contributions  a concise formalism for defining tal as the normal form for tags  the proposal of tal reachability and the first polynomial algorithm for calculating tal reachability  a formalization of the problem of library code with callbacks for contextsensitive analysis as a problem  a sound technique for contextsensitive analysis of client code based on the summary calculated with tal reachability  an experimental evaluation of our approach on a number of benchmark comparing with the approach using cfl reachability to summarize the library code languages and grammars for natural language processing researchers have investigated some to define contextsensitive grammars to parse in a natural language which is typically a contextsensitive language in particular there are four investigated for defining contextsensitive grammars grammars head grammars linear indexed grammars and combinatory grammars according to these four actually define the same family of languages which are in on time where n is the length of the sentence for parsing thus in this paper we refer to the language family described by all the four grammars as languages as all the four existing grammars are not suitable for defining tal reachability in section we present a new and concise formalism that defines the same language family as proof given in the appendix our formalism is actually the normal form for tags which is suitable for defining tal reachability and analyzing its complexity we define our grammars tags by extending the formalism for defining cfgs a contextfree grammar g is typically defined as a denoted as gn t p s where n is a set of nonterminals t is a set of terminals p is a set of productions and s is a nonterminal in n each terminal in t is a character and each nonterminal in n represents a set of strings each being the concatenation of some terminals in our formalism for tags there is a new type of nonterminals each of which represents a set of ordered pairs of strings to distinguish the two types of nonterminals we refer to nonterminals representing strings as firstorder nonterminals and nonterminals representing ordered pairs of strings as secondorder nonterminals in this paper for the ease of presentation we use letters eg a to denote firstorder nonterminals letters in the eg a to denote secondorder nonterminals and letters to denote terminals furthermore for two strings denoted as and if the pair of and is in the set of pairs of strings that a represents we denote that a can represent note that as each pair is ordered indicating that appears before and indicating that appears before denote two different pairs similarly if is in the set of strings that a represents we denote that a can represent in the formalism for defining cfgs there is only one operator ie the concatenation operator to connect nonterminals ie firstorder nonterminals andor terminals in the formalism of tags there are a number of extra operators to connect secondorder nonterminals and firstorder nonterminals specifically there is one operator to connect two secondorder nonterminals and the result is a set of pairs of strings this operator is called the operator whose semantics is defined in definition definition operator let a and b be two secondorder nonterminals the semantics of the operator is as follows  a b a b in definition and throughout the rest of this paper we adopt the convention in the formalism of cfgs to denote the concatenation operator that is to say when we put two symbols each being a firstorder nonterminal a terminal or a string immediately side by side we mean the concatenation between them for example we use to denote the concatenation of and the formalism of tags also includes four operators to connect a secondorder nonterminal and a firstorder nonterminal the result of each such operator is also a set of pairs of strings in fact the four operators are extended from the concatenation operator between firstorder nonterminals and the differences lie in the position for concatenation thus they are referred to as the extended concatenation operators definition provides the semantics of the four operators definition extended concatenation operators let a be a secondorder nonterminal and b be a firstorder nonterminal the semantics of the four extended concatenation operators are as follows     these four extended concatenation operators can also be used for connecting a secondorder nonterminal and a terminal for example a a represents all pairs of strings in the form of a the formalism of tags has an operator to construct a set of pairs of strings from two firstorder nonterminals referred to as the pairing operator whose semantics is provided in definition definition pairing operator let a and b be two firstorder nonterminals the semantics of pairing operator is  a b a b the pairing operator can also be used to the situation where either a or b is a terminal or ie the empty string for example a represents the pair a in contrast to the pairing operator the formalism of tags has a operator to obtain a set of strings from one secondorder nonterminal definition provides the semantics of the operator definition operator let a be a secondorder nonterminal the semantics of operator is  a a based on the preceding operators and the concatenation operator used for defining cfgs the grammars tags are defined in definition definition grammar a grammar g is a denoted as g n n t p s where n is a set of firstorder nonterminals n is a set of secondorder nonterminals t is a set of terminals p is a set of productions and s is a firstorder nonterminal in n productions in p to the following rules  the lefthand side of a production must be a firstorder nonterminal or a secondorder nonterminal  if the lefthand side of a production is a firstorder nonterminal the righthand side of the production must be in one of the following forms the operator on one secondorder nonterminal the concatenation of two symbols each of which is either a firstorder nonterminal or a terminal one firstorder nonterminal one terminal or  if the lefthand side of a production is a secondorder nonterminal the righthand side of the production must be in one of the following forms one operator on two secondorder nonterminals one extended concatenation operator on one secondorder nonterminal and one firstorder nonterminal or terminal the pairing operator on two symbols each of which is a firstorder nonterminal a terminal or or one secondorder nonterminal example the following tag defines n s s s s d s s a s s b s s c theorem the language family defined by cfgs is a true subset of the language family defined by tags proof the second rule in definition defines a normal form for each production whose lefthand side is a firstorder nonterminal except for the operator this normal form is actually a variant of normal form therefore any cfg when transformed to the normal form required by this rule is actually a tag with no secondorder nonterminals as we know that the language defined in example is not a cfl the cfl family is a true subset of the tal family tal reachability as demonstrated by reps the notion of cfl reachability can be generalized to where l can be any family of languages by l to the family of we have the problem of tal reachability in the following we present to our knowledge the first algorithm for tal reachability which is actually a polynomial algorithm algorithm calculate tal reachability input directed graph g and productions of tal language l output t relationships for g initialize the work list for each edge ei j labeled with a and i j n in g do add a i j to r add a i j to w end for each i i n do add i i to r add i i to w end add reachability for productions while w is not empty do select and remove the first item denoted as from w if is in the form of x i j then try z x for x i j try z xy for x i j try z y x for x i j try z y x for x i j try z y x for x i j try z y x for x i j try z y x for x i j try z x y for x i j try z y x for x i j end else if is in the form of x i j k l then try z x for x i j k l try z x for x i j k l try z x y for x i j k l try z x y for x i j k l try z x y for x i j k l try z x y for x i j k l try z x y for x i j k l try z y x for x i j k l end end algorithm our algorithm for tal reachability depicted in algorithm is a dynamic programming algorithm which can be viewed as an extension of the worklist algorithm for cfl reachability proposed by and reps our algorithm maintains a work list ie w containing two categories of items each item in the first category represents the adding of a terminal or a firstorder nonterminal such an item is in the form of x i j which represents the adding of x between the ith node and the jth node in g each item in the second category represents the adding of a secondorder nonterminal such an item is in the form of x i j k l which indicates the addition of a secondorder nonterminal between i j k and l furthermore we use r to store the calculated reachability information of terminals and firstorder nonterminals and r to store the calculated reachability information of secondorder nonterminals in algorithm the two initialization steps lines to add reachability information into r and items into w for terminals labeled on edges of g and between a node and itself the main body of the algorithm is a large loop lines to in which we iteratively deal with the items in w we further divide each iteration of the loop into two parts the first part lines to deals with items in the first category and each line between line and line deals with one type of productions involving x at the righthand side the second part lines to deals with items in the second category and each line between line and line deals with one type of productions involving x at the righthand side note that lines to deal with basic cfl productions which has also been described in and algorithm for cfl reachability algorithm try z y x for x i j for each production in the form of z y x do for each y j k l p in r k l p n do if z i k l p r then add z i k l p to r add z i k l p to w end end end algorithm the details of line in algorithm as the righthand side of such a production indicates that x appears immediately before the first string of y algorithm looks for reachability information of y in r satisfying this requirement if such information exists we add reachability information of z with the corresponding nodes the algorithms for lines and are similar to algorithm the differences lie in the different ways that x with y the details of line in algorithm are depicted in algorithm as such a production does not require y to be with x algorithm looks for reachability information of y in r with no further requirement if such information exists we add reachability information of z with corresponding nodes the details of line in algorithm are similar to algorithm algorithm try z x y for x i j for each production in the form of z x y do for each y k l in r k l n do if z i j k l r then add z i j k l to r add z i j k l to w end end end the details of line in algorithm are depicted in algorithm to the two strings represented by x we require that the first string should appear immediately before the second string if this requirement is satisfied we add reachability information of z between nodes i and l line in algorithm is similar to line in algorithm the difference is that line deals with productions each having two secondorder nonterminals while line deals with productions each having two firstorder nonterminals line to line in algorithm are similar to line to line in algorithm the difference is that for line to line we look in r for firstorder nonterminal y that can with secondorder nonterminal x algorithm try z x for x i j k l for each production in the form of z if jk z i l r then add z i l to r add z i l to w end end x do the details of line in algorithm are depicted in algorithm in particular we look for reachability information of y in r such that the first string of y appears immediately after the first string of x and the second string of y appears immediately before the second string of x the details of line in algorithm are similar to algorithm algorithm try z x y for x i j k l for each production in the form of z x y do for each y j p q k in r p q n do if z i p q l r then add z i p q l to r add z i p q l to w end end end time cost as our algorithm does not allow one piece of reachability information to be added more than once we have at most n items in the form of x i j and at most items in the form of x i j k l then we focus on analyzing the asymptotic time cost of dealing with one item in the form of x i j and one item in the form of x i j k l respectively we summarize the result of our analysis as theorem lines to deal with each item in the form of x i j among them line requires the same asymptotic time as line line requires the same asymptotic time as line or and line requires the same asymptotic time as line executing line once requires on time asymptotically because given x there are at most on productions in the form of z x given x there are at most productions in the form of z xy and for each such production there are at most on distinct pieces of reachability information of y such that x appears immediately before y thus executing line once requires n time asymptotically given x there are at most on productions in the form of z y x and for each such production there are at most on distinct pieces of reachability information of y such that x appears immediately before the first string of y thus executing line once requires time asymptotically given x there are at most productions in the form of z x y and for each such production there are at most on distinct pieces of reachability information of y thus executing line once requires n time asymptotically in summary lines to deal with one item in the form of x i j in n time asymptotically lines to deal with each item in the form of x i j k l among them line requires the same asymptotic time as line line requires the same asymptotic time as line or and line requires the same asymptotic time as line executing line once requires on time asymptotically given x there are at most productions in the form of z x y and for each such production there are at most on distinct pieces of reachability information of y such that y appears immediately before the first string of x thus executing line once requires n time asymptotically given x there are at most on productions in the form of z x y and for each such production there are at most on distinct pieces of reachability information of y such that the first string of y appears immediately after the first string of x and the second string of y appears immediately before the second string of x thus executing line once requires time asymptotically in summary lines to deal with one item in the form of x i j k l in n time asymptotically theorem the asymptotic time cost of our algorithm is where l is and n is the number of nodes in g i i a type boundary node i b type boundary node i c type boundary node d type boundary node figure four types of boundary nodes in summary contextsensitive analysis with tal reachability on top of tal reachability we propose a novel algorithm for contextsensitive analysis to calculate the reachability relationships between each pair of client nodes our algorithm consists of three steps first we build a summary containing conditional reachability information via analyzing the library code section second we further process the summary to make it suitable for the analysis of client code section third we use cfl reachability to analyze the client code based on the summary section in section we demonstrate the soundness of our algorithm library code with tal reachability definition defines the tal that we use to summarize the library code in this grammar s represents reachability with exactly matched parentheses and s represents conditional reachability with exactly matched parentheses similarly s and s are for and conditional reachability with opening parentheses and s and s are for and conditional reachability with closing parentheses definition tag for summarization s s ss e s s s s s s s s s s s i i s s ss ss ss i s s s s s s s s s s s ss ss ss i s s s s s s s s s if we use the tal defined in definition to calculate tal reachability on a dependence graph g we actually obtain exactly the same reachability relationships as we use the cfl defined in definition to calculate cfl reachability on g however when calculating tal reachability we also obtain conditional reachability relationships as well as reachability relationships in fact our algorithm always first determines a conditional reachability relationship and if the conditional reachability relationship is in the form of y for some i our algorithm specifically algorithm then determines an reachability relationship from x to y therefore if we are a library using the tal in definition allows us to summarize more information than using the cfl in definition definition cfg for contextsensitive analysis s ss e ti is s ss ss ss i s ss ss ss i if we use this cfl to analyze both the library code and the client code we can calculate all the contextsensitive relationships x i j x i j x i j x figure nodes to make the summary obtained in section suitable for analysis we need to remove some unnecessary reachability relationships from the summary let us consider our example discussed in section besides ll our algorithm also some other conditional reachability relationships using the tal in definition eg ll in fact ll does not provide further help for analysis but may unnecessary computation to identify which information in the summary is unnecessary we first identify in the summary a set of nodes such that only the reachability information among them is sufficient for analysis in this paper we denoted these nodes as the f summary nodes it should be noted that the is an important way to reduce the cost of client analysis when multiple callbacks exist as the size of graph representing library summary the graph will require much less unnecessary operations adding nonterminals to edges during client analysis fundamental summary nodes first all the boundary nodes are f summary nodes since the reachability transfers between the summary and the client through them actually there are four types of such boundary nodes in the summary figure in which we use gray nodes to represent boundary nodes in the summary and white nodes to represent client nodes four boundary nodes each of a different type the boundary node referred to as the type boundary node in figure a receives a value from the client via a call of a library method the boundary node referred to as the type boundary node in figure b returns a value to the client via a method return the boundary node referred to as the type boundary node in figure c passes a value to the client via a callback the boundary node referred to as the type boundary node in figure d receives a value from the client via a return of a callback second it is still only keeping all the boundary nodes given one type boundary node denoted as x and one type boundary node denoted as y in the summary there may be a chain of two or more conditional reachability relationships between them if all the conditional reachability relationships in the chain are turned into we have an reachability relationship between x and y note that as such a chain may depend on more than one reachability relationship provided by the client it cannot be represented by just one conditional reachability relationship therefore we need to keep all the nodes that may connect two or more conditional reachability relationships we refer to these nodes as the nodes figure a in this figure both nodes x and x are nodes third there are two ways for one conditional reachability relationship denoted as to become the first way is that the client provides an reachability relationship to make the conditional reachability relationship become in such a case i must be a type boundary node and j a type boundary node the other way is that a chain of conditional reachability relationships eventually provides an reachability relationship to make the algorithm identify nodes x x i j x i j x i j x y figure hidden nodes conditional reachability relationship become in such a case either i or j may not be in the set of boundary nodes or the set of nodes we refer to such nodes as the hidden nodes which should also be kept in the summary figure in which node x and node x are hidden nodes such a situation we further distinguish hidden nodes into two types type and type in figure x is a type and x is a type hidden node note that a f summary node can be of multiple types eg a type boundary node may also be node identifying fundamental summary nodes for each node x with at least an incoming edge labeled with a closing in g do add x to c add x to w end while w is not empty do select and remove the first item denoted as from w for each outgoing edge denoted as oe labeled with e of do change the label of oe to an closing suppose that oe to y if y c then add y to c add y to w end end end for each node x in g do if there is at least one incoming edge of x labeled with a closing and there is at least one outgoing edge of x labeled with an opening then mark x as a node end end nodes can be identified before calculating tal reachability the algorithm for identifying nodes is depicted in algorithm obviously the time cost of algorithm is on e where n is the number of nodes and e is the number of edges essentially a node with at least an incoming edge labeled with a closing and at least an outgoing edge labeled with an opening is a node however due to the existence of edges labeled with e we need to perform a propagation of edge labels which is also based on a worklist algorithm before checking the preceding condition algorithm can ensure that for any node denoted as x with at least an incoming edge labeled with a closing and any node denoted as y with at least an outgoing edge labeled with an opening if there is a path from x to y with all edges labeled with e there must be a node along the path including x and y note that the change of edge labels in algorithm should be confined to the algorithm itself so as not to impact other parts of our analysis after identifying the nodes and calculating tal reachability we identify hidden nodes in the following way there is a conditional reachability relationship among x y i and j ie and the label is s if we know that y is a node we mark x as a type hidden node and if we know that x is a node we mark y as a type hidden node it is straightforward to identify boundary nodes the only issue for identifying boundary nodes is that we can only identify a set of potential boundary nodes when the client code is still when the client code becomes available we can refine the set to obtain real boundary nodes unnecessary reachability information as we keep only f nodes in the summary reachability information related to at least one node not being a f summary node is naturally discarded we further remove some reachability information as follows we keep all reachability relationships between two f summary nodes however for a conditional reachability relationship in the form of we keep it in the summary only if both x and y are f summary nodes i is a type boundary node or a type hidden node and j is a type boundary node or a type hidden node all the other reachability information should be discarded furthermore if there is already an reachability relationship of a certain type ie s s or s between two nodes denoted as x and y it is thus not useful to keep any conditional reachability relationships of the corresponding type ie s for s s for s and s for s in the form of for any i and j the reason is that the only aim to keep a conditional reachability relationship is that the conditional reachability relationship may become an one during analysis in fact we use cfl reachability to calculate all the reachability relationships before calculating tal reachability and when there is already an reachability relationship from x to y we prevent our algorithm from adding any conditional reachability relationship in the form of to r in the first place analyzing client code with the summary we use cfl reachability to analyze the client code specifically we use the cfl defined in definition to analyze the graph composed of the client graph the f summary nodes with the reachability relationships among them and edges each between a client node and a boundary node in the summary our algorithm extends and worklist algorithm as follows first for each reachability relationship in the summary we put it into the work list during initialization because it may trigger some productions in definition eg tk ks s and s ss second for each conditional reachability relationship in the summary we do not put it into the work list because we do not want to have new conditional reachability relationships however when we have a new reachability relationship between two summary nodes denoted as i and j we check whether this reachability relationship can turn a conditional reachability relationship into that is to say we check whether there exist two summary nodes denoted as x and y such that y soundness we demonstrate that our algorithm for contextsensitive analysis using summary is sound in theorem theorem soundness our algorithm using summary produces sound results for contextsensitive analysis in of directly proving theorem we prove that our algorithm produces exactly the same results as the algorithm using the cfl defined in definition ie theorem since the algorithm is sound our algorithm is also sound theorem equivalence our algorithm using summary produces exactly the same results for contextsensitive analysis as the algorithm using the cfl in definition proof to prove theorem we need to demonstrate that the following two properties hold for any two nodes denoted as x and y in the client graph first if our algorithm determines a reachability relationship from x to y the algorithm also determines such a reachability relationship second if the algorithm determines a reachability relationship from x to y our algorithm also determines such a reachability relationship for we consider only the reachability of exactly matched parentheses as the proof for the other two types of reachability can be naturally extended from the current proof the first property obviously holds in fact when our algorithm determines a reachability from x to y our algorithm can ensure that there is at least a path from x to y labeled with exactly matched parentheses let g be the union of the client graph and the library graph n be the union of the set of client nodes and the set of f summary nodes xn and yn we actually prove that if there is a path from x to y denoted as in g our algorithm determines a reachability relationship from x to y note that this target property is stronger than the second property we prove the target property via mathematical induction on the basis of the number denoted as p of pairs of matched parentheses in when p our target property obviously holds since there is no in can be divided into a series of pieces each of which is composed of nodes all in the library graph or nodes all in the client graph as our algorithm keeps all the reachability between boundary nodes in the library graph during summarization and our algorithm for analysis definitely determines let us assume that for any rq our target property holds when pr in the following we prove that our target property holds when pq let us denote the first opening in as op and the closing matched with op in as cp there are four situations for op does not connect two library nodes and cp is not the last closing in op does not connect two library nodes and cp is the last closing in op two library nodes and cp is not the last closing in op two library nodes and cp is the last closing in for situation let cp connect node i to node j as cp is not the last closing there is a from x to j in where the number of pairs of matched parentheses is at most q and there is a from j to y in where the number of pairs of matched parentheses is at most q since op does not connect two library nodes cp must not connect two library nodes therefore j is a client node or a boundary node in the library according to the inductive assumption our algorithm determines a reachability relationship from x to j and a reachability relationship from j to y as a result our algorithm determines a reachability relationship from x to y for situation let op connect node i to node j and cp connect node k to node l thus there is a from j to k in where the number of pairs of matched parentheses is q since op does not connect two library nodes cp must not connect two library nodes therefore j is a client node or a boundary node in the library and so is k according to the inductive assumption our algorithm determines a reachability relationship from j to k as a result our algorithm determines a reachability relationship from x to y situation is similar to situation however that cp node i to node j j may not be a f summary node let us consider the first opening denoted as op between j and y along let op connect node k to node l as j is a library node and a library node can connect to a client node only through an edge labeled with a k must be a library node and all the nodes between j and k along are library nodes thus our algorithm can identify at least one node in the from j to k note that if l is a client node there must be another library node denoted as l and an edge labeled with an opening from k to l let node u be such a node our algorithm determines a reachability relationship from x to u and a reachability relationship from u to y based on the inductive assumption situation is similar to situation but more complicated that op node i to node j and cp node k to node l any of the four nodes may not be a f summary node as there is no between x and i along the entire from x to i is in the library graph similarly the entire from l to y is in the library graph now we consider all pairs of matched library parentheses nested with the pair of op and cp along let op connecting node i to node j and cp connecting node k and node l denote the opening and the closing in the innermost pair it can be proven that there exists a node denoted as u in the from j to k along such that u is a type boundary node or a type hidden node and there is no between j and u along similarly there exists a node denoted as v in the from j to k along such that v is a type boundary node or a type hidden node and there is no between v and k along according to the inductive assumption our algorithm determines a reachability relationship from u to v furthermore our algorithm keeps a conditional reachability relationship in the form of xy to show the existence of u let us consider the first opening denoted as op in the from j to k along that op node i to node j and the matched closing of op denoted as cp node k to l if j is a client code i is thus a type boundary node and can serve as node u suppose that j is a library node then cp must not be the last in the from j to k along otherwise the pair of op and cp would nest with the pair of op and cp thus we can find a node denoted as u between l and k along such that there is no between l and u due to the existence of u i is thus a type hidden node and can serve as node u experimental evaluations in this section we consider the cost our approach in comparison with the approach as our main consideration is whether the summary can client code analysis our first experiment e focuses on the cost comparison between our approach and the approach for analyzing client code furthermore to understand how much more computation the calculation of tal reachability would our second experiment e focuses on the cost comparison between our approach and the approach for library code more details can be found in our project at implementation we implemented our algorithm in java more specifically we use hash tables to store r and r in algorithm to because reachability information in r and r is typically sparse we use several indexing facilities to access reachability in r and r when trying different productions in algorithm for r we use two hash tables to index all the reachability information in the form of x i j by x i and x j respectively for r we use six hash tables to index x i j k l by x i x j x k x l x i l and x j k respectively here we use and from the java standard library to maintain the reachability information ie r and r and the indexing information for r and r respectively furthermore we also implemented a contextsensitive analysis tool on top of version for java applications we used to build the data dependence graph of the program when building the data dependency graph we do not directly perform alias analysis but retain all the information necessary for alias analysis assignment information between object variables therefore when algorithm is applied the alias information will be computed in a flowinsensitive and but contextsensitive way together with data dependence among various code elements we chose to target java applications because java is one of the most popular programming languages and callbacks are even in java libraries due to the support of method overriding in java our tool consists of a summarization component that analyzes and generates summaries for library code and an analysis component that performs contextsensitive analysis for the client code using the generated summaries experimental all our experiments were performed on a pc with core thread intel core i cpu and ram running jvm on linux benchmarks we used java programs from as our benchmark the benchmark suite has been widely used in the program analysis research in addition we also randomly selected programs from to evaluate our approach the first columns in table the statistics of the used in our evaluation column and lists the name and size in lines of code columns to present the total number of nodes the number of f summary nodes and the number of nodes in client code for each graph note that each of our contains a java library and a client program that invokes the library in different ways we analyze all the methods in either client or note that the serial program is not included because our approach runs out of memory during summarization library code that are reachable from the main method of the client program and we compute summaries for only the main java library in the benchmark while ignoring other invoked libraries such as our statistics are based on the part of client and library code that are involved in our analysis compared techniques since the summary information for library code is we may simply compare our approach in analyzing the client code with summaries with the traditional approach in analyzing the whole code base however that is not fair because the approach can also summary information for the part of library code that does not involve any callbacks note that when using cfl reachability to summarize library code if one node is labeled as not reachable to another node the reachability is still possible during analysis due to callbacks to enable a fair comparison between our approach and the traditional approach we implemented a approach containing two components a summarization component that uses cfl reachability to summary information for the library code and an analysis component that performs analysis for the client code on the basis of the library summaries similar to the implementation of our approach we implemented the approach using and generic algorithm thus we ensure that the approach is the same with our approach except that it computes and uses summaries instead of summaries for library code to investigate the efficiency of our approach for analyzing client code ie e we compared the second component of our approach with that of the approach furthermore to measure the overhead by our summary computation ie e we compared our first component with that of the approach measurements similar to existing studies of analysis we measured both the time cost and the memory usage of our analysis results the main experimental results are shown in table columns to show the results for client code analysis e and columns to show the results for library summarization e e analysis from columns to of table we make the following observations first the time cost of our approach is much lower than that of the approach for example to analyze the client code for all the the approach needs while our approach needs only indicating a speedup of x in an extreme case our approach achieves a speedup of x for the xml subject in addition our approach the approach for all the studied in terms of time cost with at least a speedup of x the reason is that although our approach the same algorithm when analyzing client code it is able to more summaries for the library code so that more parts of the library code need not to be analyzed again second the memory consumption of the approach is also larger than that of our approach this is also expected because our approach maintains reachability information between the f summary nodes whose number is much smaller than the number of all library nodes as depicted in table in total the number of f summary nodes is only of the number of library nodes furthermore for each subject the number of f summary nodes is always less than of the number of library nodes in sum check compiler xml parser sample total size loc nodes total client analysis cfl tal table experimental results library summarization cfl tal without any precision our approach is able to the contextsensitive analysis on client code by almost a magnitude e library summarization from columns to of table we are able to make the following observations first the time cost of our approach is higher than that of the approach when library code note that our approach uses cfl reachability as a preprocessing step for the library code to summarize the library code for all our approach needs while the approach needs only indicating an average of x second the average memory consumption of our approach is mb which is also higher than that of the approach ie mb the reason for the and extra memory consumption is that our approach further computes the information for library code as well as the information as this phase is typically performed much less frequently than the analysis the average of x can be discussion factors speedup our experimental results in section demonstrate that the speedup of our approach for analysis much for different ie from x to x here we further investigate the factors that may affect the speedup the first factor is the number of callbacks the client code provides if the client does not provide any callbacks our summaries are essentially the same as the summaries intuitively the more callbacks the client provides the more possibly our approach achieves a large speedup also since the of different callbacks on the analysis are different the overall impact does not depend only on the number of callbacks the second factor is the depth of nested method calls in the library code since our approach folds up nested method calls in summarization our analysis can avoid analyzing those nested method calls again tal reachability works best when some nested method calls are callbacks the third factor is the number of long chains of conditional reachability relationships that are eventually turned into since our summarization can speed up only the determination of each conditional reachability relationship to be in such a chain the existence of many such long chains may affect our approach other applications of tal reachability although we only investigate one application of tal reachability there may be many other applications in the following categories first since many analyses can be modeled as problems tal reachability should be useful for improving versions of these analyses that is to say we can use tal reachability to calculate a more summary of library code to analysis second tal reachability may provide further help for analyzing applications in which some code in the code base is not suitable for static analysis two common cases are dynamically loaded code and dynamically generated code since dynamically loaded or generated code is typically impossible or very hard to analyze to ensure the quality eg reliability and security of the whole program dynamic and checkers are often enforced at run time similar to library code it may be to acquire more analysis results of the static code with tal reachability so as to reduce the overhead of runtime enforcement third tal reachability may be a useful tool for analyzing partial code in other words we can use tal reachability to acquire useful properties of part of a code base regardless of the missing code eg client code dynamically loaded code and dynamically generated code for example the conditional reachability information calculated by our algorithm can be easily extended to acquire the dependence between any two nodes in the library graph regardless of the client code definite dependence possible dependence and impossible dependence this dependence information can then be used for compiling and verifying the library fourth tal reachability may also be useful for analyzing software systems modern software systems usually various when the developers are changing some code files they can run analysis for the unchanged files including libraries at the then when the developers finish the they can directly use the information for unchanged files to speedup program analysis for verifying the changed files considering field sensitivity in program analysis field sensitivity is another important factor that the precision of analysis our approach performs flowinsensitive and data dependency analysis and uses a simple heap abstraction that does not consider type structures the rich heap abstractions that enable can also be represented with cfl reachability however unfortunately analysis considering both kinds of is undecidable one typical solution is to use a regular language to approximate one cfl and keep the other cfl for example we can the cfl for field sensitivity denoted as and keep the cfl for context sensitivity denoted as cf lc then analysis considering both kinds of sensitivity can be approximated as a problem using cf lc this paradigm can be extended to other constraints that can be represented as cfl reachability eg synchronization sensitivity of course the generic algorithm by and reps would typically not scale to large programs when using cf lc to extend our approach for field sensitivity we can use a similar strategy the cfl for field sensitivity to it with our tal in definition denoted as t note that our algorithm essentially provides a way to calculate the intersection of a regular language and a language as a regular language can be represented as paths in a graph similar to and generic algorithm for cfl reachability our generic algorithm for tal reachability may also have scalability issues for large programs when using t one possible solution is to extend and annotated set constraints to tal reachability related work cfl reachability based on the framework of cfl reachability proposed by researchers used cfl reachability for various problems such as interprocedural slicing interprocedural dataflow analysis shape analysis constant propagation and pointer analysis researchers also investigated demanddriven algorithms for solving problems reps provided an early survey of program analysis based on cfl reachability and used cfl reachability to achieve an on algorithm for typebased flow analysis with polymorphic subtyping which improves a previous on algorithm et al used cfl reachability for analysis and race detection and used cfl reachability for demanddriven alias analysis which directly computes aliasing information without pointsto information provided the first algorithm for cfl reachability some analyses require the consideration of satisfying multiple cfl reachability properties however it is undecidable considering two or more cfl reachability properties simultaneously therefore it is needed to keep one cfl reachability property and approximate all the other cfl reachability properties as regular reachability properties in this paper we propose tal reachability via extending cfl reachability tal reachability allows us to calculate more and compact summaries than cfl reachability for library code contextsensitive grammars as mentioned previously researchers investigated four for defining contextsensitive grammars grammars head grammars linear indexed grammars and combinatory grammars according to these four are actually four sets of different notations for defining the same family of contextsensitive languages ie the tal family which are in on time where n is the length of the sentence for parsing in this paper we provide a concise formalism which is the normal form for defining the tal family compared with the four existing our formalism is more suitable for defining tal reachability which has not been investigated previously there are also another two less investigated ie linear contextfree rewriting systems and grammars for defining a larger language family than the tal family staged program analysis analysis belongs to a notion of staged program analysis where multiple passes of program analysis with each other to achieve the purpose we are aware of two research efforts on program analysis that try to build summaries for library code with callbacks specifically et al heap to achieve contextsensitive stages analysis however their approach when recursion exists while our approach achieves full with et al provide a general framework to deal with callbacks due to its generality it identifies abstract domain parts affected by callbacks and left these parts for analyses when client code is available while our approach is able to generate partial summaries for these parts with conditional reachability and the partial summaries are validated to be effective in our experiments our conditional reachability is relevant to conditional dependencies which were defined and studied by and in another scenario but the conditions in conditional dependencies refer to existing branch predicates while the conditions in conditional reachability in our paper refer to the unknown client code furthermore cfl reachability naturally provides a basis of library code et al proposed a flowsensitive analysis for verifying program memory safety properties in which strong updates are considered in summary building however their analysis does not consider callbacks researchers have also considered library code to speed up dataflow analysis however their approach is based on the functional approach proposed by and pnueli and is not solvable in polynomialtime of the program size in addition their approach simply folds intraprocedural nodes or invocation nodes which invoke only library functions no callbacks our analysis can also be applied the graph produced by their approach to make dataflow analysis even faster since our approach can reduce the analysis cost globally eg our algorithm can also fold invocation nodes that can invoke client code dealing with callbacks for demanddriven interprocedural analysis the main of topdown approaches lies in repeated analysis and the main of bottomup approaches lies in analyzing information unnecessary for the demand our approach is essentially a bottomup approach however since we target analyzing reachability relationships between all pairs of nodes not specific pairs of nodes we do not need to avoid analysis unnecessary for any specific demand thus it is natural to use bottomup approach here unlike program analysis where library code is distinguished from client code other staged analyses use different passes on the same code base and aiken proposed a analysis where conditional information is calculated to ensure sound race detection xu et al proposed a pointsto analysis which uses conditional information to calculation et al proposed to use static information ie residual policies calculated in the first pass to reduce the runtime overhead for analyzing dynamically generated code in javascript conclusion and future work in this paper we propose a novel framework for program analysis called tal reachability based on this framework we further propose a novel technique to summarize library code with callbacks for contextsensitive analysis since our technique conditional reachability we have more summary information without further approximation we further evaluated our approach on a set of java benchmark programs and our experimental results demonstrate that compared with a similar approach our approach is able to achieve a speedup of over x for analysis on average the largest speedup even reaches over x our approach naturally some for summarization however our experimental results demonstrate that the is typically acceptable since tal reachability provides a new framework for static program analysis we believe that there will be a lot of future work on top of tal reachability in the future we plan to investigate the following issues first although our current research focuses on analysis tal reachability is applicable to various other problems we plan to investigate these problems eg pointsto analysis using tal reachability second our current algorithm for tal reachability is a generic algorithm it does not consider the special characteristics of the graph we plan to investigate faster algorithms especially for specific problems third our current research considers only context sensitivity in our analysis we plan to further consider field sensitivity in our analysis where a major issue is to scale the contextsensitive summarization using tal reachability fourth when analyzing libraries it is possible that library l invokes another library l whose summaries has been computed we plan to handle this such cases by the summaries of l for analysis of the client library l the authors from university are by the national program of no cb the national program of no the science for research groups of no and the national science foundation of no and references benchmark suite jvm s a and r s software change impact analysis ieee computer society press s algorithms for recursive state machines in proc popl pages  l chen j y p wang and b xu identifying extract class opportunities for science information sciences  r j a r jhala and s staged information flow for javascript in proc pldi pages  i t a aiken and m sagiv precise and compact modular procedure summaries for heap manipulating programs in proc pldi pages  g applicability of indexed grammars to natural languages in u and c editors natural language parsing and theories pages  s horwitz t reps and m sagiv demand interprocedural dataflow analysis in proc pages  s n t w reps m sagiv and a v shape analysis in proc cav pages  a k l s and m tree grammars journal of computer and system sciences  j and a aiken the set reachability connection in practice in proc pldi pages  j and a aiken annotated set constraints in proc pldi pages  r and g data models via guarded dependences in proc pages  d j r h d a b and m dependence graphs and compiler optimizations in proc popl pages  c a and v making contextsensitive pointsto analysis with heap practical for the real world in proc pldi pages  a and c extending grammars a logical account of grammars in proc acl pages  s n r n and m sagiv program dependence analysis in proc pages  r g and k modular heap analysis for higherorder programs in proc sas pages  d and t reps of a class of set constraints and reachability  m and a aiken conditional must not aliasing for static race detection in proc popl pages  m pnueli two approaches to interprocedural data flow analysis program flow analysis theory and applications pages  c phrase structure grammars head grammars and natural language phd thesis stanford university p j s foster and m existential label flow inference via cfl reachability in proc sas pages  p j s foster and m w contextsensitive analysis for race detection in proc pldi pages  g contextsensitive analysis is undecidable toplas  j and m typebased flow analysis from polymorphic subtyping to in proc popl pages  t reps shape analysis as a generalized path problem in proc pages  t reps program analysis via graph reachability information and software technology  t reps undecidability of contextsensitive analysis toplas  t reps s horwitz m sagiv and g up slicing in proc pages  t reps s horwitz and m sagiv precise interprocedural dataflow analysis via graph reachability in proc popl pages  n a g m sagiv and e modular shape analysis for dynamically programs in proc esop pages  a s and t interprocedural dataflow analysis in the presence of large libraries in proc cc pages  springer m sagiv t reps and s horwitz precise interprocedural dataflow analysis with applications to constant propagation  y and k deterministic left to right parsing of tree languages in proc acl pages  m and r contextsensitive pointsto analysis for java in proc pldi pages  m d l and r demanddriven pointsto analysis for java in proc oopsla pages  m combinators and grammars in r e and d editors grammars and natural language structures pages  c sun n xi s z chen and j ma automated enforcement for relaxed information release with reference points science information sciences  k and d j the equivalence of four extensions of contextfree grammars mathematical systems theory  d characterizing contextsensitive grammar phd thesis university of pennsylvania t l x yf and d software testing and analysis advances and challenges  g xu and a merging equivalent contexts for scalable contextsensitive pointsto analysis in proc pages  g xu a and m scaling pointsto analysis using contextsensitive analysis in proc ecoop pages  m methods in database theory in proc pages  x r m and h yang hybrid topdown and bottomup interprocedural analysis in proc pldi pages  x and r demanddriven alias analysis for c in proc popl pages  appendix theorem our formalism presented in section defines the same language family that tags define in the following we first present the formalism of head grammars which is equivalent to the formalism of tags then we prove that our formalism is equivalent to the formalism of head grammars thus proving theorem definition head grammars a head grammar is a four tuple g n t s p where n is a finite set of nonterminals t is a finite set of terminals s n is the start symbol and p is a finite set of productions of the form a f n where a n n f w cn cn n n t  t and n when f w and w are defined as follows  t  t n t  t is a concatenation operation where v ui vi un vn  w t  t t  t is the operation where w u v u v uu vv the language defined by is  t s  nonterminals in a head grammar are actually equivalent to secondorder nonterminals in our formalism and there is an implicit operation on the start symbol to form a string in the language defined by the head grammar we transform theorem into the following two lemmas lemma backward subsumption the language family defined by our formalism can be defined by the head grammars lemma forward subsumption the language family defined by the head grammars can be defined by our formalism proof lemma we show that all the production rules in our formalism can be expressed by the rules in head grammars operator for any two string pairs a and b in the form and a b this can be exactly expressed by the w operator in head grammars since w extended concatenation operators for a string pair in the form of and a string in the form of all the four extended concatenation operators can be expressed using the w or operator in head grammars note that the operator in head grammars is equivalent to our operator  this can be expressed by c which will produce and finally  this can be expressed by w which will produce and finally  this can be expressed by w which will produce and finally  this can be expressed by c which will produce and finally concatenation operator although the formalism of head grammars contains only our secondorder nonterminals it can simulate the traditional concatenation operator as follows we can use a nonterminal in head grammars representing to simulate a nonterminal in cfgs ie a firstorder nonterminal in our formalism then the w operator serves as the traditional concatenation operator for two such nonterminals pairing operator let a and b be simulated by and respectively we can simulate a b as c operator in head grammars there is actually an implicit operator on the start symbol our formalism allows a firstorder nonterminal from a secondorder nonterminal to with other secondorder nonterminals the operator can simulate this situation for example can be expressed by c since it will produce note that we can use the operator together with and the w operator to manipulate the concatenation position for example w c results in therefore all the production rules in our formalism can be expressed by the formalism of head grammars proof lemma we further show that all the production rules in head grammars can be expressed by our formalism w operator as shown above the w operator in head grammars is equivalent to our operator thus can be expressed by our formalism operator we apply mathematical induction on n n and i can be arbitrary integer within the range n  case n i can only be i cu v u v this is the identity production rule and is trivially supported by our formalism  case n i can be or i cu v u v u this can be expressed by our formalism as u v u v i cu v u v v this can be expressed by our formalism as u v u v  now we assume can be expressed by our formalism when n k k for any i k then for n k and i i i k ci v ui vi uk vk vi cu v ci v ui vi uk vk according to case c can be expressed by our formalism in is less than or equal to k then according to our inductive assumption ci k can also be expressed by our formalism thus can be expressed by our formalism based on mathematical induction i n can be expressed by our formalism 
an efficient for lll parsers c n fischer d r s b computer sciences department university of wi abstract an lll based which operates by is studied the is able to correct and parse any input string it is efficient linear in space and time requirements and chooses as defined by the user in syntax errors moreover the can be generated automatically from the grammar and a table of terminal symbol insertion costs the class of lll grammars by this method contains with minor modifications grammars used to specify most common programming languages preliminary results suggest that this method can be used to advantage in lll driven compilers introduction the problem of and from syntax errors in contextfree parsing has received much attention known tions however usually contain some rather some are essentially adhoc requiring the use of hand coded recovery routines others when with certain syntax errors are forced to skip completely ignoring portions of the input some methods must be considered in that they have nonlinear space or time bounds yet others when with a choice of possible make an arbitrary and all too often choice we consider an lll based which these difficulties this method limits its attention to lll grammars that is those lll grammars for which it is always possible to effect an error correction by a suitable insertion of a terminal string this class of grammars is a large and interesting one example grammars which with slight modification can specify the syntax of such programming languages as algol and pascal in an compiler this insert only is because correct programs can always be built around the programs submitted by a user the error considered has many de properties it requires at most linear time and space it produces a syntactically correct program from any input string it can be automatically generated from an lll grammar and a supplied vector of terminal symbol insertion costs when choosing a string to be inserted to correct an error it always chooses a locally optimal string as defined by the cost vector this allows the choice of to be by merely the cost vector the lll the algorithm we present is an insertion only error for lll parsers since we may need to consider at the end of an input string it is necessary to use an augmented grammar let g then the augmented grammar g vn u u p u s ss where all strings will be terminated by the symbol we shall consider all grammars to be augmented and denote vt u by t vn u s by on given as input a string xa such that s x but s xa the correction algo rithm will find a such that s in order for this algorithm to succeed we need two restrictions one on the class of lan guages considered another on the parsing algorithm used it is clear that not all lll languages will be to an consider the lll grammar g s s for input a there is no insertion such that ay we define a class of grammars for which error correction is always possible a cfg is said to be iff for all and a such that s x and s p xa there ex such that s in the next section we will show that it is able whether an lll cfg is for real programming languages does not appear to be a serious constraint for example in order to transform algol into an language it is only necessary to allow a program to be a sequence of blocks rather than just a single block the lll parsing algorithm must also be con it is wellknown that every lll gram mar is strong and the conventional parsing algorithm for lll languages takes advantage of this fact however even for lll grammars this algorithm will not necessarily detect an error upon first the symbol consider the following in lll grammar g s e e and try to parse a the parsing stack sequence s km e lm e lm the last transition occurs because c follow at this point the parser error but it is too is no useful information left on the parsing stack to guide a correction al we thus require a parsing algorithm which will never make a transition on an input symbol thus detecting the error when that symbol is first encountered the algorithm which is usually used for parsing languages for k suffices this involves con tables which identify the exact lookahead set these tables are in effect then used as nonterminals in the parsing algorithm and an error is detected whenever an erroneous symbol appears as the lookahead an table can be represented as a pair ay where and y is a local follow set how ever the ignores the local fol low sets so for our purposes the parsing stack will be written as xn x where u tt the algorithm requires two auxiliary tables s and e these tables rely on an function c cc is defined to be o for act ca is supplied as an a priori value and for w x cw u vt sx y where xy and for all ze such that x z cy s cz in other words sx a terminal string derivable from x the function c can now be ex to no ca for and act if a a otherwise pi where p ax x xn and x a in addition i has a property let w be a terminal string such that xi wa then for all qj ay and yj za have w z where we that is with a on top of the parsing stack and a the erroneous input symbol will an expansion that will lead to a least cost insertion the algorithms which compute the s and e tables operate by iteration over the grammar until the costs converge to a minimum they are discussed ain detail in the appendix given u vt and act such that a a the following recursive procedure will compute the such that it will do this by performing a sequence of into the string being parsed will insert the terminal string w immediately to the left of the sym a currently as being in error and to the right of any previous algorithm procedure then return else begin comment let p pi where ax x sx end i a n we are now ready to give the let the parsing stack be and let the erroneous input symbol be a the parser will detect the error when it finds tile parsing table entry error it will flag a as being in error and will call the following procedure algorithm procedure for i n step until then return then else ex a begin a return end the procedure down the stack until it finds tne first stack symbol can derive the error symbol while inserting for all other stack symbols when an xi is found such that xi a if xi a the prefix procedure is called to compute the re required the parser is then reading the leftmost inserted symbol properties of the we now consider the properties of the parser introduced above the most important property is input string with proper can be and parsed further when an insertion is required it is locally sense l in the fol theorem assume that for some lll grammar g x lg but xa lg for xv at further assume that while to parse xa algorithm is invoked with on the parse stack where ij vt and a y a y must exist since g is insert then algorithm will find and insert a string such that w y and yz ya furthermore there is no t such that w z and y za where proof the lll parser fails as soon as sym encountered since g is insert we know that for some symbol y on the parse stack y a algorithm in turn each symbol on the parse stack if a symbol cannot derive a it in the lowest cost string derivable from it if a symbol y can derive a it inserts the lowest cost prefix such y us the net result is to insert the lowest cost string which will allow a to be accepted by the parser qed corollary let x be any input string where then an lll parser using al as an will parse and accept x we thus have a very robust tor which can build a correct string out of any input also since all are lo optimal we can use the cost vector to the choice of possible as the next theorem demonstrates go rithm is efficient and compact theorem assume an lll parser using al as an processes x then it requires a at most time and b at most space proof a we can establish two important observations each step of algorithm can be to some stack symbol and each stack symbol is an amount of time bounded by a constant dependent solely on the grammar ii each input symbol causes a number of symbols bounded by a constant to be added to the parse stack note that i and ii yield the desired result immediately and hold for normal lll parsing during error correction observation i follows from tne fact that each stack symbol considered either generates a derivation string or a prefix string of the error symbol in either case the string is bounded so it takes a bounded amount of time to do the insertion and later parse it during error correction observation ii follows from the fact that those stack entries which derive strings are effectively deleted further that stack symbol y which can derive a the error symbol is in effect replaced by u t where y m and u is the prefix to be inserted since w is determined solely by y and a its size can be bounded by a constant b trivial qe d we now consider the problem of deciding whether an lll grammar is to do this we characterize the situation in which tne is invoked assume we are just about to match some valid input symbol a with the top stack symbol the stack is of form for no and l u vt we pop a and consider tile next input symbol b which is in error the error will succeed if and only l xn can generate b to decide whether can be guaranteed we must characterize the possible sequences of stack symbols we observe that a leftmost der of a string y in a cfg exactly to a rightmost derivation in a cfg rev is g with g corresponds of y rev all right hand sides we can then easily that x can occur on the parse stack of an lll parser if and only if can be read by the characteristic which corresponds finite state to g is then not iff the for can read a sequence xl for which x b for some since the is deterministic we can associate a path with each input sequence we need only consider paths if b cant be generated by a path with cycles it certainly cant be generated by that path with the cycles removed and paths for which otherwise terminate the path we then obtain l at the first theorem an lll grammar g is insert iff the corresponding to has the property that for all bt and for all paths of the form a x no x starting at the start state x xn b usually it will the entire se e et e not be necessary to generate consider the has the form all paths ending in a terminal begin with e and since e b for all g is will implementation and conclusion the described above has been successfully implemented and tested on an lll grammar for a language similar to algol w the algorithms to compute the s and e tables detailed in the appendix proved to be fast requiring less than seconds on a for a grammar with nonterminals terminals and tions although the is large it can be stored efficiently in since for each it is only necessary to access a single column of the table this fact coupled with the results of the previous section indicate that the and space of tile lll parser are not when the is added the only significant loss of efficiency in space is a result of requiring all lll parser rather a parser for the above grammar this tile size of the parsing table resulting in about non zero entries however this still compares with the size of tables for similar grammars employed by many bottomup parsers the following short and program provides examples of the kinds of by algorithm the symbol insertion costs have all been fixed at con improvement could be expected through of the cost vector that are made just of symbol as being in error i j t t real array a if i a goto l i i integer while k do the program begin ­ i j real array a id if i a id then gc l i begin integer procedure id for ib id k there is an interesting variation of algorithm which will in general lower cost as it is the algorithm searches down the parse stack for the first symbol which derives the error symbol it is possible to allow it to search further down the stack replacing all passed symbols x with sx a number of insertion strings may then be computed each a result of allowing a different stack symbol to be the root of a derivation of the error symbol and the least cost string is chosen in the above example procedure id for id id is inserted be and while because the top stack symbol is tile remainder of a type declaration and a tion is capable of deriving a while the and better insertion string id for id id is obtained with the searching down the parse stack reveals the next symbol is also capable of generating a while and by replacing the rest of the id the lower cost insertion is found although we will not analyze it here the stack is bounded if we that there is always a positive cost for replacing a stack symbol by its derived string thus the modified algorithm will still operate in linear time and space it be that the we present is not restricted in to grammars if the is not the algo rithm will always find a insertion if there is one and could otherwise be to failure the algorithm can also be modified to allow simply cost vector to make certain tions very expensive while adding a procedure to evaluate the cost of algorithm can thus be used as the basis of a large family of lll appendix the following algorithm computes table of strings sa where it simultaneously computes ca over the grammar until the costs converge to a minimum algorithm a for all co true for all p do cx xn ca false end until the iteration of the repeat loop of algorithm a those strings having a derivation tree of height i every an has a derivation tree of height trees of greater height must contain a derivation sequence b which can be col thus at most iterations of the repeat loop are needed the inner for loop will execute in time proportional to the size of the g is considered to be the number of productions plus the sum of the lengths of all the righthand sides the execution of algorithm a is thus bounded by to facilitate the computation of the and to accommodate insertion algo rithm discussed in section we extend the entries to include a cost thus if a a then where p x x xn w and c w if a a then e define c where for if ab o otherwise the following algorithm is very similar in struc ture to algorithm al algorithm a comment initialize for all for all comment the main loop repeat true for all ad do for all begin do k min lin j be such that k cx xj if k a end until false end the number of iterations of the repeat loop is again bounded by n for essentially the same reason as noted above while the nested for loop iterations are bounded by ltl and g respectively thus the execution time of algorithm can be bounded by in practice this algorithm can be improved substantially each time an entry is changed it is placed on a stack the stack is initialized with entries obtained from all derivations the main loop then operates by an entry all other entries whose costs are through application of the entry this determination is by a table linking all nonterminals to their tions in all righthand sides the loop is terminated when the stack is empty references aho a v and t g a minimum distance parser for context free languages siam journal of computing aho a v and unman j d the theory of parsing translation and vol section n j r w and t r design and implementation of a compiler for pl cacm f l practical for lrk languages phd thesis mit c lll grammars supporting an efficient error handling information processing letters graham s l and s p practical syntactic error recovery cacm d the use of transition matrices in compiling cacm d compiler construction for computers new york e t an parse algo rithm cacm q james l r a syntax directed error recovery method ms thesis univ of computer systems research group tech rep may j e syntax directed error re for compilers phd thesis univ of illinois comp sci dept iv r p error detection and recovery for syntax directed compiler systems phd thesis comp sci dept univ of j p automatic correction of syntax errors in programming languages phd thesis cornell univ comp sci dept tech rep tr lewis p m d j and r e compiler design theory addisonwesley reading mass g syntaxdirected analysis for contextfree languages a practical approach cacm t g syntax error detection correction and recovery in parsers phd thesis inst of tech s p practical syntactic error recovery for programming languages phd thesis univ of california dept sci tech rep r contextfree error by evaluation of algebraic power series proc acm fifth annual conf on theory of computing austin texas 
processes and proofs of theorems and programs richard a institute of technology richard j and alan yale university j i should like to ask the same question that you are to give a precise definition of logical correctness which is to be the same as my intuitive for logical correctness how do you intend to show that they are the same r should is the the not final average that his intuition authority j it is exactly those processes which proofs of theorems in mathematics that require that program verification as by a large segment of the computer science community is bound to fail in its primary purpose to increase ones in the correct of a particular piece of software this is a view that we have found to be to many but the key to our position on a relatively simple observation a large measure of credit for the success and growth of mathematics belongs to the mechanism of proving theorems in proving many of the ideas reported in this paper were out of discussions held at the conference on software technology july in nc we in particular the help of jr who organized this and has been of in our work this work was supported in part by the us research grant no authors and by nsf grant no addresses r school of in formation and computer science institute of technology ga r a department of computer science yale new ct logic for programs however these mechanisms are almost totally it has been extensively argued that the art and science of programming should to become more like mathematics in this paper we argue that this point of view is correct but that the reasons usually given for it are wrong in the first part of the paper we present our view that mathematics is rather than a formal process an process and that the view of mathematics is and destructive for proving software in the second part of this paper we interpret these arguments as positive suggestions for producing reliable software and better programming tools and we conclude that there is every reason to believe that there are mechanisms that can make program tion more like real mathematics we have used proving in two different in a previous the sense of proof refers to the common notion of informal proof used in mathematics the sense proof of proof refers to the formal that appears in the literature notion of on program verification by a shall mean the sort of valid syntactically deduction as may be carried out within a consistent formal logical calculus such as set theory or arithmetic we have been to proofs with proofs let us call this viewpoint monolithic the monolithic view is the one of school of logic proceeds from axioms or or hypotheses to theorems by steps each of which is easily from its predecessors by a fixed rule of transformation we will begin by that the views of the school can be very and that mathematics is and must be highly theorems indeed every knows that a proof has not been understood has done nothing more than verify if one step by step the correctness of the of which it is composed and has not tried to gain a clear insight into the ideas which have led to the construction of this particular chain of in preference to every other one n t that every year over theorems are published by a fair number of these are subsequently or for other reasons others are into most are ignored but a fraction come to be by a portion of the mathematical community theorems that get published are the work of and those that are are not always the work of in published a proof of the conjecture which for years before a in the reasoning was by this proof by the way has since been by many wellknown who to their that they had at last solved this problem the published a page proof an important problem in group theory unfortunately the proof contains a so subtle that it can only be detected by a very careful analysis of an induction involving many lemmas together i mathematical is filled with of sometimes less than whose best efforts were for instance to address a mathematical con only to return his notes to his and that the matter would the architecture authors are for this observation of mathematics to math y require further thought just increasing the number of working on a given problem does not necessarily proofs recently two other groups of one results the concerning the same group a type of object arising in theory a branch of topology the results turned out to be and since both proofs were very complex and involved detailed was not symbolic and numerical at all evident calculation but it the were sufficiently high to press the issue so the and proofs were changed obviously each group was highly to discover an error in the others proof but neither the nor the proof could be yet one was clearly subsequently a third group of researchers obtained yet another proof this time supporting the result in of the the weight of evidence now being against their proof the to the issue notice that the truth of the theorem at this point is still very low compared to the far more results we tend to regard as one of the was so by this experience that he has since given up mathematics for a in which the results of his can be more a recent issue of science contains a that the secure notion of mathematical truth may be due for the central issue here is not how proofs get but rather what it is that is when one asserts his of a particular theorem there are two relevant views that may be probabilistic classified as classical and the view when one a mathematical principle statement a one there is a correct formal that in of a in a suitable logical theory that semantically completely truth a formalizes is true the if it says of what notion of is that it is and it says of which is not that it is not two points special attention here first the classical view requires that we of mathematical objects in a strictly fashion a theorem either or fails to a property to an object secondly the classical view does not require that every informal proof be by its formal counterpart in fact the classical view does not even require that it be possible to produce such a proof there is a sound reason for allowing the to formalize some of our arguments for even the most trivial mathematical theories there are simple statements whose finite proofs are long lecture on the history of such research concludes with a physical interpretation of how hard it may be to prove simple mathematical state ments suppose that we encode logical formulas as binary strings and set out to build a computer that will decide the truth of a simple set of formulas of length most bits then even allowing ourselves the of a that will produce electronic components connecting them with infinitely the computer we design must fill the entire observations observable concerning universe lengths these precise of proofs with our about the amount detail embedded in proofs for example of we often use let us assume generality without loss of and therefore necessary by if to replace amounts of formal detail tw since long proofs in the classical view can only be viewed as probably correct it is perhaps reasonable to give probabilistic of mathematical statements the reasoning is that a valid proof may have the dual of being technically easier than a classical one and may allow to those critical ideas that give rise to uncertainty in classical this process leads to a more valid proof an illustration of this notion is michael algorithm for testing for very large integers n all of the classical techniques for determining whether or not n is composite fail because of computational time is required for the test than is left in the lifetime of the insight was that it is possible to guarantee that any such n is prime or not with small ty of error within a reasonable amount of time in view of these difficulties how is it that mathematics has and has been so as a description of nature obviously theorems get by and most of these is it possible that this process is at an end and that mathematics in its classical form will not almost certainly not the mechanisms that cause theorems to be and understood operate well in large of let us sketch some of these mechanisms first proofs are widely read an author writes a proof down on paper and reads it for errors in the common case that several on the same proof it is usually read by them all by their and by many others this leads to a second mechanism proofs are published and this is a triple filter a must be before publication a large must be in a article finally after some of the has a tion such as takes a more look at the proof third talk to each other they give symposium and colloquium which attempt to sometimes of their arguments they into each others with of insights for current research and they on in university and expensive all for the sake of other they key is that other are what happens to to a proof when it is the most transformation is probably an of the proof leads usually to alternative proofs and several versions of the same theorem an source of examples of the transformations that can take place by this process is the little by paul and the combinatorial discussed in are usually presented in a variety of each of which the intuition in a slightly different way after enough and alternative proof construction the community seems to decide that the central concepts have an if the various proofs begin to feel right and the con are examined from enough the cal truth of the theorem becomes established the next activity that sometimes takes place is that the theorem is generalized in some way if in the to the generalization the mechanisms lead to the of the generalized proof then the truth of the original finally statement important is considered theorems are established used they may appear as lemmas in larger proofs if they do not lead to then the in the supporting lemmas of a larger proof is increased theorems can be used in other ways for example use theorems by in values and relying on a particular physical interpretation of the conclusion that and that stand are evidence of in theorems theorems sometimes make with other areas of ones the successful of information between distinct branches of also increases in theorems the most example of this sort of transfer is proof of the prime number theorem this proof uses connections established by and between theorems in complex analysis and certain asymptotic properties prime numbers a more recent of the example sequence of the of same is the of the notion of into mathematical logic paul original proof of the independence of the axiom of choice and the generalized hypothesis from the remaining axioms of set theory was so that it was ie understood by very few scott robert and j central notion of giving it an alternative algebraic tion and others forcing arguments with more familiar ideas in logic generalized the concept and found the generalization to be useful when his results to the national of sciences in very few his proofs by forcing arguments are studied by in logic and are used as standard tools in certain areas of logic half of the papers examined in random selection from the journal of symbolic logic make essential use of forcing let us summarize the main argument of this section working usually do not believe proofs because they believe that they can translate them to a formalized logical theory to act as the arbiter rather theorems get because they are read published and discussed and generalized used and connected with other theorems the role of simplicity we that very few theorems are subject to of the filters through listed above indeed the degree to which a theorem is is largely by its importance and this seems to be highly with its simplicity of statement as a general rule the most important mathematical problems are clean and simple to state an important theorem is much more likely to take the form every is a rather than the form theorem if ­ and except i and and ­ for and xx then unless i iv every that s or satisfies is a the problems that have most since have been simple to state probably use simplicity as a first guage of a problems importance so that the decision to consider a proof in de tail is often by some slightly tional is for does the problem feel this mathematics held that the of a scientific theory could be by how well it could be on the a similar criterion to the applies to mathematical theories of course a judgement of simplicity must be by the underlying theory the four color conjecture on such foundations that it can be stated with complete precision to a child the hypothesis about location of the of the complex m function cs z n which may not be clear to a but certainly requires only the most tion to mathematics the deeper independence questions of set theory are similarly basic can for example the existence be proved from the of certain large remaining axioms of set theory even though it requires some effort to be precise in stating such a problem informal statements serve the intuition a simple statement of category theory the very well may look very complicated as a formal statement in axiomatic set theory but we are generally to allow for this sort of because of the processes category have the fundamental concepts of their field in ways which are to say set but the important concepts are simple in their domains the point again is that simple that are easy to state and in a specific far more likely to be read published and used than narrow theorems that apply to such a class of structures that no will ever again consider the class yet it is exactly this kind of theorem that arises in pro gram proving for real programs deal with real human activity and are thus detailed and imposed the and which upon them by their human designers are real programs and the are not theorems simple in the sense that arise in trying we mean here to prove real programs are not simple software the complete program program itself description will do is the only of what the p j the mechanisms that save proofs of theorems are the ones that proofs of software let us concentrate on program tion by the method of inductive assertions the kinds of specifications that usually software tend to be long and complex that is the verification conditions that result from common assertions these are the theorems to be satisfy the simplicity criteria outlined above in the area of program correctness counter this ment by that the long complex theorems to be are deep that they are in fact usually nothing more than extremely long chains of substitutions to be checked with the aid of simple algebraic identities one group we know of has taken this concept to its extreme by that verification conditions be proved by of these are to be of mathematical who the verification conditions besides the the concept is exactly why verification what must program fail provers have failed to is that the proofs will be not because the theorems that are being proved are deep but rather because the mechanisms that we have discussed here simply will not apply to the kinds of theorems that they are proving the theorems are neither the proofs of even very simple nor basic and simple programs run into of pages thus the for one really in mathematical two is one and math a community to and the proof of an individual piece of software is no longer present simply will not be read discussed in or over generalized or used they are too specialized for any of those activities the fact is that the kind of mathematics that goes on in proofs correctness is not very good of there are of course algorithms that do get proved but these tend to be algorithms like find f which while generally useful have nothing to do with kind of program that is written for specialized uses and which must operate in a production programming ment the fast pattern matching algorithm of knuth morris and pratt and by morris was first implemented as part of text editing system subsequently a system programmer who did not understand the new algo rithm it from the text editor and replaced it with a much slower pattern matching routine the system programmer the new algorithm the point is simple the kinds of algorithms that get proved correct have nothing to do with software give a choice between a very good algorithm with a proof of correctness but which may be hard to understand and a straightforward algorithm which an he the algorithm and it is the complex algorithms that are most interesting and have the most of being to the of proof there have been several apparent trap left in our argument thus far we will now them off what about proof systems well totally automated systems are out of the question for a variety of reasons in the first place the lower bounds on the length of computer proofs for mathematical theories a very picture of automated proof secondly researchers in the area do not even take the possibility of totally proof london characterizes the program verification system as one that can be left in an mode to out the a program even if an could be built and london that such a system can be built to work with reasonable reliability imagine the reaction of a programmer who inserts his line inputoutput package and returns several later to find the message verified followed by a line proof we seem to be left with some kind of machine system that uses machine checks proofs this type of system of course on complex does not help at all the human prover still makes takes that will never be to the processes of proof another apparent way out is to use very high level languages to raise the content of the theorems being proven the strategy here is to use the fact that very high level languages can deal directly with a range of objects to that the complex theorems resulting in a set of verification conditions will be interesting and therefore subject to the processes we have been discussing the situation in proofs of very high level programs is not much changed over their counterparts for example the following verification condition arises in the a fast algorithm written in a very high level language similar to setl theorem if n is a power of f is a complex vector and r is an integer and if s e and b and c j then i bj ln ar a r r mod n b and o rn ii j j and o j n iii then xx r r and o r r n fa b ­ fa i k cr lr kl b ir r n xk and r j jr r n at some level the transition between specification this follows and program must by two be left observations first the data sets on which programs operate are in general complex objects in computing the for the national for example we find that each has more than pay for instance the time his was versus hill similarly the input assertions for many numerical algorithms are not even certainly they cannot be formalized the second observation seems to us to be the most however the purpose of a program is an informal often criterion and the from informal to formal objects must forever be we be in the of assuming the formalization of an object we know only informally constructing software one of the of the in as an to is to them from too much of mathematics n we can combine the arguments of previous tions with the intuition from a or so of experience in dealing with mathematics in a symbolic way since symbols can be written and moved about with of energy it is to to the conclusion that anything is possible in the symbolic this is the of theory viz solvable ble problems and also the of complexity theory viz solvable problems vs solvable problems does not break down at this level of human activity it is no more possible to construct tures without to construct using material energy than structures it is possible for free but if symbols and material objects are to be in this way then we should perhaps pay special attention to the way material are since we might expect that in i am a q mit press the later life of a principle the same limitations apply before we return to our of relating proofs to able software let us briefly to consider the role of engineering principles it appears to us that the engineering pro have been at the for the creation of reliable structures with two human human cannot create perfect mechanisms human tend to into activities before they are understood surprisingly this is accomplished by of the same mechanisms we have been disciplines first reliable in engineering never means perfect in the monolithic classical notion of there are simply no proofs or proofs that stand that or that power systems rather set limits of failure relying on other design criteria to place these limits well above the likely to be encountered in practice it is perhaps symbol which suggests to computer that a our structures are so much more important than material structures that they should be perfect b our available energy is in practice sufficient to grams as perfect we now see connections with mathematics the probabilistic view of mathematical truth is closely to the engineering notion of reliable structure this suggests that we should make more serious attempts to treat software reliability in a setting distinct from program proving since both merely establish expected limits of second tend to the human to try designs by the amount and kind of in designs this suggests that tend to designs and to thus subject them to some of the same processes as are present in mathematics is the situation as as we suggest there are almost certainly mechanisms which make software more like mathematics in the ie which software to the level at which the processes described above operate many of these mechanisms are just applications of engineering design principles eg reliability within limits channel into constructive paths by previously successful designs while many are straightforward extensions of our on what causes mathematics to be in the main successful the to prove programs correct is constructive and valuable the monolithic view of proof has in hiding the primary benefits to from program proof what we have done is to point out a basic difficulty with any attempt to prove programs correct however proofs of software may be coupled with engineering techniques and may yet succeed indeed there is considerable evidence that the verification of software can be to the key processes that allow us to understand and believe mathematical proofs ie there are mechanisms with which to make software more like real mathematics the first mechanism which may be exploited is the device of creating general structures the instances of which become more reliable due to the of the general tures in particular form appears to be the exactly the sort notion of of mechanism that this sort of activity a library of useful abstractions will develop and programmers will simply not have to program as much to get a new system this notion has appeared in recent years in several in the creation and understanding of general ly useful algorithms represents such a the team programming methodology of is another example of attempts to software explicitly for the purpose of it to of effective designs causes a community to examine the programming tools to be most commonly used a second mechanism is the notion of level proof we have basically argued that a proof of correctness will not be correct ever if proofs are correct they must be generally in order that information may be extracted from them the here is that algorithms yield ideas about other algorithms and are thus while proofs may not be exported the languages of proof must be carried out in high level at higher levels than programming is done consider that theorems which are to are exported to a larger community and if they are created in languages then instantiation to programs become feasible and with our other mechanisms the concept of correct software been with us too long as a goal for it to be easily in fact as a goal it offers for research in computer science providing for example a to even more export able programming tools and for the practice of programming however the notion of program correctness has that of gram like good we should not our mathematical models with and correctness like proof is nothing but a model of relatively little discussion see eg has into determining tive developing technical tools and creating research for other of reliability issues we feel that the growth of complex software systems has not yet been discussed using that are sufficiently precise for development of alternative views of software when another view of reliable design arises that more fully exploits the mechanisms which have proved useful in the development of and for which we have argued in this expect to see technical developments follow in this alternative track references s of a a b on the problem of the four j mathematics v pp p j map coloring j math oxford pp theorems v j l the existence of infinite groups in w w f b can and r c eds word prob northholland pp g mathematical proof the of a reasonable science vol pp a meyer the inherent computational com of theories of ordered sets a brief proc international of august m o private communication p and j methods in academic press j la distribution des de la cs et consequences see math de france v pp p j the independence of the hypothesis nat sci usa part i v pp part ii v pp j b simplified academic press independence proofs a infinite forcing in model theory in j e cd second logic symposium northholland pp r w world the life and times c a r hoare algorithm find c a c m v pp d knuth j morris matching in strings computing v pratt fast pattern to appear in siam j l the complexity of decision problems in automata theory and logic mit thesis r london private communication j schwartz on programming report see also a comparison of and setl by j b morris sci lab university of california nm j k rice private communication w a r l london and m abstraction and verification in university computer science department research report july d e ke art of vol i vol ii vol iii f t programmer team management of production programming ibm systems vol no pp ­ s l and l observations of in applications of modern programming ieee transactions in software engineering vol no september pp 
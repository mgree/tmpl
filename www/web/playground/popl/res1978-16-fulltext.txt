record of the fifth annual acm symposium on principles of programming languages offline and online algorithms for equalities the pennsylvania state peter university university park pennsylvania university of college park bell sethi hill new abstract the classical common subexpression problem in program optimization is the detection of identical subexpressions suppose we have some extra mation and are given pairs of expressions e e which must have f zf j which if as a result the same must have h value and expressions different values we ask r this has been called the uniform word problem for finitely algebras and has in proving and code we show that such questions can be in time where n is the number of nodes in a graph representation of all relevant expressions a linear time algorithm for detecting common sub expressions is derived algorithms which process equalities inequalities and online are discussed introduction some compilers will recognize that b xc is a subexpression of both such common subexpressions xc and tend to arise when address computations are made ex in commands like in the context of array references another interesting occurs this time at the source level instead of looking for identical subexpressions we need to find expressions that are equivalent subject to some conditions for example whenever as it is when a that b or a b then it xc a less direct fol implication is a b b a further a and soon in inferring and we do not use any properties of division or for that matter whenever then ki where and can be any two functions the work of this author by the national science number was partially foundation supported under grant in this paper we suppose certain pairs of expressions we are given e e i called axioms or equalities and ask whether these axioms together imply gh where g and h are some expressions also of interest is the case when we are given inequalities f zf j lj n and ask whether for all i and f f for all j together j imply either gh the equality problem or g the inequality problem the by example above problems during investigation and sethi ds of of that manipulate data structures for consider the following simple program m ai the value assigned to m is given by the tional if ik then else ij the to m can safely be replaced by m ij this involves showing that whenever it follows that both equalities and inequalities must be considered while simplifying the nested conditionals which occur with more complicated programs or with multiple subscripts gl g h here h is assigned if g gl which simplifies to gl if we can show that assuming e e and ff it follows that gg considers the equivalence of programs where all predicates are tests for equality showing that two programs are equivalent again reduces to showing that two nested conditionals with equality tests are equivalent thereby involving the equality and inequality problems considers a deductive system for solving these problems as a necessary component of a program verification system the interactive deductive systems go and the symbolic execution systems ki used in pro gram verification require efficient methods for equality or inequality between expression instances these applications require that a data base of known equalities be maintained to de whether a new equality or inequality is consistent with or from the current data base n our object is to give time efficient for equalities or inequalities of expressions from axioms we that the expressions considered are free of variables and involve only constant symbols the following the problems examples suggest the scope of example given that xy it is immediate that however given we cannot down and infer t similarly given that ab a we cannot up and infer ax c z b a x c since be o but given a x c b a x c it c may follows that using tests by contradiction we can turn inequality questions into equality questions suppose j i xk for example we are given and are if as a result z for a test by contradiction suppose that immediate is false ie from in fact that it which contradicts the given statement consequently our must be false ie is true is ii as in example we show appendix a that the inequality problem reduces to the equality problem f zf jl furthermore play a very the given minor role inequalities so the equality problem reduces to the uniform word problem de by it follow given that axioms gh does example conceptually the basic technique for testing equality is substitution of sions given the following set of axioms suppose we are whether substituting a for in the second infer a substituting b in the first axiom yields cb ad final substitution of c for bad in the bad yields thereby c b in the tive n for one ex the implementation number of algorithmic of substitution raises a issues since we employ the precise term is uniform word problem for finitely presented algebras some expressions substitutions device depends expressions device to keep track of rather than performing actual the nature of the on the representation of before discussing the of various representations let us review what is known about the uniform word problem the problem has long been observed to be decidable a gave an exponential decision algorithm kozen ko shows that the uniform word problem is complete for p the class of polynomial time gives a polynomial time algorithm kozen k also shows that the problem requires space in one natural proof system nelson and no have in dependently discovered an one time algorithm using the methods of section below have dis the connection of the with theories of data have implemented a simple polynomialtime algorithm for program verification studies in this time efficient problem paper our object algorithms for is to give the uniform improved word in designing an algorithm there are three choices that need to be made the representation of expressions the representation of equality information between expressions and the mechanism for deciding when an expression f can be derived from an expression e by substituting for a subexpression in example c b ad in order to infer we need to establish the equality of the subexpressions c and bad as well as b and in general even though we may be interested in testing the equality of expressions g and h only it will be necessary to examine all subexpressions of g h and the axioms a tree representation makes it easy to refer to subexpressions each leaf in the tree represents an input name and each non leaf node represents an operator the representation of expressions we will actually use is a generalization of a tree called a directed acyclic graph dag dags are formed from trees by identical subtrees figure gives an example of a dag in the con text of dags we will refer to nodes rather than to expressions both nodes u and x represent the subexpression ba b figure directed acyclic graph be further identical dag subtrees the above yields a dag can the dag representation of expressions arises naturally in the translation of sequences of assignments au cu a dag is also a much more representation there are dags with n nodes whose equivalent trees have n nodes consider in the two leaves representing b necessarily have the same value as do the two leaves representing a one way of recording these value number b ta facts is to assign a number called a to each node nodes the same the number an axiom like recorded by forcing the nodes a and b a to have the same value number since nodes u and x operator and their respective have the same sons have the same value number it follows must have the same value that nodes if nodes u and u and x x initially had different value numbers we must now change the value number of u to that of x or vice versa but there may be a set of nodes with the same value number as u and a set of nodes with the same value number as x so we need to merge sets of equivalent nodes the algorithm of morris and shown by tarjan to have a practically linear running time can be used for the purpose the final issue we must is the used to nodes like u and x in figure which have the same operator and whose corresponding sons are equivalent suppose leaves labelled b a c in figure have value numbers respectively we can form a string for each node using the operator for the node and the value numbers of the sons of the node thus the strings for u and x will be and the string for z will be x the problem now becomes one of identical strings and schwartz cs strings which takes linear expected time but quadratic worst case time if the strings to be checked for equality are all available at the same time then the string sorting algorithms of are guaranteed to take linear time but hashing may be more in practice methods which do not explicitly set up the strings to be sorted but rely on controlled edge traversals are also available the data structures needed are similar to those in sethi se where an rithm in the context of processor scheduling is given our objective in this paper is to show how the solution of the uniform word problem reduces to these two issues the of equivalence relations and the detection of nodes like u and x which have the same operator and equivalent sons with operators like and x there is a constant bound on the number of operands for this case the uniform word problem can be solved in time where n is the number of nodes in a dag representation of the expressions to be tested an algorithm is given in section a linear algorithm is given to detect identical subexpressions in section design of algorithms equalities online involves choices which are discussed to handle processing of some different design in section section places relating the uniform word problem it to results on other in perspective problems by the problem an expression will be viewed as a tree where each leaf is labelled with an input name chosen from a finite set s and each node is labelled with an operator chosen from a finite set as usual the number of operands of each operator in is given by an integer rl called the rank of and all nodes with have exactly r sons order in which the sons of a node appear the is significant the semantics of expressions are also expressions denote elements of a set v of values we define the value of an expression in terms of an interpretation i that maps each name to an element of v and of rank c to a function from vr to v definition the value under i of an expression e denoted by qe is by a a if a is in s el er are expressions r if an equality is a string of the form ef where e and f are expressions the equality is satisfied under i provided ge f under i given a set of a interpretation is said to satisfy a if every equality in a is satisfied under i with these definitions we uniform word mentioned t ion can in formulate the the uniform word problem for a single equality let ae h and the equality gh be given e gh is satisfied for all satisfying a u since the other problems mentioned in the introduction equality consistency inequality reduce to instances of the uniform word problem we have chosen to defer a discussion of them to appendix a there exist problem field several ways of describing the uw on ones point of view and it can be as the problem of assigning identical value numbers to the nodes of a dag that are equivalent under a set of equalities the problem of all valid implications from a set of axioms the problem of calculating the smallest congruence generated by a set of axioms or the decision we use the abbreviation phrase uniform of the phrase word problem as an uniform word problem for finitely presented algebras finitely comes about because a equalities between expressions the uniform that a is a parameter to the problem the further abbreviated phrase uw problem will sometimes problem problem for the theory of equality with uninterpreted function symbols a no the formulation we will actually use proving the correctness and analyzing the com of algorithms for the problem will represent expressions by dags then nodes represent subexpressions with each node x of a dag is associated a unique expres sion tree tx the value x of a node under i is tx let a be a given set of if node x has expression g g and if node has expression h then testing whether testing gh follows if a from a under reduces all to a is empty in the classic common sion problem and we are interested not so much in determining if g h as in finding all redundant computations the related statement terms of dags is that we want to partition the nodes of a dag representing the relevant expressions so that two nodes u and x are in the same class if and only if mx under all i satisfying a such a defines an re on nodes all equalities between expression will be translated to relations between nodes a given set of equalities between expressions will be represented as a symmetric binary we agree to call i is gx relation on the nodes of a dag this relation a also inter said to satisfy a if u we can now setting of dags the uw problem in the uniform word problem full version given a dag d and a binary relation a on the nodes find a relation r such that if and only i x under all i satisfying a d at this time we will not the between the full version of the uw problem which determines a partition on the nodes of a dag and the single equality version which checks two given nodes for equality a similar distinction applies to finite automata where the best known algorithms for the two versions have different time hopcroft and hk give a practically linear algorithm for determining equivalence of two finite automata and hopcroft h gives an algorithms for partitioning the states of a finite automaton into equivalence classes basic lemmas given ab and bc it immediately follows that ac since equivalence is transitive equally obvious is that we can always substitute equals for equals within an expression these two observations t form the basis of two trans transitive and sc congruence we will t and d are exactly c show in this section what is needed to that solve the uw problem of these efficiently transformations computing the then becomes our goal or consider the dag in figure the two leaves representing b necessarily have the same value as do the two leaves representing a once leaves representing the same name have been related we can infer that nodes u and x must have the same value under all interpretations these lead to the following transformation c definition the nodes of r false and let r be a binary dag d r transforms to under c if and only relation on if is u and x are leaves name a or representing the same u and x representing the same operator have sons dr and y y respectively and for all j j r or w j j we also need n a transitive transformation definition let r be d r transforms to r xu under t if and only if is false and for some node z and are both true d since we will apply and at we use to t ie p dr only if or ptr by definition of adds a pair relation of nodes to a relation so starting p scan only be applied a with any number of times in we say p is irreducible under a if and only if for we write p r when p r under t all r p sr is false and r is a major of application correctness advantage of c of not the order and t is that the of any algorithm that applies c and t in any order until no longer possible fol from theorem the price to be for this advantage ia a one we have to verify that the order in which the transformation adds pairs does not matter more precisely from the properties of c and at we can verify that if p r p then s t and p s by adding different pairs there exists t such that r t thus if p t and p t we to and can p or if and only if r is p for io p lr if and only if p p and pr we write p sr if p ir for some io show that must be the same as a system such as the one we are working with in which each object transforms to a unique irreducible element is said to have the finite church property see sethi sel for details we that since elements are unique under will write p for the irreducible relation p transforms to under the rest of this section shows theorem that starting with a given relation a the solution to the full version of uniform word problem is given by the relation a implies that a for u all nodes u and x x under all satisfying proof let ao be a and let be some sequence of symmetric such for io ail ai and we prove that the by on the least such that basis io then so by definition mu mx satisfying a inductive i there exists z such from the inductive under all i hypothesis satisfying if a a then t i and xa u mz mx a if then u and x either represent the same input name or they represent the same operator and from the inductive has the same value the lemma follows hypothesis as son o j son of x of u j for all j the interesting part is showing that the of the above lemma is true in other words if u and x have the same value all interpretations satisfying a then u some insight can be by considering the case where no two nodes are assumed equal so a is the empty relation then we can use a free interpretation that assigns the expression of node u as the meaning of u so that u and x have the same value exactly when they have identical expressions since the transformation identical subexpressions the last statement translates to exactly when uk a similar idea works with any a we will pro by defining a particular interpretation satisfying a under which nodes u and have the same value exactly when u in the same equivalence class under a x will x are definition given a relation partition the nodes of d into i classes assign an integer from each equivalence class let number of the equivalence class for define a as follows a let equivalence through i give the node x to if some leaf aa x x represents name a then let if some node x represents operator and has sons map yl yl y let the to function n la before verify that we use the above is a function a lemma is an interpret a a tion we must tion satisfying proof by definition the same name are in the so for any name a qa all leaves same equivalence is unique representing class suppose representing that the w w wr there are two nodes same operator with and yl y u and sons x respectively such that since a is irreducible under it follows c that thus a is a function a is a subset of a if we have so therefore satisfies a a n theorem completeness nodes u and x in d u mx under all of if and satisfying for only a all if proof one direction is lemma conversely suppose yx under all satisfying a then u x under h by the definition of it is clear that z z under for a all z thus and x cl relation which is formed from a by taking the closure under s c and is the t minimal congruence relation on expressions which satisfies a in an independent development sh gives a result similar to theorem using a least binary relation closed under conditions similar to c and t the interpretation the herbrand transformations with algorithms of definition corresponds to model given by our use of makes it easy to connect an algorithm from be solved a theorem by starting and applying the uniform word problem can with a given set of equal transformations ac and t in any order until no longer possible to yield a for then tw nodes are in the same equivalence class of a if and only if they have the same value subject to the equalities of a if we can find a sequence of ever equivalence relations that starts with a and to a then we can give an easy upper bound on the length of the sequence given a symmetric relation a let a be the equivalence relation formed by taking the reflexive tive closure of a consider a sequence of equivalence relations o k n he nodes of irreducible d such that then ak aj a jl must be a and k clearly s a is formed j by merging equivalence classes of a if for equivalence each class that kn where j has at least one less than n a then we are j is the number of nodes of d for operators like and x there is a constant bound two on the number of operands for simplicity of we will give the algorithm and its analysis assuming all operators have rank two algorithm in figure starts by the nodes into equivalence classes based on o the reflexive transitive closure of the given equalities a all nodes in a particular equivalence class are given a common value number represented by the array vw indexed by nodes the nodes are then processed in some sorted order as a new node u is encountered a string u consisting of the operator of u followed by the current value numbers of the sons of u is constructed for the purposes of this discussion the strings are into a table acl for available computations list if d is in the table then there node x with the same string must be some other u so the equivalence classes for u and x have to be merged by procedure merge when value numbers are changed to put u and x in the same class the strings for the may have changed so procedure merge the let d edges let give the be a dag with n vertices a be a set of node pairs number of elements of a and e and let lemma algorithm l correctly computes proof the value numbers define an equivalence relation in the array vn on nodes let ri be the equivalence relation before the i st call defined to merge by vn just it is clearly the case that that only if u ri so conversely let let a be the re closure some sequence of a and of relations let such o l that ail ai and ak a we prove by induction on i that for all i there is some r such that implies x suppose basis io here r suffices inductive step io there exists z such that from the induction hypothesis if ail then ua z and ­ za x there is a r such that uz and zx so that ur xx if ail then u and x have the same label and their corresponding by ail from the induction sons are re hypothesis sons are related by rr for some least integer r ie they have the same value just before the r st call to merge number consider the call to merge from the choice of r a pair of corresponding sons of u and x get placed in the same equivalence class by being assigned the same value number if both u and x have been marked by then there is an appropriate string for each of u and x on acl when all nodes on are con in merge u and x will be placed in the same equivalence class if u and x have not both been marked by then when the last of u and x to be marked is processed by it will be placed in the same equivalence class as the other node the above induction establishes that if then for some r and at termination u and x have the same value number u theorem given a dag d equalities a let d have n each has two sons determines a in and a set of nodes assume algorithm time proof from lemma algorithm de a so we just need to verify the time bound step requires time since each equality must be at and the components of an graph can be found in linear time aside from the time taken to check entries on acl and the time spent in merge the time taken in the while loop is proportional to the number of nodes in order to ensure that an entry can be added or from acl in constant time the acl as a kn each node in the will be an array of length n with each element of the array being a pointer to the appropriate son of the node since there is a constant bound on the number of sons of a node the each string is bounded by given strings of length the space required by the is on we avoid initialization costs using a pointer stack as in exercise thus the time taken in procedure is linear consider the calls to procedure merge calls of the form merge kk constant time and can be to the point at which the call occurs if then in constant time the call merge kj is converted to merge jk since the value numbers define an equivalence class on nodes there may be at most n calls in which value numbers are changed so all we have to verify over these n calls is that the total is time spent when two classes are merged we are careful to merge the class with fewer into the other class thus every time a x is because of son y the list for the class of y in size since there are a linear number of edges in the dag and the number of entries on a list is limited by the number of edges node x is at most times because of y since there are at worst two sons of x node x is at most times it follows that the total time to merge is the time we get taken by o and merge input a dag d and a set a of node pairs that are given to have the same value the nodes of d are assumed to have been given numeric identifiers in the range to that they can be efficiently since lexical normally assign internal names to variables this assumption is not to be output equivalence where ie x and value under all interpretations y y if and only if have the same satisfying a structures nodes maintains the value numbers of each element ln and linked list acl the available computations list contains pairs o m where o is a string and m is a value number the two operations performed on acl are the insertion of a new entry on ac and the of an entry for a string g is the structure for an directed graph the nodes of d in topological order starting with the leaves it returns when there are no more nodes i procedure initialize da a fc for each pair do add edge xy to g end the connected components of g using search set the vn of each node in the first component to in the second component to etc while x null do mark let r be the sons of x left to right add x to the and if x is a leaf do nothing if the acl has an entry o for then merge where m is the value number entered for d else insert on acl and add x to the list end end procedure merge kj if kj then return i i then else for all y on do for all x on d let x have sons l to right if the acl has an entry for then merge where m is the value number entered for end append list to append list to end merge figure algorithm for the uniform word problem in practice acl might well be implemented as a hash table not as a but then only expected time to search the acl is constant the worst case time the not to extend the above algorithm to the case of dags d with other than binary operators we use an observation due to tarjan replace each node x with label and r sons by a chain of binary nodes and dummy operator symbols as suggested in figure the resulting dag d can be processed by algorithm since every node of d gives rise to binary nodes in d then d has no more vertices than d has edges this yields an oe time overall d d figure transforming to binary nodes suppose that the operators to be commutative ie the ordering at each node is we can tend algorithm to cover this are assumed on the sons readily ex case corollary can be computed time bound when operators are commutative from a without the proof instead o merge sort of constructing in procedures to get string and string in decreasing instead of order use string o when checking strings against acl the time bound does not change u a linear problem for the common subexpression for particular cases of the uniform word prob problem more efficient algorithms can b written if the set a of pairs is empty then if and only if the trees rooted at x and y are such nodes are called strongly equivalent the problem of computing has been called common subexpression detection and schwartz cs use hash table searching to solve this problem in expected linear time and worst case time n here we give an algorithm partition with linear performance in worst case let the height of a node x in d be the length of the longest path from x to a leaf any two strongly equivalent nodes of d must be at the same height thus algorithm partition needs to only nodes of a given height each node is assigned a value number which never changes to assign value numbers to nodes at height i the algorithm needs to sort only the height i nodes and needs to use only as many as these nodes have sons the algorithm is given in figure algorithm partition generalizes the algorithm from aho et al p for determining whether two labelled unordered trees are algorithm partition solves the isomorphism problem for labelled ordered dags and for trees as a special case theorem the nodes of dag algorithm partition time on e let a be d with correctly an empty relation n nodes and e determines on edges in proof correctness any two strongly equivalent nodes must be at the same on the first iteration the leaves are correctly identified assuming partition has identified strongly equivalent nodes at height i it is easy to see that the strongly equivalent nodes at height il are correctly identified analysis let ni be the number of nodes of height i let ei be the total number of edges clearly from nodes of height i to n and ze e their sons consider the loop body ei on iteration i step takes time the size of the list built is n e step adds to queue strings with thus step sorts in time strings of total length using this takes i ei time step can clearly be done in and step is bounded by overall the loop body since step on the algorithm one time requires total on o input a dag d with n nodes the leaves of d have labels from a set s of names and the have labels from a set for convenience assume each element of g us been assigned an integer nr between and n output an array where x is strongly equivalent if and only if structures sorting of bits list is a indices and queue are needed is an linked list of bucket for array procedure find the height of all nodes in d let h maximum height of any node io set set all queue to to false while ih scan the nodes at height i collecting in list the value numbers of sons of these nodes set each time value number i is encountered and add i to list only the first time add to list for each distinct element of o us encountered for each node and sons x at height yl i with label add string to queue note ro for of x leaves call this the string sort the queue using only the indices on list strings on with scan the distinct count queue assigning distinct suc value numbers to those nodes with strings on queue increment accordingly for each i on end list list do end return vn partition figure detection algorithm for common algorithm partition can subroutine to provide an algorithm for word problem that require hashing or proof of theorem no have independent ly discovered an the same time bound corollary and e edges and uniform word problem time given a set can a dag d of equalities be solved with in n nodes a the one proof see nelson and no o in the special case of the uniform word problem in which there is given a single equality ef between expressions linear time suffices this problem arises in and sethi ds where a restricted class of programs with array assign ments is studied nodes time corollary a uv one let a a single then a can be determined in proof let du and dv be the of d rooted at u and v respectively if neither of u and v is an ancestor of the other then all edges coming into u or v to a new node x and run partition on the resulting modified dag suppose that v ancestor then du is a of dv call of u in d two nodes x and y if y a node equivalent to v will be called a for each node x in d define the of x to be the of node x above its descendant nodes with no descendant have nodes u and v have zero let x be a node in d of height i and j it is easy to see that if x is equivalent to any node of height less than i then x is equivalent to some node y of the same j in dv given d we can run partition strongly equivalent nodes that d is given with distinct nodes expressions run partition on on d and so assume having dis dv assigning value numbers assign the same value number to u and proceed to consider v next modify nodes in order partition to of above v steps and are modified to scan nodes of i in dv and queue up the strings at this all nodes with less processed the remaining by partition in order height after than co have nodes are of increasing to maintain the of each node above v an array is maintained the of a node is calculated using the of its sons and is set to zero ever the count reaches the of v o an online algorithm the above algorithms for the problem all assume that the given inequalities between expressions uniform word equalities and are known before any need to be drawn and that expres sions are presented in the form of dags thus the algorithms are offline these assumptions are realistic in contexts involving code however for interactive applications such as theorem proving and symbolic execution equalities inequalities and requests to perform may arrive in any order algorithms are needed which are online and themselves to a dynamically changing environment of known equalities and inequalities this is especially true in symbolic execution systems ki where alternating program paths are explored in one path an equality is assumed true and in another path it is assumed false for example we would like process the following transaction to be able to stream online example fa c fb d ab deduce cd hc deduce bd the order in which the equalities are important if ab were encountered before fa c and fb d the equality c d would be quite easy to then prove an algorithm for the above example is online if each inequality or deduction request is completely processed before the next is read thus before input is read answer whether or not cd the algorithm is must from the information in and similarly before input is read the algorithm must that inequality is inconsistent with the information in to the basic problem is that of creating and updating a data base for equalities so that a simple decision algorithm can be used to determine if two expressions are indeed equal me will use the notion of equivalence classes to keep track of all expressions known to be equal an class is constructed for each expression which has been encountered while processing equalities a class is represented by a value er moreover the subexpressions of each expression are represented in terms of their value numbers for example when the equality fa c is processed an equivalence class is created for a say for fa say whose member is f and for c say an list acl is maintained with the definitions which is accessed by hashing on the lefthand element the equality of fa c is processed by merging the two equivalence classes and and all subsequent references to fa or c are by use of the lowest equivalence class which was merged ie in our example this would result in an acl to the process of adding base consists of an equality to the data for each half of the equality determine the equivalence class in which it is contained create one if it is not contained in any equivalence class this is done by parsing each expression using the acl to assign value numbers to subexpressions this is done by routine parse in figure merge the two equivalence classes by routine propagate in figure update all references to the merged equivalence classes to point to the new equivalence class merge all equivalence classes whose equivalence is a direct by of the transformation c this may re in the merge called recursively routine propagate being as a of consider the case when ab and fa and fb appear in separate equivalence classes labelled p and with g then implies that fa and fb are to be uniquely represented as is the name of the equivalence class a and b and thus the two classes containing fa and fb are merged into one class all acl references to q are to the process of determining the equivalence class value number of an expression be as a form of simple precedence parsing against the reductions available in the acl the algorithm for adding an equality to the data base is given in figure the data base consists of an indexed table acl one entry for each node processed to date we will in referring to nodes instead of expressions and subexpressions an entry is of the form am where o is a string vv vr consisting of an operator symbol and son value numbers m is the value number of the associated node acl is accessed by hashing on the strings all references to a member of an equivalence class are in terms of its value number pro propagate that the value number of any class equals the smallest index of any node in the class steps and correspond to the merging of equivalence classes due to transitivity al references to the merged value numbers max are replaced by the minimum value number step enforces the propagation of equality by the transformation when two acl entries ai and ok with identical strings are found the classes i and k are merged by recursively calling propagate there are no more than calls of propagate for each call to update is a list of acl of entries am which mention max or min in thus it is a list of nodes affected by the merge of max and min is maintained in sort to simplify the search for a string match in step step need only be applied to entries on note that duplicate acl entries caused by merging of value numbers are deleted since acl is we do not actually remove these but only mark them as deleted the process of determining the equivalence of two expressions is quite simple from a tional specifically in parsing an expression there are exactly as many of the acl to be made as there are input names and operator symbols in the expressions the process of updating the acl can be up significantly by the of linked lists and which links all members of equivalence class i in part the need for step which links all equivalence classes having the son i the need for step and the steps and inequalities can also be handled this is accomplished by maintaining a table of pairs of equivalence classes value numbers which are known to be the algorithm for proving equalities needs only a slight modification to be able to with inequality queries such as in the above example in such a case the inequality does not appear explicitly in the data base instead we derive it by contradiction we assume that bd and add this relationship to our data base if b zd is true then a contradiction will occur this is detected at the occurrence of an merge of two equivalence classes which are known to be of and in the above example each entry in is a pair of value numbers therefore whenever a merge of two equivalence classes occurs this table must also be updated is updated just before step of as follows for each pair occurrence if xy end xy in do of max by min then contradiction replace xy each note that the inequality algorithm modifies the data base acl should a contradiction be detected we would like to the updating that has occurred this is not a problem if the algorithm operates in a recursive environment where dynamic storage allocation and garbage collection are available eg lisp and wegman pw consider unification which can be described informally as follows given two expressions g and h containing variable symbols substitute subexpressions for the in such a way as to make g and h identical in the uniform word problem we start with a given set of equalities a and ask if g and h are equivalent the unification to start with expressions g and h and ask if there exists a constrained set of a subject to which g and h are equivalent the two problems are quite different while an on algorithm exists for unification is the best comparable result for the uw problem and while assuming operator does not affect the uw problem complexity it can be shown that unification with commutative operators is nphard procedure update ef are be added ef expressions to the data ef is the axiom base to obtain the value numbers propagate of ef from the acl propagate effect new equivalence through the data base end update of procedure propagate max if min max then swap min and max in a ma are the value numbers of the equivalence classes being merged is a acl indices in sort of entries which mention max or for j let om if min occurs in in o then insert end do j for j instances of max by let om if then replace t lf max occurs in o then m by min replace all occurrences max in o by min of insert j in i needed since string o has changed end while do step through the list of affected nodes looking for matching strings and propagate merge let h be the smallest index on delete h from let oi for each j on do let t if t then matching string delete j from mark deleted from acl classes ik must be merged end end propagate end figure algorithm to process an equality the axioms are equalities any variables law many instances given in the uniform word problem between expressions not involving but a law like the commutative x is really a scheme for inferring of axioms of the form ef where ef are expressions let x xy be a set of variables equalities between expressions over are called axiom we review the effect on the complexity of the uniform word problem which results from as seen introducing only the commutative axiom schema for operators does affect the decision procedure for equality if a is a set of axioms over s u then a generates a finitely presented group the uniform word problem for is well known to be undecidable indeed there exists a fixed set of axioms a for which the word problem is undecidable what happens when both associativity and commutativity of operator are if a is a finite set of axioms a xyz generates a finitely pre commutative the uniform word problem for such commutative is decidable however a recent result shows that this problem is complete in exponential space it follows that for infinitely many a deciding equality of expressions requires time kozen ko has shown that inferring from a set of axioms is a hard problem knuth and kb and l give algorithms which work to decide word problems for some sets of appendix a inequalities problem and the uniform word let a m and bf jl be sets of equalities inequalities respectively we shall also and b for the conjunctions a b and use a and formulas are built up from equalities using the usual logical connective formulas of the type gh and will be abbreviated the meaning function m can readily be extended to formulas a f is satisfied under provided gf is true a formula is consistent if it is satisfied by some i a formula is valid if it is satisfied by i consider the following sets a and b as above and h four problems and expressions given g a equality problem determine whether gh satisfied for all i satisfying this is the same whether a a b is valid is b consistency problem determine whether there exists i satisfying this is the same as whether aa b is invalid c inequality problem determine satisfied for all i satisfying the same as valid whether g h this h is is is d uniform word problem determine whether gh is satisfied for all satisfying just the equalities whether a the same as determining is valid all uniform following four problems word problem lemmas reduce to instances as may be seen from of the the al given a and b and expressions g and h a aa b if and only is valid if b y aa b is invalid if and only if is invalid c aa b gh al is valid if and only is valid if proof equivalence the other part a follows of aa b o gh parts are similar from and o the logical gh a let a be a conjunction of is valid if and only if at least is valid for lj n proof and suppose that all of a o gj are invalid then there exist consider n over over value domains satisfies j aa gj vi x defined by me xe where is the value of e under aa for this is the satisfied formula but is not valid a contradiction then the other direction immediate d of the lemma is the above lemmas show that all the problems a b c reduce to deciding the validity of formulas of the form where a is a conjunction of equalities thus a solution to the uniform word problem solves all the problems we wish johnson johnson to thank al aho john unman for helpful discussions and references a w solvable cases of the decision problem northholland amsterdam a v aho j e hopcroft the design and analysis of algorithms mass j d unman computer reading au a v aho and j d unman optimization of straight line programs siam j march b m s generation of optimal code for expressions via cacm june cs cu ds go hk ki kn kb k l no ln e exponential petri nets proc th computing r and a r meyer space complete problems for and commutative ann acm symp on theory of pa may john and j t schwartz programming languages and their compilers preliminary notes second revised version institute of mathematical sciences new york ny april combinatorial problems in the theory of complexity of algorithmic nets without cycles for simple computers p j and sethi assignment commands and array structures proc th ann symp on foundations of computer science october d i good an interactive ieee trans march r l london and w w program verification on software engineering se j e hopcroft an algorithm for states in a finite automaton in z and a cd theory of machines and computations academic press new york ny j e hopcroft and r m an algorithm for testing equivalence of finite automata tr dept of computer science cornell univ see description in aho et al j c symbolic execution testing c acm july and program d e ming knuth the art of volume sorting reading computer searching ma d e knuth and p b simple word problems in universal algebras in j ed computational problems in abstract algebra press d kozen complexity of finitely algebras proc th ann on theory of computing may symp co d kozen lower bounds for natural systems proc th ann symp on of computer science oct proof d s canonical algebraic simplification in computational logic department of mathematics report university tx g nelson algorithms th ann science and d fast decision based on union and find proc symp on foundations of computer oct g nelson and d a simplifier program manipulation this proceedings for pw m s and unification proc theory of computing m n wegman linear th ann acm symp on pa may h a normal form for ing proc symp on artificial and programming languages august compiler test intelligence ny sa sel se sh h proving the correctness of optimized code of the acm to appear sethi property testing for the october jacm july church sethi scheduling graphs siam j computing on two pro march r e about equality and programming aug an algorithm proc of languages for the sw p on ai sigplan notices r e tarjan depth first search and linear graph june algorithms siam j computing r e tarjan on the efficiency of but not linear set merging algorithm jacm april a good r e tarjan private communication a undecidable a and r m theories co amsterdam 
program improvement by source to s o u r c e transformation david b massachusetts computer associates inc massachusetts key words optimization transformation program improvement compilation program manipulation abstract w e treat a program as an object of manipulation determine items of program and simplify the program based on the s o m e motivation for program manipulation is presented along with two examples of higher level optimization written in an algollike language a collection of program transformations and a model of the compilation process in terms of transformations are presented finally a description of the application of these ideas to an existing programming language is given introduction the class of programs which have time andor space requirements is quite important these requirements m a y arise from constraints caused by the runtime computer performance requirements of the program or considerations resulting from execution of the program optimization is the n a m e given to the application of a set of rules for manipulating various representations of a program these exploit local or global within the program in order to improve the program relative to some measure before discussing optimization w e should discuss some ideas on the nature of the programming process the programming process can be divided s o m e w h a t arbitrarily into a number of conceptual phases construction verification optimization compilation execution documentation etc in an world one constructs a program using computer such as a text editor file system and syntax checker the during program construction is to describe data objects of interest primary operations on these objects and an algorithm to solve some problem using these objects and operations at the construction phase in the programming process programming style should be primarily at clarity of expression and ease of verification and only attention should be to efficiency unfortunately programming which lead to logically clear programs tend to result in programs which w h e n compiled are not efficient enough to meet their operational requirements structured programming techniques such as the isolation of implementation details of operations from the application of the operations tend to result in highly modular programs naive compilation of highly modular programs results in great as a consequence of the of the modules it is necessary to decide which be expanded as inline code which should be specialized to their particular calling environments and which should be left as general modules the code resulting from modules which are expanded inline will usually allow for considerable optimization w h e n viewed in the context of the program in which the expansion occurs conventional optimization techniques unfortunately will only perform a little of this optimization more powerful techniques which address themselves to program structure loops and conditionals in particular are needed these optimization techniques may be in two ways by facts k n o w n about the particular data objects being manipulated at the point of module expansion or by interactions with the program text that is the context of the point where the module is expanded examples of these two different w a y s of optimization will be given in a later section in general w e view the process of optimization as one which either or accepts as given statements of invariance in a program statements of invariance include the of the specification of the internal representation of data objects and the implementation of the basic operations on the data objects as well as such standard information as n has the value of sin represents the library routine and this algorithm will be executed only on a c d c given certain statements of invariance certain program transformations m a y be s h o w n to preserve program correctness while at the same time improving the program relative to some measure obviously fault can be found with the view of the programming process presented above algorithms to manipulate data objects are not designed without s o m e notion of h o w to implement these objects even at program construction s o m e information such as this program will be compiled by ibm f o r t r a n level h m a y be k n o w n and the statement of the algorithm may be affected also while doing optimization it m a y be discovered that a chosen representation does not allow the operational requirements to be met thus requiring the construction verification and optimization of a n e w representation our in the programming process into construction verification and optimization for algorithm and representation is to two data objects and operations on them w h i c h are natural to a problem area from the underlying representation of the objects and operations and the problem of constructing a correct algorithm from the problem of making an algorithm meet certain time andor space requirements higher level optimization in optimization w e treat the algorithm as an object of manipulation determine items of algorithm either from the algorithm itself or by statement from the outside and simplify the algorithm based on the we include within optimization such standard techniques as constant propagation constant computation common subexpression elimination removal of invariant code from loops strength reduction elimination of redundant code etc our primary interest however is in high level optimizations such as case splitting based on k n o w n possible values of a variable loop unrolling loop fusion interaction between loops and conditional statements etc w e are interested in those optimizations which can be described as transformations on a representation of a program that is optimization w h i c h can be considered as we thus may describe an optimization as a mapping of one particular tree structure to another the issue is that this mapping must preserve program validity in s o m e cases for example loop unrolling the transformation always preserves validity in others certain enabling conditions must be true before the transformation can be performed for example two syntactically identical computations are conventional c o m m o n subexpressions only if corresponding variables referenced by them can be s h o w n to have the same values a second consideration the of optimization is that the transformation must lead to an improvement of s o m e form in the program a is that the transformation itself m a y not improve the program but m a y change it in such a w a y that later transformations will result in a gain this is to the intermediate expression issue in algebraic symbol manipulation for example in certain cases computation done prior to an if then else can be duplicated on the then and else branches this results in no of time and an increase in space but it m a y be that taking advantage of the k n o w l e d g e that the if predicate is true on the then branch and false on the else branch will lead to considerable one can imagine an optimizer searching through a program tree trying to decide where to apply transformations such a process would be extremely however it appears that the application of certain transformations immediately suggests other transformations to apply for example having discovered that a variable is assigned a constant value immediately suggests that w e try to propagate that constant and then see whether the assignment is to a dead variable having propagated the constant value w e want to see if constant computations can be done and whether w e can assert that other variables are constant we thus view an optimization as containing parts · the n a m e of the optimization for identification purposes · a pattern to be found in the program tree structure · a pattern predicate w h i c h evaluates to true if the optimization preserves program validity · a predicate which evaluates to true if the optimization or a optimization will improve the program · a sequence of rules which make the transformation · a set of predicates to be true as a result of applying this optimization and · a sequence of names of optimizations which should be tried as a result of applying this o p a serious problem involves the propagation of information from its point of origin to where it is needed to evaluate predicates in an optimization rule classical such as f o r t r a n h have used the technique of interval analysis as described in optimization an improved form of global analysis called analysis has been developed to m a s s a c h u computer associates and used in the f o r t r a n compiler and in the f o r t r a n a program developed for f o r t r a n source language optimization optimization shapiro and algorithms extraction has extended the concepts so that they apply to a n y property set which satisfies an appropriate set of axioms recent work by information inequalities affine has studied the problems of and propagating information about programs w e are interested in techniques for manipulating programs which contain loop structures clearly most programs will have looping structures explicitly written by the programmer although these are of interest of greater interest are the loops w h i c h exist implicitly within the program as a result of high level programming language features a programmer could perform transformations such as loop fusion on loops w h i c h he has written there is no way however that he can touch the implicit loops in the program by analogy a programmer can if he is careful perform c o m m o n subexpression elimination on code he has written there is no way however that he can eliminate the c o m m o n code resulting from similar array references the compiler must this high level programming language features w h i c h provide implicit looping m a y exist in two forms they m a y be built into the language as standard features such as the primary operators and condition expressions in languages development development the vector and array operations in a p l apl or they m a y be provided by extension in an extensible language such as e c l the first case can clearly be viewed as a special case of the second where the extensions are made at language definition time a later section describes two examples of higher level optimization and shows the type of success that m a y be expected description of program transformation rules as indicated earlier a program transformation rule says find s o m e pattern in the program for which s o m e conditions are true if an evaluation function indicates that this transformation results in a gain relative to the appropriate m e a sure then perform a set of and make a set of assertions having executed the rule there is a set of rules w h i c h m a y have b e c o m e applicable see if they apply a possible syntax for such a rule might be name pattern where when predicate then pat i replacement i replacement n assert predicate i n a m e i n a m e m as an example of a conventional optimization the rules for constant folding might be written y where assert constant propagate in x where constant x then x constant computation in x op y where and then x op y op constant computation in x y where then x y null the rules in the above examples of constant folding do not have because there is always an improvement by applying them other rules are not always for example in general splitting a loop into two loops introduces an overhead of extra control structure h o w e v e r on a g d c if the n e w loops will fit into the instruction stack of words there will be a gain this rule might be written loop split in loop ab repeat where and w h e n a repeat o b repeat then loop ab repeat loop a repeat loop b repeat if w e were to actually state formally all the details of the rules presented later the presentation would be quite tedious long and difficult to follow s o m e predicates and functions such as and code length above are their existence can be a s s u m e d without m u c h however w e are most interested in the pattern and rather than give the detailed in most cases w e have just given a generalized before and after example in the hope that the reader can deduce the form of the transformations the details of the transformations are presented in l o v e m a n transformation the idea of program transformation is applicable to most high level languages the details of transformations however are obviously language dependent rather than pick an existing language and all we have designed an ad hoc algollike language as the target of our transformation effort knuth go to states a that a consensus m a y develop by for a really good programming language which he named we name our language samples written in this language will be seen in the next section is designed so that reasonably high level well structured algorithm specifications can readily be written and so that suitable low level constructs are provided to serve both as targets for of features and to m a k e the job of code generator production easier we shall not give here a formal definition of the language this can be found in l o v e m a n transformation we shall give however examples of the more important language features variables a x constants true operators arithmetic assignment ÷ t and or not implies is expressions conventional embedded assignment s function invocation relational cond i block ab x and b x a bx x i y fx s u m of first ab integers ab if x then ab else ab endif begin real j i initially i loop i tn i ij repeat i en statements assignment conditional va b smallest value in then x endif x i y i z then b true else endif conditional de tion a s procedure invocation procedure return label go to situation occurrence block loop iteration loop value list loop multiple iteration iteration loop if p l t h e n sl p then s else s endif declare initially a integer array n s static label array £ £ n mode ij represented b selected b £ i n t e r r shared end assert x a s s u m e a x b suppose ij implies sort elements of call a bc label abc label t abc g tq s done normal termination table full be sl s end a repeat loop b s to f a repeat loop jn a repeat loop fo i bl s l b s a r e p e a t to fl f i o fo i b i b s i fi j bj a repeat loop a while p b repeat concurrent loop simultaneous loop synchronous loop situation loop for ib s to f a repeat ib b s a repeat loop sync s tf a re t until m end examples of higher level optimization in order to give examples of the power of higher level optimization let us a s s u m e w e are using the programming language defined above which allows data type and operator definitions a s s u m e w e have defined the data type matrix in the natural way and have defined the operator to be matrix multiply a procedure which will multiply an £ by m and an m by n matrix giving an £ by n result matrix declare m n z n loop loop for j to n loop to m z yk ij repeat repeat end let us look at a particular call on namely a multiplication of a by b giving c where a happens to be a diagonal matrix ie i j implies declare a s s u m e a is diagonal t b directly expanding in line gives with constant propagation loop ti loop for j to loop for k to i ij repeat re t repeat by performing a case splitting based on the knowledge a is diagonal the assignment statement in the innermost loop becomes then else by expanding the scope of the if we get l o o p fo i t o lo loop to loop to i if i k then c bk j else endif repeat repeat repeat the then clause simplifies to which is redundant and m a y be eliminated in the else clause i k thus references to k m a y be replaced by references to i the program is now loop to i loop fo j to loop to i if i k then e f repeat repeat repeat the purpose of the within the innermost loop is to select the one number in the range of k which is equal to the current value of i which ranges from to i for s o m e values of i this one number might not exist if it exists it is in fact the current value of i o the program may thus be written using the loop elimination transformation as loop loop for j to cj y if i then endif repeat i and i clearly m a y be evaluated at compile time and the predicate of the if statement i i is clearly true for all i since the if statement is in the range of a loop in which i thus the if statement m a y be replaced by its then branch giving loop t i loop for j to fl y repeat repeat at this point constant propagation expression simplification and dead variable elimination after propagating the zero the assignment is redundant since that generation of is dead gives the simplified code loop i to i loop for j to j repeat repeat with the program in this form tional compilation techniques would result in good object code this example of optimization on assertions known true at the beginning and on assertions derived from the program clearly the more that is known about data and program the better job an optimizer can do such initial assertions can c o m e from two sources from the programmer by direct statement or derived from the program as a result of global compilation compiling the routine in the presence of the call of the routine in a ma in program as a second example suppose w e have in addition to the above extended the definition of as a binary infix operator for matrix multiply as a binary infix operator for matrix addition and as a binary infix operator for matrix assignment the meaning of is the procedure the meaning of is declare plus procedure m m z matrix m loop i t loop to m xj repeat repeat end and the meaning of is declare e m m loop to i to io p for j to m j xj repeat re t end suppose we have the following declare d a b c naive compilation of the assignment statement will give declare b tl c t t note the need for words of temporary storage expanding plus and assign in line gives loop loop to i t l i j loop i to repeat repeat repeat loop i loop pt repeat loop loop to j to i d i j t j repeat t the outer loops can clearly be fused since the index sets are the same and there are no data dependencies which it giving loop to i loop to i loop for k i to repeat w e n o w note that each instance of and is dead after the i j iteration of the two outer loops ie tl and t have b e e n reduced to scalars subsumption replacing a variable which is used only once by its definition and tl to be gives us loop t i loop for j to i tt to i tl repeat repeat tl w e could have eliminated tl completely by in but w e did not for two reasons first on m a n y machines an array reference is more expensive than a scalar reference secondly a compilers code generator is more likely to assign a scalar w h i c h is dead at the end of each loop iteration to a high speed register than assign an array element reference to a high speed register typical program transformation rules w e have s o m e w h a t arbitrarily divided the program transformations into five classes for ease of simplifications optimizations and since the program transformation rules are still being developed we cannot give a complete set of such rules if indeed such a set exists w e shall describe informally however a collection of approximately transformation rules these include fairly trivial program simplifications conventional optimizations sophisticated loop parallelism detection straightforward or replacement of a construct by its lower level meaning and manipulation rules these rules include all those referred to in the previous e x a m simplification refers to a generalization of the idea of constant computation and involves up local of program in fairly obvious ways we shall list some of the more obvious simplifications · constant computation including evaluation of procedures with constant arguments and no side effects · loop elimination of a loop · conditional if true then a else b endif a if false then a else b endif b · conditional then else a endif if not p then a endif · assignment elimination by equality if a b the assignment a b can be eliminated a special case of this eliminates the assignment a a optimization is the term w e use to describe those program transformations usually of a low level which are already well understood in s o m e sense these transformations include all the classical ones and perhaps a few new ones · common subexpression elimination · code motion from program areas of high cy to those of lower frequency · strength reduction · dead variable elimination · constant propagation · subsumption following an assignment and before modification of any part of expr a use of m m a y be replaced by expr only if expr has no side effects this is especially valuable if there is only one use of m or if the expr is a simple variable name in which case the transformation is called scalar propagation the idea of subsumption may be used with embedded assignment to register assignment for example can be replaced by · go to · array temporary elimination for example bc can be replaced by t bc t count up to zero a counting up loop can be so that the last loop value is zero thus simplifying the loop termination test this requires modifying all uses of the index within the loop and insertion of an index assignment following the loop if the loop final value is a constant the index offset is a constant and its addition can be done via address arithmetic if the index is dead following the loop the index assignment is not needed loop · i repeat loop fo in repeat i nl to m o v e while to end any loop must have a conditional jump thus if a loop terminates with an jump the loop can be to m o v e the conditional jump to the end thus eliminating the jump loop a while p b repeat pq t loop b £ a w h i l e p repeat the term evolution is used to describe those program transformations which discover higher level language constructs among lower level constructs primarily we are concerned with discovering higher level parallel looping constructs work on the parallel execution of loops lamport parallel loops coordinate and is of great importance here lamport defines three types of parallel loops loop concurrent loops in which individual processors are a s s u m e d to operate on different iterations of the loop loop sim simultaneous loops in which individual processors operate in fashion similar to the iv and loop sync synchronized loops in which the individual processors are a s s u m e d not to be in but to a synchronization condition which guarantees preservation of orderings two transformations have been developed to detect parallelism in conventional iterated loops lamport loops · the coordinate method transforms certain well sets of nested loop into a loop sim · the method transforms certain well sets of nested loop into a loop obviously any loop is also a loop s im it has been s h o w n that any loop sim produced by the coordinate method is also a loop syn c · strip refers to the transformation of a given parallel loop into the iterative execution of a parallel loop with smaller index set this transformation is necessary for any parallel machine with a fixed number of processors for example on the iv which has processors loop to ai bi ci repeat loop for i i b tp ai bi ci repeat l o o p to loop for i j ai bi ci re f repeat t j observe that strip can work equally well for a strip of width one ie for a machine with only one processor it has been s h o w n that any loop or loop sync can be strip thus in place of the second transformation in the e x a m ple above w e could have strip in reverse order with a width of one to get the counting backward loop loop i ai bi ci repeat the transformations to parallel loops require considerable data dependency analysis exactly the analysis necessary for loop splitting loop fusion etc w e shall see the role of parallel loop detection in the of these transformations later another evolution transformation we need is · detection which for a given loop determines variables other than those given explicitly which also serve as loop indices the are written in the as explicit parallel indices for example j z to a j j t b j to a t describes the replacement of a higher level language feature by its meaning in terms of lower level language features typically we perform transformations on given language constructs then replace the constructs by their m e a n ing and perform further transformations at the lower level · elimination loop a repeat si to fi sj j bj until done loop b si a j j sj ij bj fj sign then repeat end · iteration elimination loop i a repeat sl to fl s to f declare end loop b sl b repeat loop b repeat · iteration elimination loop v v v a repeat declare end i vl b i v b i v b i v b alternatively declare a declare a array v v loop for jl i to aj b repeat · single step iteration reduction loop s a repeat sis loop for a repeat si · single step iteration elimination loop by s to f a repeat ib sis £ p a i i s i while si repeat · loop elimination loop a while p b repeat mb a i f p then t o m endif · procedure invocation elimination suppose f has been declared a procedure of n arguments of modes ml ran respectively and with return value pr of m o d e mr for example declare pl ml a end a reference to f can be replaced by a block wh i c h computes the appropriate value fa an begin declare initially al initially an a pr end manipulation is the mapping of one version of a computation into another version which is better in the sense that it is smaller or faster or will enable other transformations to apply to the computation s o m e of the that have been developed are given here · back expansion of conditional allows a computation to be by the information that p is true on the then branch and false on the else branch if the computation is an assignment the variable assigned to m a y well be dead on one of the branches a if p then tc e fc e if p then a tc else a fc endif · forward expansion of conditional if p t h e n tc else fc endif a if p then tc a else fc a endif · loop unrolling in general reduces the number of tests and jumps executed and increases the number of instructions exposed for parallel execution it often register allocation by the matching loop a repeat loop a a repeat loop while p a until done loop while p a if p then done endif a repeat end loop s a repeat until done loop b s to f a if i f then done endif a repeat end note that if the n u m b e r of iterations of the loop is by the unrolling factor then the test for termination is not needed the assignment i i s can often be eliminated by subsumption · loop first case loop s to f a repeat i b if i f then a loop a t endif if it can be shown that the loop will have at least one iteration ie that i f initially then the enclosing if statement can be removed the assignment i b can often be eliminated by subsumption · loop last case loop bs a repeat lo f if i f then for a t a endif · loop middle case loop b b s a op a repeat loop a repeat s s this manipulation is particularly useful w h e n the loop body is an appropriate conditional statement for example if i m l then if the predicate is i m l performing a loop first case manipulation on the second resulting loop is often valuable · case split a s s u m e there is an assertion of the form p implies q where p is a predicate about array subscripts and q an assertion about array values of the form ar value where ar is an array reference whose subscripts are restricted by p for example i j implies if there is an expression which contains an array reference ref w h i c h matches at then replace ref with then value else ref endif if there is an assignment ref x where ref matches at and x matches value the assignment can be replaced with if not p then ref x endif for example j implies o then will b e c o m e if k then ak o · loop elimination a predicate within an inner loop may be used to select an item out of the intersection of the index sets of the inner loop and outer loop w h e n detected this condition can be greatly i o to ij b a loop by then s endif t b repeat loop a i then i endif b repeat typically the m a x and min expressions evaluate to constants and the assignment i is eliminated by subsumption · loop compression often a predicate within a loop serves to restrict the index set of the loop in this case the restriction can be incorporated into the index set itself suppose b £ f loop to f if i then a endif repeat loop b i tf a repeat or suppose b £ f loop b to f then a endif repeat loop to ib b a repeat · order reduction if an array a is used in a loop on i and all references to a have i in for example the first subscript position then if a is dead following the loop the of a may be reduced as stated here this is a special case of a more general rule for example loop for i o ai j all repeat loop for i · a aj re t · index set shift it m a y be that the set of values a s s u m e d by an index variable if modified will be more compatible with additional transformations loop s tf loop s to fc i ic o repeat repeat · loop fusion adjacent loops over the s a m e index set if data dependency considerations allow can be fused into a single loop the data dependency analysis can be represented by first conventional loops into loops and strip to get back to a conventional loop o n e of the index sets m a y require index set to m a k e it identical to the other x s to f for a a repeat p loop s to f loop bb repeat ret o for ib a j i b repeat s i o a j i b repeat s t f · loop the loop splitting manipulation a loop fusion and depends on similar analysis to loops split strip loop a b repeat s to f for a b red for ib a repeat loop for ib b t s to f s to f i o s to f a pt i o b s b p · p reordering the loop reordering manipulation depends on finding a nested loop set to a and strip in an appropriate way loop bi si to fi loop bj s j a repeat repeat loop for si sj fj a loop j bj sj to fj l o o p to i bi s l to fi a repeat repeat · loop variable elimination suppose t is invariant in loop and di is the change in i as a result of the loop l o o p for i tb s a repeat loop tb i t a repeat t t di s to f the compilation model as hoare has a solution to the problem of producing efficient object code for programs written in a high level language is to have designed the language so that a simple straightforward compiler will produce straightforward object programs of acceptable and efficiency the language should be sufficiently expressive so that most optimizations can be made in the language itself that a general optimizer can simply translate an inefficient program into a more efficient one with guaranteed identical effects and expressed in the s a m e source language this is our approach our model is that a straightforward parser perhaps automatically generated will parse the character string representation of a program into a more highly structured easier to manipulate internal form it is this internal form that is in fact transformed by our transformations at any point in the transformation process w e can the results by use of an or w h i c h will the character string representation of a program w e believe that by applying an appropriate set of transformations to a given source program written in a rich source language we can transform the given program in such a w a y that quite naive code generation techniques will result in very good code it is our hope that this reduction in scope of the code generation problem m a y in fact m a k e possible s o m e real progress toward the automatic or at least production of code generators the point here is that a considerable amount of the work done by conventional code generation can be viewed as transformation where the predicate depends on the target machine ie the transformation may always be a valid one but m a y only be useful for a particular target machine w e have found however that most existing languages do not allow compilation it is an assumption inherent in transformation that there is s o m e subset of the language for w h i c h the compiler k n o w s h o w to generate efficient code for e x a m ple part of the benefit of constant propagation will be lost if the compiler does not generate immediate instructions when one argument of a computation is a constant in our work with existing languages then w e have found it necessary to make suitable language extensions so that the results of our transformations can be expressed it is intended that the algorithm writer however will to the original language the language presented earlier in this paper has been designed so that it contains both appropriate high level features for the algorithm writer such as iteration loops loops and situation statements and appropriate low level features such as labels and let us the previous example of matrix multiply w h i c h w e had transformed to loop loop to at i t w e shall continue this example to s h o w h o w transformations given a rich enough source can in the remaining compilation the underlying representation of an m by n matrix is a one dimensional array of m n items where selection of the ij item of the matrix selects the inj item of the underlying array letting ua ub and uc be the underlying arrays for a b and c respectively we have loop i tq i loop to uc ua ub repeat repeat doing expression simplification and common subexpression elimination within the inner loop body the inner loop body becomes tl i j t i part of the tl computation and all of the t c o m are invariant in the inner loop performing code motion w e get loop t i t i loop i to tl t j repeat analyzing both loops for the computation becomes loop t t t i ii to i loop to j i to tl t by to t tl t repeat the i and j indices are now dead and can be eliminated l o o p to t tg t i i i to i loop for tl tl to t tl t repeat removes the one remaining notice that the index sets of t and t contain the same number of elements thus range testing for t is not needed t o l o o p fo t l l to lo loop for tl tl b to t ctl red t t using loop variable elimination w e can replace tl by t using index set w e can have the t loop final value be zero thus code select t loop b ii tp loop tor t tl to t tl t repeat t t t t repeat scalar eliminates the remaining tl references subsumption and constant computation simplify the t computation and eliminates the inner iteration loop t o l o o p fo t too t t i ft t sg lo loop t t while t ft repeat t t repeat subsumption between loop iterations again simplifies the t computations t i loop z ii to ft t sg loop t t i while t ft repeat repeat eliminates the outer iteration loop t i t t p ft t gt t t w h i l e t ft r e p e a t t t while t repeat finally eliminates both loops t i t g t label outer loop ft t label inner loop t t i label if t ft then to inner loop endif t t ii label then q to outer loop endif the program is n o w in a form where making only reasonable a about the target machine a naive code generation would produce good code by naive w e m e a n that code generation need look only at one statement at a time not that it need not be indeed it is very important that code generation k n o w h o w to handle the obvious special cases · load a register with a constant · increment a register by a constant · access an indexed memory location · conditional transfer of control · application of higher level optimization in order to improve the object code of an existing high level production techniques of program transformation were used this language is a f o r t r a n l i k e programming language designed specifically for the processing of problems the language contains the following features i ability to define n e w character string alphabets computational operations extended to character strings such as character by character addition modulo alphabet size high level operators such as frequency count ability to extend operations to and in general explicit indexing over strings in a replacement statement or conditional statement c o m p l e x relations over strings for use in i statements c o m p o u n d indexing in loop statements and indexing including multiple and parallel indices to study this language w e used a language laboratory consisting of a parser generator and program to construct a model front end compiler for the language laboratory the l a n g u a g e laboratory is a tool designed to in the development of optimization techniques for high level programming languages it is written in b c p l and designed so that experimental optimization techniques can be in for testing and analyzing the laboratory is capable of syntactically analyzing a program a structural representation of the program and that representation into a n e w source program it also provides to manipulate and print the structural representation so that experimental optimization techniques can be quickly implemented and analyzed the laboratory is c o m p o s e d of five parts syntax analyzer working tree and table generator and experiments there is also an interactive c o m m a n d interpreter to with online the laboratory implementation was somewhat language dependent it n o w appears that this language dependence could have been r e m o v e d from all parts of the laboratory except of course the experiments themselves in this laboratory environment w e were able at low cost to study the effect of various transformations on typical source programs our results allowed us to m a k e suggestions for changes in the production compiler the introduction of high level loop optimizations in the production compiler allowed certain critical language constructs to be executed up to a factor of three faster in working with a language not specifically designed to allow transformations we naturally had to consider a variety of other issues these included information target language considerations and processing of high level features all techniques for program improvement require that information about the program and its environment be available although the of this information w a s not a central portion of our work the availability of the information is a the objectives of our study in this area have been to ourselves that the type of questions which need to be for transformations can be by state of the art techniques and to a d v a n c e the state of the art in this area w e have concerned with three major areas i the problem of determining ordering relationships a m o n g array references in loops ordering and their use in optimization and optimization and the general problem of information and propagating it through a program information the language proved to be an target language for transformations s o m e study that several appropriate low level constructs were not present and that the production compilers code generator often many special cases a number of simple changes were m a d e in code generation as a result of this study besides defining and the subset of the language the analysis in code select also m a d e a improvement in the object code we found that specific high level language features can be handled in one of two w a y s d e v o of features or algorithm design the use of a language feature can be replaced by its implementation in terms of lower level language features of features this technique w a s used very successfully in the handling of a large class of complex string assignment operations and predicates over strings it w a s also used to handle logical operations in conditional statements and the processing of array references alternatively algorithms were sometimes to implement certain features this was often machine dependent and was very useful when a given target machine had specialized powerful instructions for example we designed a special algorithm for a like i n d e x function to search a string for an instance of a second string which used the ibm translate instruction and executed approximately times faster than a implemented index function we studied the problem of computation on elements in strings and techniques for performing certain computations one word at a time rather than one character at a time w e studied the problem of providing efficient output for languages using the f o r t r a n run time inputoutput package the techniques developed allowed certain programs to run up to three times faster than they had prior to applying these techniques conclusions the use of transformations appears to be very promising both for high level program optimization and as a model of the of the compilation process obviously much remains to be done initial steps have been taken at information needed to evaluate the predicates in transformations analysis extraction information inequalities affine and c h e a t h a m evaluator considerable effort is still needed in this area and in the specification of the predicates themselves only a little work has been done on the ordering of transformations and optimization transformation although a large number of compilers have been constructed and therefore the software engineering aspects have had to be addressed compilation as an integrated information and transformation system a number of interesting software engineering problems if the role of code generation in a compiler can in fact be reduced as m u c h as w e hope so that production of code generators becomes possible considerable work will be needed in this field the use of a language laboratory in the development of transformation techniques was very valuable a similar but more general and more powerful system should be produced such an effort would have m a n y interesting software engineering problems of its own and would provide a very powerful tool for future research the technology of information and the tools provided by the language laboratory make possible the idea of constructing an interactive program system such a system would allow a user to interact with and to transform his program taking advantage of known of data matrix a is lower left or environment the compiled version of this program will run on a since the transformations would preserve the correctness of his program the user could concentrate on the job of his program so that it would meet his required space and time constraints several people have to our work on transformations we would like to express our in particular to and michael of m a s s a c h u s e t t s computer associates philip apl an a p l m a c h l n e stanford laboratory s u s e l february acm sigplan languages symposium on very high level languages sigplan notices april acm sigplan optimization proceedings of a on compiler optimization sigplan notices allen e and a of optimizing transformations in ed design and optimization of compilers prenticehall david and laboratory beta laboratory final report mass c o m p u ter associates inc december et al evaluator a partial evaluator and its use as a programming tool dept of computer sciences university and transformations some transformations for developing recursive programs int conf on reliable software ieee computer society april te evaluator symbolic notes working paper te and laboratory a laboratory for the study of automatic programming conf proc vol s l transformation s s preserving program transformations second a c m symposium of programming january m optimization global program optimizations phd thesis computer science department university pittsburgh pennsylvania hoare car on programming language design computer science department stanford university december information information about programs mass computer associates inc ca july assignment the assignment of scalar variables to m e m o r y cells mass c o m associates inc january michael inequalities proving inequalities mass computer associates inc ca june submitted for publication affine affine relationships a m o n g variables of a program mass computer associates inc ca accepted for publication by knuth go to structured programming with go to statements computing vol no december lamport parallel parallel execution on array and vector computers proceedings of the on parallel processing august lamport the method for an array computer proceedings of the conference on parallel processing august loops the parallel execution of d o loops c o m m a c m february lamport coordinate the coordinate method for the parallel execution of d o loops proceedings of the conference on parallel processing august transformation transformation of programs in preparation david david and development development of compiler optimization techniques mass computer associates inc c a d d august david and s optimization program and practice proceedings of a conference on programming languages and compilers for parallel and vector machines sigplan notices vol i no march k in a row the k in a row problem mass computer associates inc december david and david development development of compiler optimization techniques mass computer associates inc july replacement on the compilation of the beta replacement statement mass computer associates inc august david and johnson the parallelism analyzer and synthesizer proceedings of a conference on and compilers for parallel and vector machines sigplan notices vol i no march ordering the partial ordering of loops and array references mass computer associates inc december optimization a mathematical theory of global program optimization m and algorithms the representation of algorithms applied data research inc final technical report vol ii development center september analysis mechanical program analysis c o m m a c m september extraction property extraction in wellfounded property sets ieee transactions on software engineering vol no september transformation program transformation xerox palo alto research center september predicates the synthesis of loop closure procedure closure in the computer vol no i february the programming system proc vol pp and language for systems programming c o m m a c m december 
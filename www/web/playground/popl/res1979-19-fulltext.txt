synthesis of resource invariant for concurrent clarke aiken computation laboratory university cambridge mass programs abstract and have developed a proof system for critical regions in their system logically related variables accessed by more than one process are together as resources and processes are allowed access to a resource only in a critical region for that resource proofs of synchronization properties are constructed by predicates called which describe relationships among the variables of a resource when no process is in a critical region for the resource in constructing proofs using the system of and the programmer is re to supply the resource invariants we show that plays a key role in the derivation of strong resource invariants we also develop methods for automatically synthesizing resource invariants specifically we characterize the resource invariants of a concurrent program as of a functional which can be ob from the text of the program by using this fixpoint characterization and a widening operator which exploits our observation on the importance of good approximations may be obtained for the resource invariants of many con current programs introduction and ow have developed a proof system for regions in their system logically related variables accessed by more than one process are together as resources and processes are allowed access to a resource only in a critical region for that resource proofs of synchronization properties are constructed by predicates called resource invariant these predicates describe relationships among the variables of a resource when no process is in a critical region for the resource related methods for verifying concurrent programs have been discussed by lamport lm and pn in constructing and proofs using the system the programmer is required of to this research has been partially national science foundation grant supported by no supply the resource invariants we investigate the possibility of automatically synthesizing resource invariants for a simple concurrent programming language in which processes access shared data via conditional critical regions we consider only invariance pn or safety properties lm of programs this class of properties includes mutual exclusion and absence of deadlock and is analogous to partial correctness for sequential programs correctness proofs of programs are expressed in a proof system similar to that of and to gain insight on the synthesis of resource invariants we restrict the language so that all processes are nonterminating loops and the only statements allowed in a process p and v operations on we call this class of programs pv programs for pv programs there is a simple method for generating resource invariants ie the semaphore invariant method of ha which expresses the current value of a in terms of its initial value and the number of p and v operations which have been executed although the semaphore invariant method is simple to state it is a powerful technique for proving pv programs we show that it is as powerful as the method of l for proving freedom from deadlock the semaphore invariant method however is not complete for proving either absence of deadlock or mutual exclusion of pv programs we show that there exist pv programs for which deadlock mutual exclusion is impossible but the semaphore in variant method is powerful to es this fact this incompleteness result is important because it demonstrates the role of in the generation of powerful resource invariants we also give a characterization of the class of pv programs for which the semaphore in variant method is complete for proving absence of deadlock mutual exclusion the semaphore invariant method is generalized to the class of programs in which tions to many synchronization problems can be ex although the generalized semaphore in variant also fails to be complete it is powerful to permit proofs of mutual sion and absence of deadlock for a significant class of concurrent programs when the generalized semaphore invariant is powerful to prove some desired property of an program is it possible to synthesize a stronger resource in variant is possible than we argue that and that by to generate the semaphore we show that resource invariants are them as fixpoints it invariants which are invariants previously de the resource invariants of an program c are fixpoints of a functional fc which can be from the text of program c and that the least fixpoint of fc is the strongest such resource invariant since the functional fc is continuous the least fixpoint p fc may be expressed as the limit u j this used directly only a finite a good initial characterization to compute of u fc unless number of different states approximation is available cannot be c has or unless for by using c however the notion of of cousot we are able to speed up the of the chain and obtain a close approximation the widening to p fc in a finite number operator which we use exploits of steps our observation on the importance of in the generation of resource invariants although fix point techniques have been previously used in the study of resource invariants la fl we believe that this is the first research on methods for approximations up the convergence of the sequence of to examples are given in the text to illustrate the power of this new technique the language and its semantics are dis in sections and of this paper sections and contain a description of the semaphore in variant method and a discussion of why it is section introduces the class of linear programs and briefly describes how the semaphore invariant can be generalized to this class of pro grams the fixpoint theory of resource invariants is presented in section section contains an account of widening operator and how it can be used in resource invariants the paper concludes with a discussion of the results and some remaining open problems a simple concurrent programming language an program will consist of two parts an part zt in which initial values are assigned to the synchronization variables and a concurrent execution part resource rx cobegin which permits the simultaneous or interleaved tion of the statements in the processes all variables accessed by more than one process appear in he prefix tion part processes rr of the concurrent have the form must where pi cycle s s s s s si is end i a list of conditional critical terminating statement statement statement regions th cycle construct is a non loop with the property that the next to be executed after s ki si of the loop although is the first the cycle simplifies the generation of loop the results of this paper loops eg while loops to allow multiple resources and will not be treated in this also apply to the extension is straightforward paper conditional regions have the form with r when b do a od only variables can appear in the boolean expression listed in b and the r body a of the conditional critical region when execution of a process reaches the conditional critical region is delayed until with r when b do a the process no other proce is using r and the condition b is satisfied then the statement a is executed as an action list let c be an above a program program with the state u is an s where format ordered de is the counter for process and is in the range ki pi s maps the set of synchronization variables to the set z of integers and is called the pro gram we will write bs b in store resulting when the executed in store to denote the value s as will be the sequential statement s of store a is a of an program of program states oo state o has the reflects the assignments made in the part of c consecutive states c is a sequence the so where so and j cr j are related m n pc pc sj n as follows there such that exists an m pc if im i m if pc m km otherwise if statement pc in process m is with r when b do a g jl then bs true and note that concurrency in the execution of an program is modeled by nondeterminism in the tion of successor states if there exists a computation of program c then we say that state o u oj oj is from the initial state of c and write note that the next statement to be executed by process pi in state is always we say that program c is blocked in state o if the condition of the next statement to be executed in each process is false in state a state of c is a state if o is reachable from the initial state of c and c is blocked in state o two statements s and s in different processes of c are mutually exclusive if there does not exist a state the initial state of c in which next to execute in their respective reachable and processes from s are frequently it will be convenient to identify a predicate u with the set of program states which make u true if is the set of all program states then z will be the set of all possible predicates false will correspond to the empty state set and true will correspond to the set z of all program states also logical operations on can be interpreted as set theoretic operations on subsets of z ie or becomes union and becomes intersection not complement and implies becomes a subset of u will denote the strongest corresponding to the sequential a and the u if the predicate u is identified with the set of states which satisfy it then u may be defined by u su theorem let a be a sequential statement a if u vx and uv then sp a u c sp al v b f ul i lo ks of predicates then u ui ui proof see cl u resource invariant proofs in this section we adapt the proof system of and to programs we use the notation of hoare to express the of the sequential statement a with respect to the p and tion q the triple is true p a q iff a p q proof systems for partial correctness of sequential statements will not be discussed in this paper let c be an program and let st be the set of statements occurring within the processes of c a resource system for c will consist of two parts a predicate ir called the resource all free variables of ir must appear in the resource prefix rx of the program c proofs of sequential correctness for each of the individual processes of c for our purposes these correctness proofs are represented by a set vc of assertions and two functions called pre post st vc which give the precondition and post condition for each statement c in the proof to that the proofs of sequential correctness for the individual processes are interference ow we require that the free variables in free the verification conditions for process i do as free variables in for any process j program with the format the verification on with ji xf c is an described in section then the functions pre and post for process pi must also satisfy the following conditions a a ir b pre s c w for j d if s is the conditional with r when b critical aj region then pre s a b a s a ir theorem let be a invariant system for the program c if a is in c and s is the next statement of pi to execute in state then proof see ow u resource invariant systems may be used to prove absence of deadlock and mutual exclusion of an program c to prove mutual of statements s and s in c it is sufficient to give a resource invariant system xc for c such that a a ir is unsatisfiable for c to become exhibit a resource the predicate n a il to prove invariant that it it is system is impossible sufficient to fc such that ki v jl a mb a ir is unsatisfiable local subset of the processes in a similar manner deadlock are blocked in which only a may be handled the semaphore invariant method p and v operations on a semaphore a can be treated as conditional critical regions px is equivalent to with r when xo do xx od vx to with r when true do xl o section we restrict the class of programs and this so that the only statements allowed within processes are p and v operations on we call programs the semaphore invariant method ha is based on the use of aa variables let a be a semaphore with initial value m occurring in a pv program c for each statement si corresponding to a p operation we introduce an auxiliary vari able a which is each time the p operation ment si is executed corresponding similarly for each state to a v operation we intro a variable ai all auxiliary initialized to zero at the beginning c the semaphore states variables are of the program that the predicate ia c whenever c is not executing tion on the semaphore a a p or v opera when auxiliary variables are added to c in this manner there is a simple method of generating appropriate pre and post functions for c let pi cycle the program s c s end i be the and let dd ith process in be the variables functions for for this process process pi will he pre and post be defined dd i d i if s is j associated we refer to the a conditional critical region with auxiliary resource variable dd invariant then system consisting of the conjunction of the semaphore invariants ia and the annotation as the semaphore to c obtained by the system above procedure consider for example a a cycle b cycle pa pa sa sb the va va pv program end end c sa and sb represent the bodies of the critical regions established by the p and v operations and will be treated as null statements in the analysis which follows annotating c as described in the previous we obtain resource ra a cycle al a a a a a ll a aa q with end l r when true sq aa o b cycle a a a a a all sb with r when true a a oc the invariant ia for semaphore a is since i a the predicate is unsatisfiable it follows sb are mutually exclusive is free from deadlock since is also unsatisfiable that statements sa similarly we see that the predicate and c incompleteness of the semaphore invariant method the incompleteness of the semaphore invariant method is best explained by means of progress graphs d the progress graph is a graphical method for representing the feasible states of a pv program consider for example the program c al bl a cycle b pa pb pb va pa vb vb s va a feasible computations of this program can be re presented by a graph in which the number of tions executed by a process is used as a measure of the progress of the process eg b progress ab for process b a the dashed line represents a computation of the process c in which process a executes pa b executes the pb region and of the graph represents those program states which fail to satisfy b such states the semaphore invariants for are called states a or the point labeled x in the graph is a state the state x is reachable from the initial state of c but further progress for either process a or process b would violate one of the semaphore invariants ie both processes those points in the graph states are blocked of c which are not reachable from the origin initial state by a path composed of and vertical line segments which never cross an region by a valid computation sequence of c are called points states all are unreachable the point labeled y in he graph is an example of an feasible point if the program c were started in state y the semaphore invariants would not be violated next consider cobegin a cycle pa vd end b cycle pa vd end the pv program c pb pd va pc pb pc vb pd vb va vc vc the progress graph for c is shown on the next page note that of program deadlock can never occur during c let be the semaphore execution invariant system for the program c thus if auxiliary variables are added as described in section a c c b c a d b a a the invariant i will be given by i ­ acc c c c bl ­ ac ac ­ ­ ­ o it is not difficult to for absence of the state z in which show that deadlock the condition is satisfied ao al a al al bo bo bl bl bl co cor co c c by do do do dl do thus absence of deadlock cannot be proven by of the semaphore invariant method the state which satisfies is an example of an reachable feasible state in which each process c is blocked we will call such states trap means z states theorem the invariant method s complete for proving deadlock freedom for those pv programs whose progress graphs do not contain any trap states graph state must show proof let c be a pv program whose progress does not contain of c in which any trap states thus any all processes are be reachable from cs initial state ie t be the semaphore invariant system for c we that the condition is unsatisfiable if and only if deadlock is impossible for the pro gram c clearly if is unsatisfiable than deadlock is impossible thus assume that is satisfied by some state u by con of the predicate d all processes are blocked in state g since o is reachable from the initial state of c it is a deadlock state a similar characterization may be given for mutual exclusion how can the semaphore invariant method be to handle trap states since trap states correspond to holes in the un feasible region of a progress graph a method based on is of investigation we return to this question in section although the invariant method is not complete for proving absence of deadlock or mutual exclusion of pv programs it is a powerful tool for proving correctness of pv programs which occur in practice as the examples of ha demonstrate additional evidence for the power of the semaphore invariant method may be obtained by comparing it to other methods which have been proposed for proving deadlock freedom of pv programs we prove for example that the semaphore invariant method is as powerful as the method of l if a pv program has a reduction proof of deadlock freedom then it also has a proof using the invariant method reduction is a technique for decreasing the number of interleavings of statements which must be considered in the proof of a concurrent program let c be a concurrent program and s a statement contained in c the reduction cs is the con current program obtained from c by making s into a single ie action to prove that program c has some pro u it is sufficient to produce a sequence of programs cc c cn and statements sl sn such that for il ll if ci property has property u u then also cn trivially has property u gives a class of statements called tions with the property that if c is a concurrent program and s is a then c is iff cs is deadlock free for pv programs have the form s sn where are p operations si sn are v operations and sz sn can always execute in view of con graph proof trap above of the final of deadlock states we will assume that the progress program cn in a reduction freedom does not contain any lemma if the c a trap of the trap state of a state then the progress cs also a proof let u be a trap state for the pv program c by definition u is an unreachable feasible state of c in which every is blocked let cs be a where ss has the form described above assume that u is not a trap state for cs if o were a feasible state of cs then it would be a trap state of cs since every computation of cs is a computation of c thus must not be a feasible state of cs since s sn must be executed as an atomic statement in cs the process containing s must be blocked in state g while to execute one of the statements s s sn since by definition of a the statements s sr sn can always this is a contradiction u theorem has a deadlock freedom using the method it also has a proof of deadlock freedom using semaphore method then the proof assume that co has a proof of dead lock freedom using the reduction method then there exists a sequence of where cn is free from deadlock and does not contain any trap states by lemma co must also be free from deadlock and not contain any trap states by theorem it is possible to prove that co is free from deadlock by means of the semaphore invariant method u generalization method of the semaphore invariant since a large class of synchronization tech can be modeled by counting operations on shared variables the class of linear programs is of particular interest the conditional cal regions of a linear program have the form with r when bx xr where the variables resource r xl do ax x xn x xn belong to the condition bx x xn is a truth functional combination of atomic formulas of the form o the body ax x xn is a series of assignment statements which increment the shared variables xn eg xl xl bl xx b n xn bn note that are special cases of linear programs many other standard synchronization problems including the philosophers problem the readers and writers problem and the problem can all be expressed as linear programs arguments are given in sc ag that linear programs are universal and in their power to express synchronization constraints for concurrent programs it is also to prove that mutual exclusion and deadlock freedom are undecidable for this class of programs we briefly outline how the semaphore invariant can be generalized to linear programs let be an program for each conditional critical region si in c we introduce a new auxiliary variable which counts the number of times has been executed thus the algorithm of section may be used to generate pre and post functions for c the resulting annotation of c will be c si called the canonical annotation let an be linear critical form occurring region of to denote in the condition of some c we will use the notation the change in value of h a caused hs by the execution is given by of statement s note that j let where o gives the initial values of the synchronization relationship variables then the must hold j if no process region for r is executing a critical although the generalized semaphore invariant is sufficiently powerful to permit proofs of mutual exclusion and absence of deadlock for a significant class of linear programs it fails to be complete for exactly the same reason as the original semaphore invariant a fixpoint theory of resource invariants let l be the set of program states and let f xz if and then u is for the functional f if u is a fix point of f and u v for all other fixpoints of f then u is the least of f f if for every chain co of subsets of z m j u j a v is if f is continuous then which s given co by pf u f false j f has a least fixpoint where u and fl ff u the resource invariants are fixpoints of a functional obtained from the text of program of an fc c let program c which can be c be the xe resource cobegin rx we assume that s has the form c contains k critical and that the ith critical si with r when bi ai regions region the algorithm of sections and will be used to generate the pre and functions for c let z be the set of possible states of c and let fc z z be defined by k v i j where initial the predicate state of c describes the lhe fc s a mapping on x thus fc which is by ifc u j has a least proof the continuity directly from the of fc follows of sp u theorem c are for c all resource of fc also invariant lr of s a proof c clearly let ir be a resource invariant we must show that for ir by condition a in the definition of a resource invariant system condition e we see that for ir by ai it follows that for i k ir hence k v il so k v il ir ir thus every resource invariant ir of fc since is a fixpoint k of c v v il is a fixpoint we have thus and for i k by construction of the pre and post functions also have we by monotonicity it follows that for i k or equivalently that pre si a bi a ai thus is a resource to the canonical annotation invariant corresponding given in section theorem d proof let ir cs we show that ir is a fixpoint of fc and that since follows that is the least ir fixpoint of it c a ir clearly let il then either io such that or ir or there exists only the third case is interesting uc if then there is a state such that since there is a computation oi of c with because and is also a computation of c and b let oc ir then there exists a computation rr in which we prove by induction on r that since the basis case is true assume that for all computations of c let be a computation of length r then there exists o and o and such that o r thus f it follows that co ir u i n theorem the resource system con of and the canonical annotation is relatively complete for absence of dead lock and mutual programs proof system we prove that for the resource the condition is deadlock is is unsatisfiable impossible clearly if then deadlock is impossible we must show that if is satisfiable then there exists a state d the initial state of c c is blocked let satisfies since which is reachable from in which every process of be a program state which cd satisfies it follows that and also that each process of c is blocked in state ad since state ad is of c reachable from the initial thus dd is a deadlock state for the program mutual exclusion the reader c the proof of completeness is similar and will be left for to u theorem shows that strongest resource invariant for next theorem is important because method for improving approximations is the program c it gives a to the theorem lc fc then m if l is a predicate such that u fl proof it is easy to show that for all fl false thus m u f false j q u fl j u to illustrate theorems the following solution to problem we consider the mutual exclusion ao bo resource cobegin a cycle al with sa a with end b cycle bl with sb end b with r when bo do od r when true do aa od r when ao do od r when true do bb od adding auxiliary of section to we obtain variables generate and using the algorithm pre and post functions resource a b al cobegin a cycle a bl b al with r when bo do od sa a with r when true od do end b cycle bb bl with r when ao qo q sb b with r when od end true do in this case the function c s ao aa b z bl vj bo aj true bl aj true aj since ab is and in statement guess for a resource invariant in statement ab an is ab obvious it is easily checked that ir so that ir is a fixpoint of fc since d is unsatisfiable the invariant ir prove absence of deadlock for c ir is not strong enough however exclusion of statements sa and may be used to the invariant to prove mutual sb since the predicate m is satisfiable by using resource theorem invariant we may compute let the strongest l fl fl then l since we see that u io bo aq using the resource invariant it is easy to show that the predicate m is unsatisfiable are mutually thus exclusive the statements sa and sb note that theorem can only be used to obtain if program c has a finite number of different possible states or unless a good approximation is already available to in the next section we will examine more powerful techniques for obtaining strong resource invariants up the convergence of fixpoint tech for resource invariants for linear programs of cousot c may be used to the widening characterized by the following the notion of to speed up operator is two properties a for all predicates u uv and v c uv u and v b for any chain of admissible pre the chain defined by v uo is eventually stable ie there exists a such that for k in this paper the predicates are the convex sets of qm where q is the set of rational numbers and m is the number of resource variables belonging to r the widening operator that we use is a modification of the one used by cousot c let u and v be convex sets then u and v can be represented u as conjunctions and v h ad j kl k where each is a linear inequality of the form we further s assume that the representation of u and v is minimal ie no conjunct can be without changing u or v we say that two linear inequalities y and are equivalent k if they determine the same half space those yj of uv is the in the representation conjunction of u for of all which there is an equivalent in the representation k of v thus the widening operator out all those constraints in the representation of which do not occur in the representation of v u chain we now describe the strategy for since the predicates in the may not be convex sets let where cv is the convex hull the sequence is a chain of convex sets the sequence i t will be used in a good approximation to the strongest resource invariant for r and is defined by ob t j where t and h j theorem a each it can be in a finite of steps number b it for t c the sequence it s a decreasing ie a chain in z proof of a by condition tion of a widening operator the ho hi h must eventually in the sequence there exists it ak k j such that proof of b co u il co c u io m c u g co c j t c t ­ j c it proof of c let convex sets we write conjunct in v there in u we prove by tl k u and v be poly if for every is an equivalent con induction on k that basis step tl o induction step assume tl t k h then tl el kl k tk note that implies thus ko it ko and the sequence in practice is a decreasing when computing chain in it we stop generating a predicate the limit the predicates is found h h uj such that as soon as ht h lf of the chain fails for c then additional to be a resource predicates in the t may have to be j of it provides computed a procedure thus the may be used to obtain better approximations to the strongest resource invariant we demonstrate resource invariants this method by considering al cobegin a b cycle cycle pa pa sa va sb va of synthesizing the program end end c discussed in section is given by the function c in ao vj v sp a al j a al a aj while methods finite c is quite simple and can be handled of section there are potentially number of states and the chain by the an in does not converge tions it by computing the sequence however we obtain of note that is a resource invariant for c that i implies the semaphore invariant i a in the proof of absence of deadlock and mutual exclusion in section and used for the pv program the incompleteness method i is strong deadlock freedom the causes a problem since used in section to of the semaphore invariant enough to permit trap state z i contains a proof no longer the of bd d the unreachable graph of the b feasible program which is not satisfied points in the progress by as a final example solution to the readers priority bh processes and one writer we consider and where there process the standard problem are two reader eg al bo co do eo resource rr rw aw al bl a b c d e cobegin reader reader writer each reader process has the form reader i cycle ai with r when read b with r when l end do a ail o true do od the writer process is writer c with r when true do ccl od d when do o e with r when true do q end note that auxiliary d and e have been the number of times variables added to critical al bl a b c r the program to count regions al bl a b c d and e are executed the predicate generated by our approximation procedure is o ab ab this predicate program and of deadlock statements is a resource invariant for the is sufficiently strong to prove absence and mutual exclusion of read and write open problems if a concurrent program contains a large number of critical regions then the combinatorial explosion in the number of possible states which must be considered by the approximation procedure of section may prevent convergence to a suitable resource invariant we are currently techniques for this combinatorial explosion two techniques which seem promising are a preprocessing the program to obtain information about which states can follow a given state during a computation of the program for example in the readers and writers problem assume that reader is waiting for entry into critical region al an that if reader executes critical region b it is unnecessary o check whether reader is enabled to enter al since execution of i not affect the value of aw a similar analysis is used in obtaining efficient tions of conditional critical regions sc b construct the program and its correctness proof simultaneously although the programmer may not precisely know the resource invariant for the program he is writing he may be able to deduce a first approximation to the invariant from the problem specification in this case the technique of sections and may be used to the approximation techniques for deriving correct concurrent programs have been investigated by van and a number of additional questions arise re the power of the generalized semaphore invariant of section and the fixpoint methods for generating resource invariants in sections and it would be interesting to compare these proof techniques with other techniques which do not use resource invariants eg the church approach of rosen r and the reach ability tree construction of ke al so it is not clear how the techniques of this paper generalize to synchronization methods such as path expressions ha for which linear are not explicitly given currently the author is building an automatic verification system for concurrent programs based on the ideas in this paper this system will ex the synchronization skeleton of a con current program and use the techniques of sections and to generate the appropriate resource invariants the examples of section were all obtained with the aid of this system references ag t a complete model for repre the coordination of asynchronous processes computer research report john university md bh prenticehall p nj system principles cl clarke e foundations m program invariants as th annual symposium of of computer science c cousot p and cousot r static of properties of proc nd international symposium b ed april on c cousot p and n automatic discovery of linear among vari ables of a program proceedings of th acm symposium on principles of languages d fl dijkstra e w sequential processes programming languages g ed academic press ny l and n nondeterminism the correctness of parallel programs department of computer science mellon university and ha communicating a n synchronization of com processes ca cm ha a n path expressions of computer science carnegie mellon university de h hoare c a r towards a theory of parallel programming operating systems c a r hoare r h ed academic press ke models science university r m generalized for system verification department technical of petri nets as computer report z la van a and derivation of strongly programs research correct report m formal parallel l r j reduction a new method of proving properties of systems of processes proceedings of nd acm symposium on of programming lang lm lamport l on software proving programs engineering the correctness of ieee transactions ow pn r approach s and d verifying pro of parallel programs an axiomatic ca cm a the temporal logic of th annual symposium on foundations science november programs of rosen b k correctness of parallel grams the churchrosser approach theoretical computer science sc h a on the efficient of conditional critical and the construction of monitors informatica ac ta 
an assertion language for data structures a cook and c university of in this paper we wish to consider the problem of proving assertions about pro grams that construct and alter arbitrarily complex data structures in recent years several papers have been written on the subject of proving assertions about such programs however the class of data structures considered has generally been a proper subclass of the class of all data structures such as the classes of linear lists or trees burstall discusses the problem of what he calls distinct von lists and distinct trees j extends approach his approach is likewise basically but is applicable to more general data structures restricts his attention to simple lists noting the problem of providing a complete framework for correctness proofs if one attempts to handle very general data structures morris discusses the question of designing a programming lan guage for general data structures in order to facilitate verification of programs written in such a language provides a set of axioms for the class of data structures in which for instance two data structures are equal iff they are equal our approach is in that the domain over which we permit program variables to range is the set of all data structures where intuitively a data structure is just a set of primitive data items say integers together with a set of relations on these items our intention in this and papers is to define a suitable assertion language for these data structures to prove that this assertion language is adequate to describe all reasonable properties of programs manipulating data structures to define axioms in the style of hoare which describe the effect of program segments written in a suitable programming language on data structures and finally to prove that these axioms are correct and in a reasonable sense complete thus our intention is to provide a complete framework for describing arbitrary data structures about programs and proving assertions that manipulate them the question we wish to investigate in this paper is that of describing an adequate assertion language and describing the criterion of adequacy itself to illustrate the problem consider a class of programs in which the domain of all vari ables is the set of integers these pro grams have been often considered in studying the correctness of programs and the assertion language used is usually the lan guage of number theory formally this is a language of the first order predicate calculus in which the constants are the arithmetic operation symbols and symbols for equality and inequality how ever one might choose the sim language of presburger arithmetic instead in which plus is the only operation symbol this has the advantage of being the language of a decidable theory and one might at first think it appropriate to use with a simple programming language in which plus was the only operation symbol able however a little thought shows that presburger arithmetic is not adequate for all programs for even such a simple pro gramming language because for example a program to multiply by repeated additions can easily be written but one can prove that the multiplication relation x yz is not expressible in presburger arithmetic the question then is the following what criterion must an assertion language satisfy in order to be sufficiently expres to describe the programs for which it is intended we suggest that a necessary condition is that the language be able to express any relation computable or partial computable by one of the programs nor this means the assertion language should be able to express the recursively enumerable relations over the domains of the program variables and in this case we shall say the language is strongly expressive in the case of programs about integers first order number theory this criterion since all recursively enumerable relations and in fact many more relations over the integers are expressible in the language in the case of programs which cons and alter data structures however it is not at all obvious what sort of assertion language is most useful and it seems to be even less obvious whether or not candidate assertion languages are adequate in the sense defined above in this paper we describe an assertion language for programs which construct and alter general data structures we define precisely the notion strongly expressive discussed above and prove that our language has this property a related notion of adequacy for assertion languages is given in cook in the context of discussing the complete ness of axioms for program proving our mathematical model for a data structure will be a data graph similar to the ones described in roughly speaking a data graph is a finite directed graph whose arcs and nodes are labelled with nonnegative integers intuitively the labelled nodes of the graph correspond to primitive data items and the arcs correspond to the relations between them it will be convenient to assume there is a special undefined node fi in the graph more formally we have the following definition a data graph consists of a finite set s of no wa node r c s undefined node together with a function d s n where n is the set of nonnegative integers and a transformation t s x n s such that for each a q s fi for all but finitely many i q n and fi for all i c n of course if a is a node in s then da is the label of a the intended meaning of b is that the unique arc labelled i from node u leads to b if q we can think of this as saying there is no arc labelled i coming from node a thus in a single data graph no two arcs coming from a given node can have the same label we now describe the assertion language l intended for describing and proving pro of data graphs the language l is a first order predicate calculus language with three sorts of variables the sorts are first variables for graphs denoted by etc second variables for nodes denoted by and third variables for nonnegative integers denoted by the operation symbols are datum and next where is intended to mean ordinary addition of integers and datum is a two place operation with ments of type node and graph respectively and is intended to be the label of a in g next is a three place operation with arguments of type node nonnegative integer and graph and is a node which is intended to be the node in g at the end of the arc labelled i coming from the node a in the graph g thus if then in the graph g if a is not in g then o and for all i the constant symbols of the language l are of sorts node integer and integer respectively the predicate symbols are e and where a s g is intended to mean the node o is in the graph g and can indicate equality either between two integers or between two nodes the s can be defined and the relations in l in the usual way for example ij u we will use the notation for this is motivated by common array we will use the notation notation for and for equality between graphs is definable language so we may also write a b u in our ab in the standard interpretation for l the variables of sort node and the of sort nonnegative will each range over the domain n of nonnegative integers a standard node will mean simply a nonnegative the cons symbol q will be interpreted as o the variables of sort graph will range over the domain consisting ml data graphs whose nodes are nonnegative integers see the above definition of data graph a member of this domain will be called a standard data graph the cons will receive their a formula a in l with no free variables is either true or false under this standard interpretation if the formula a has free variables al gp of the indicated sorts then a expresses a relation ra over standard nodes nonnegative and standard data graphs as follows am i p holds iff a is true in the standard interpretation its free variables are interpreted nodes integers and graphs when as the ln cl cp graphs referred we assume nodes and data to are all standard since there is no in the language l for expressing equality between nodes and integers such as q i which would be one can show that all expressible relations ra are invariant under of nodes precisely say that the relation we i ng gp on nonnegative integers and data graphs node invariant iff for every permutation t n holds iff in is gp ng holds where is the data graph formed from gi by renaming the nodes according to n and are isomorphic we will say that data graphs g tions which there here are two examples of taken from the existing can be expressed in our useful rela literature language u at r means that is an arc from a to d in g there is only ith a means that a path arcs from a to b in g along in order to define precisely the notion of strongly expressive discussed earlier we need to assign numbers to standard data graphs this can be done in any standard way see the appendix let denote the number of g then corresponding to any relation r on nodes nonnegative integer and data graphs there is a relation r on non negative integers such that a a l l cl ll data graphs gi gp such ff al gp holds for some that gi s i p recall really nonnegative that r is recursively that standard integers enumerable nodes are we say iff r is enumerable and r is recursively in the usual sense we note that the examples a and a given above are recursively enumerable relations the fact that l is strongly expressive is in the following theorem theorem every recursively enumerable ra l on nodes nonnegative integers and graphs is expressed by some formula in l this appendix theorem is proved in the we describe now a simple programming language l for manipulating data graphs the variables identifiers will coincide with the variables of l except there will be no graph variables thus variables will be of sort integer denoted by etc and sort by etc variables are not declared node variables are automatically to o integer variables to o in forming expressions in l other than those appearing in assert statements graph variables are not the program can manipulate only one graph at each point in time namely the graph which we will call b whose representation is currently in storage of course this graph need not be connected and it can have several different components which we think of as linear lists trees etc as we shall see these components can be named by the programmer in assert statements integer expressions of l are the integer terms of l with graph variables deleted for o il and a integer expressions is understood to mean is under to mean where b is the present above graph in storage as explained node l ple q a expressions expressions are the es deleted ai node terms of for exam are all node boolean expressions are the quantifier free formulas of l with graph variables deleted for example il ai are all boolean expressions conditional while statements are as and compound assertions have the form assert p where p s any formula of l ables may be included in assertions the variable b will always be the present graph defined may introduce assertions above but the programmer other l l apl a s in his for instance he may wish to keep track of the values of b or its at various points during execution of his program assignment statements are of two sorts integer and node integer assignment statements are of the form i e or e where i is an integer variable e an integer expression and o a node expression node assignment statements are of the form a o ae o or u new where a is a node variable e an integer expression and o a node expression the statements of l have the one would expect from algol although the node assignment statements require some explanation the statement a o has the effect of a normal assignment statement causing the node variable a to assume the value of the node expression o but the structure of the present graph b is not changed on the other hand effect of the statement ue o is to change the graph b so that arc number z coming from node a now leads to node z where t and are the values of the integer expression e and node expression u respectively finally the effect of a new is to bring a new node into the graph b and to let the variable a refer to it this new node a will initially have datum o and all its arcs leading to q we can assume program of l the initialized to gram segment below graph b has previously storage that for a complete graph b in storage is however for the pro we assume that a data been placed in as an example to illustrate l present a simple program segment to reverse a linear list see burstall we we assume that initially al that is that one a to q by following the graph consisting to q forms a linear assumed initially can get eventually from only arcs labelled o of the path from a list the node f is to be q ba u i t end figure shows the effect of the program on the input before execution of the program segment is during execution of the program segment at the start of the while loop and after execution of the program segment is terminated the only arcs we show are the arcs labelled o of the program execution s a during execution e el e after execution representation of of reverse program figure below we repeat our program to reverse a list together with initial and final assertions note that the graph variable b may appear in assert statements and it will always refer present graph b in storage in addition the free graph variable a is introduced in the first assertion to remember the initial value of b by b a initially in the final assertion the value of a is unchanged but of course b now refers to the final graph in storage which is the list thus the first assertion says among other things that b is a linear list and the final assertion says is the reverse of a b keep list the free variable track of the first the o is node introduced to of the original is merely that the list is linear the asserts that the arcs have been by the program the assertions do not include the fact that the program terminates nor do they include the obvious fact that arcs other than those labelled o are unchanged by the program assert q while a z fl do t ao f assert u nl given sufficiently powerful proof methods about data graphs it is possible to prove this program is correct relative to the assertions this means that if the initial assertion holds before execution of the program then after execution assuming it terminates normally the final assertion will be true in a future paper we will present rules and axioms of the sort used by car hoare sufficient to carry out such a proof and further prove that these axioms and rules are correct and in a reasonable sense complete one of the assertion language presented in this paper is evident from the example given formulas to describe even what might be considered simple programs tend to be long to this we can offer both a partial solution and a partial our assertion language is designed to be able to describe arbitrarily complicated data structures not just subclasses such as lists or trees in fact we have proved that it is powerful enough to describe any such structure it is therefore reasonable that assertions written in our language are going to have to be longer than equivalent assertions in a language specifically designed for a particular application in our language the programmer not only has to out exactly what data structure he is about but also define pre the functions he expects to compute such as reverse his program in other words there is an obvious price that has to be for the generality of our language however this price can be because of the basic theorem of this paper the programmer is able to express in our language any recursively enumerable relation over the domains of the variables that is for a particular application say lists the user can add to the basic language useful abbreviations such as linear or see burstall or which stand for expressions in l and thus make his tions both and more easily under further he can add recursively enumerable predicates to describe useful functions such as reverse the situation is analogous to say number theory developed in a formal lan guage in which only and are primitive typically one would add non primitive predicate symbols for sz is a prime and i which would be defined in terms of the original language and make descriptions easier of course in other situations it is too much to hope that simple predicates can be so defined to describe programs that treat complex data structures in a complex way in such cases complex assertions seem regardless of the language the essential point of this work how ever is that we can prove that out assertion language for data structures is enough so that any property of a program that structures can be expressed in the language appendix theorem able every recursively gp on nodes nonnegative integers and data graphs formula in l is expressed by some the theorem is proved by showing that l is capable of describing the computation of an arbitrary single tape turing machine z see for descriptions and terminology regarding turing machines for convenience we assume that z has tape alphabet with o representing a computation of z is coded by a large graph g an tion i of z is coded by a node a of g as follows the string of tape symbols is coded by datum k for some k with q for all i k the number of the currently is and the state scanned square number is the relation asserts that if u codes an description of z then b codes the description which follows after step of computation of z this relation can be expressed in l as a finite tion over all q of one z of formulas aq u v aq for example if if z is in state it should print then q meaning that qr scanning symbol sv then st and assume state aq u i fst aq is defined similarly of q for other kinds the relation asserts that if a codes an description of z then this will lead to an accepting ie terminating computation of z coded by y this can be expressed in l as follows where z qf is the unique accepting state of now we are in a position following lemma to prove the lemma every recursively enumerable in on nonnegative integers is expressible in l proof let z be a single tape turing accepts the input il in iff in holds we assume that the input encoding uses unary notation the initial tape configuration for input il in is the string so that the n where ii indicates ol of the symbol and as a the relation in ag asserts that i o is the used node a in the graph g codes the initial description of z with input input can be expressed l as follows in ag u datum o l ii i ­ datum c here the equation that square number one u scanned and indicates the tape is being o indicates that z is in state zero which assume is the initial state thus we in g this completes the proof of lemma we now give a precise way of assigning numbers to standard data graphs a data graph g is defined by the finite set sg of all such that b d and either b z r or i o the last condition that s is finite g but every node a z g of g occurs in at least one ple we define k and m p i where pi is the ith prime and tl tk are the of sg in order of increasing number unfortunately the relation g is not expressible in l because there is no way in l to talk about nodes as numbers however the relation meaning g for some g isomorphic to g is expressible in l more generally we have lemma let the relation hold is a t n n such that i i s j s n and gj then gn is expressible in l proof to al the idea is to assign numbers nodes in the gi by creating a graph h with a base node y such that y has precisely one arc in h to each of the nodes in g u u g u a p l an the number of the arc to a node a is the number to the node the relation holds iff can be found which makes the g and the ui have the right numbers to keep the notation we will the expression for gn only for the n p thus give case f here is the of prime expressible in of g relations l by lemma notice above pj in the that the are all theorem can now be proved as follows let g gp be recursively is a formula enumerable by lemma there gl gp in l which expresses the relation r let express the relation then the formula jl gn defined in lemma bc expresses the relation r burstall correctness structures rm some techniques of programs which machine intelligence for proving alter data cook sa axiomatic and semantics for an algol fragment course notes for s dept of computer science university of march m and hoare car an axiomatic basis fo computer programming october the t correctness manipulating data structure no laboratory university of berkeley september of programs research california operating thesis ms verification on structured data mit february of programs morris verification oriented language design technical report of computer science university of california berkeley december dept schemes sciences al data graphs and addressing journal of computer and system june pp ta data axiomatic approach memo august structures an automatic programming and inc 
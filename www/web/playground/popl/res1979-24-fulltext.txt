data of extended abstract john h reif computer science department university of new york abstract data flow analysis is a technique essential to the compiletime optimization of computer pro grams facts relevant to program are discovered by the global propagation of facts obvious locally this paper extends flow analysis techniques developed for sequential programs to the analysis of communicating concurrent processes introduction we consider a set of concurrent processes each sequentially executing a distinct program and communicating by the transmission and of messages by it is meant that there is no interference between processes by shared variables interrupts or any other synchronization primitives beyond the message primitives the processes might in fact in the same machine various channels are available for cation between processes and each channel has a unique process which is the destination of messages transmitted through this channel the communication between processes is static if the channel arguments to message primitives are constants and otherwise is dynamic we consider both these cases in the usual semantics for message communication the process a message need not wait until of the message and thus a queue of messages is associated with each channel in a more restrictive semantics proposed in hoare the of a message m is required to wait until a of of kl we are interested in data flow analysis of communicating processes the discovery of facts about processes and propagation of these facts across process boundaries an analysis problem of particular interest here is reachability can a given program statement ever be reached in some execution reachability is perhaps the simplest of data flow analysis problems section describes our flow model for a system of communicating processes in which the control flow through each program is represented by a flow graph this model allows for all executions valid in the usual semantics of communicating processes but also may allow for additional spurious executions of course a statement unreachable in our model is also unreachable in the usual more powerful semantics unfortunately we show in section that testing reachability in our flow model is recursively undecidable using a reduction from state reachability of machines in the case of static we show that testing reachability in our flow model is reducible to and from in petri nets which has shown to require at least exponential space infinitely often nevertheless we have developed polynomialtime algorithms for approximate solutions to analysis problems as an aid to our flow analysis we define in section a special acyclic directed graph called an event spanning of each graph containing a spanning tree flow graph as well as certain edges called message links connecting pairs of transmit and receive statements between which a message may be sent if no event spanning graph exists then some program statement is unreachable message may be sent if no event spanning graph exists then some program statement is unreachable section presents a linear time algorithm for constructing when possible an event spanning graph for the case of static communication in section we describe an iterative technique for data flow analysis of communicating processes with communication which generalizes a technique for data flow analysis of sequentially executed programs due to and unman their algorithm repeated until convergence a pass through the flow graph of a single program in topological order of its dag directed acyclic graph our proposed algorithm a pass through all the flow graphs of a set of communicating processes in topological order of their event spanning graph section extends our data flow analysis to the case of dynamic communication we present an algorithm which builds an event spanning graph while simultaneously performing data flow analysis section concludes the paper the flow model for communicating processes we describe here a flow model for a system of communicating processes let symbols denoting communication c be a set of channels each process p sequentially executes a distinct program represented by a process flow graph g each node corresponds to a single program statement the edge set consists of pairs of nodes between which control may transfer an execution is a path of g beginning at the start node s we will distinguish a final or exit node from which control may be considered to exit example s qn l n the above flow graph has execution path s nl n nl n among others the state local to the process p is specified by a program counter pointing to the currently executed program statement the value bindings of the program variables local to p and the message queues for channels with destination p to be described program statements include assignment statements of the form xa where x is a program variable cal to p and a an expression with the usual effect of setting x to the result of evaluating a a transmit statement of the form the first argument al must evaluate to a message channel cc c and a evaluates to the message to be transmitted say m the message m cannot be a pointer value but is otherwise unrestricted in particular m may be a communication channel the second argument a may be absent in which case some fixed default message is transmitted a receive statement of the form where the argument a evaluate to a communication channel and x is a program variable local to p assigned the value of the message received we assume no start node of a flow graph is a receive statement empty statements will also be allowed control statements are not found in n since the control flow is specified in our model by the edges of flow graph g the sets of program variables local to distinct processes are disjoint and are assumed to have no shared values thus there is no interference between processes except that induced from our message primitives an event is the execution of a statement by a process and will be assumed to occur it might be and by other events and might also occur simultaneously with others a sequential execution of a single process flow graph g is a total ordering of events resulting from the sequential execution of the statements occurring in an execution path of g given process flow graphs gl gr execution in our flow model is a partial an ordering of events e in which those events associated with any given process flow graph gi form a sequential execution of gi and such that s is consistent with the semantics of the message primitives transmit and receive as defined below intuitively ee if event es event e if es is an event resulting from the execution of statement receive a and to channel c then e must be by a unique event e c resulting from the execution of a transmit first argument evaluates to channel c and whose second argument evaluates to the message received in addition we assume that if a process sends two successive messages ml and m over a channel c they arrive in the order that they were transmitted hence if are events resulting from the of and ele se are the corresponding message events ee implies el ez no further assumptions about message behavior are made note that the resulting semantics are nondeterministic two simultaneous message by different processes over the same channel must arrive in sequential order but we make no assumptions about this order an operational semantics for communicating processes is specified by for each channel a message queue qc listing the messages transmitted but over channel c a receive statement has the effect of deleting the message m at the front of the appropriate message queue and evaluates to m the order of messages appearing in the queue need only be consistent with our assumption that successive over a given channel from a given process be received in order of transmission complexity of reachability in the flow model a program statement n is reachable if it appears in some execution in our flow model in this section we consider the complexity of testing reachability in the general case of dynamic communication it will be shown that the reachability problem is undecidable even in the case of a static communication where the channel arguments to all transmit and receive statements are constants testing reachability requires exponential space infinitely often a machine is a finitestate automata augmented with a pair of counters which may b e and tested for zero the halting problem for machines is known to be recursively our proof that reachability of program statements is undecidable a simple recursive reduction from the halting problem for machines this proof exploits the ability of a single transmit statement to communicate over various channels depending on the evaluation of its channel arguments theorem reachability is undecidable flow model of communicating processes in the proof consider a machine s qo qf cl c with state set s initial state final state set of instructions jl and counters cc associated with each state qf is an instruction of one of the following forms increment iq where in state q the counter ci is by and state q is entered i q where in state q the counter ci is by and state q is entered i where in state q if counter then state ql is entered and otherwise state q is entered a computation begins in the initial state qo with both counters set to o computations resulting in transitions to undefined states or negative counters are undefined the computation halts at state qf to simulate this machine we build a process p which to and from itself on channels cl c that is p is the origin and destination of all messages the flow graph of p is g initially the message queues qc q and q are empty associated with each instruction iq cj is a subgraph of g which simulates this instruction we shall claim that if ci contains the integer k zo then k if iq increment is of the form i q then g q hence an execution of q results in the addition of to if iq i q then is of the form q and so an execution of q results in the deletion of some if this message queue is not empty and otherwise if is empty then the process p if iq q i ql q then is of the form transmit x p a transmit x l d it may easily be shown that if is empty on is reached and otherwise f ql is reached qz in either case the queues are to their state just before execution of n q hence the node is reachable in some execution of p just in the case the given two counter machine next let us assume the channel arguments to all transmit and receive statements are constants so that the communication is static with this restriction there is a strong to a synchronization structure called a petri net in fact we can show that reachability of statements in this case is polynomialtime reducible to and from of petri net markings a petri net is a directed pn with a set of places m a set of transitions t and a set of directed edges each edge containing exactly one place and one transition a marking of pn is a mapping p from the places t to the nonnegative integers given a marking u and a transition with no predecessor marked by o t is by the markings of predecessors of t by and the markings of successors of t by the resulting marking u is said to be derived from v a marking n is derivable from initial marking there exists a sequence of markings po l pk p such that ui is derived from for il k a marking p is if there exists a derivable marking u such that for all places a survey of petri nets appears in theorem in petri nets is log space reducible to reachability in our flow model with static communication proof be a petri net with initial marking and suppose we wish to test if marking u is reachable in pn for each transition t predecessors xl xj and successors xi xi we have a process flow graph gt start ey ca receive observe x t that on receiving messages from channels gt messages over channels xi xi for each place with successors tl tk there is a process flow graph gx start j m transmit transmit r observe that for each message received over channel x gx over one of the channels or for any place and integer k is a subgraph which adds k messages to qx if ko and otherwise attempts to delete i k i messages from qx if ko if ko and i then the process and no successors of are reached a simple but somewhat tedious construction produces an of size the first time the node nx is reached qx contains messages the exit node of process flow graph gx is reached just in the case qx contains px on some visit to nx finally we have a process flow graph go start w i exit where ii xl xs is the set of places follows that the exit node of go is reachable and only if the marking p is in petri net pn with initial marking uo d it if by using petri nets to simulate turing machine computations with exponential space bounds has shown petri net markings is hard by theorem we have that of corollary reachability in the flow model with static communication is hard it is also straightforward to show theorem reachability with static cation is reducible to in petri nets event spanning graphs a message link is a pair of transmit receive statements which communicate through the same channel throughout this section we assume static communication the channel arguments to transmit and receive statements are assumed constant thus we may statically determine the set ml of al message since the number of message links may be quadratic in size of the process flow graphs for efficiency the set ml is never explicitly constructed by our algorithm fix gl nl el sl gr nr er sr as the process flow graphs let n uni be the set of program statements let an event graph be an acyclic directed graph such that for each il r the subgraph of induced by all nodes but those of ni and deleting all edges except those between nodes of ni is a spanning tree of gi for each receive statement n n there is a path in from a start node to n containing a transmit statement communicating over the same channel as n example the following graphs g and g are portions of flow a cl x ml n m the corresponding graph is j portion of an event spanning first we characterize the case where there exists no event spanning graph a et bn f receive statements is a blocking set if for each transmit with the same channel argument as an element of ne all execution paths from a start node to m contain some element of nb example the set b is a blocking set for the program flow graphs illustrated below start sl nl receive c d n transmit c b it is easy to show lemma there is a nonempty blocking set nb just in the case there is no event spanning graph theorem if there is no event spanning then some state is unreachable proof by lemma there must be a nonempty blocking set nb graph suppose some is reached in some and no other element of nb is reached strictly before n since n is a receive statement by definition of there must be an execution of a transmit statement m over the same channel as n previous to the first execution of n this implies that in the flow graph gi containing m there is a path from the start node of gi to m which contains no element of nb the assumption that nb is a blocking set d we now present an algorithm for constructing either an event spanning graph or a blocking set algorithm a input process flow graphs g with program statements n uni and message channel set c output an event spanning graph if it exists and otherwise a nonempty blocking set nb xl for each do if n is a node then w add n to true q else false for each channel do k true e initialize the to node set sl sr and edge set until eu choose and delete some statement n if n is a transmit statement over a channel c and then begin false fj if n is a receive statement over a channel c and then add n to else for each successor m of n such that not do add m to mc m if not then nb m add m to the node true end add nm to the edge set of for each channel c cc u nb then return event spanning graph blocking set nb in the above algorithm a node has been visited if has been set to true it is easy to verify that for each channel if no transmit then statement over c has been visited contains all receive state ments over channel c so far visited otherwise when a transmit statement over c is visited then is set to false all receive statements in are added to active and is set to theorem if an event spanning graph exists then the above algorithm returns one else it returns a nonempty blocking set proof it is easy to verify that if the algorithm returns a then it is an event spanning graph on the other hand suppose the algorithm returns the set we claim this is a blocking set suppose not then there exists a receive statement and a transmit statement m communicating over the same c as n and a path p in a flow graph gi start node si to m and avoiding all elements of nb in the above algorithm si is initially added to it is easy to show that all other elements of p are also eventually added to including m thus is eventually to fl a contradiction with the assumption set that data flow analysis of communicating processes with static communication data flow analysis yields information about a program this information is too weak to suffice for program correctness proofs however it is sufficient for the usual compile time optimizations for example it may be discovered that certain program variables or expressions always evaluate may substitute to constants hence the compiler single load instructions for more complex sequences of instructions which compute the same constant value we wish to extend data flow analysis techniques to the analysis of concurrent programs is an text on data flow analysis of sequential programs let d be a set of predicates de assume a semilattice dv where is the usual lattice meet operation which is binary commutative and on d we require v to be the following weakening of logical for each p if p hold then holds the lattice partial order is defined q p all p qd note that is the restriction implication to domain d p for of logical q p just in the case q implies p for all p qed we assume d contains true false as minimum and maximum values respectively so p true and false p for all we also assume that dv is well containing no infinite strictly decreasing chains pp similar data flow analysis frameworks appear in graham and wegman example we consider a domain d containing finite sets of inclusion relationships of the form where x is a variable and s is a nonempty set of constants we assume that the sets of inclusion relationships contained in di are normalized containing no more than one inclusion relationship for any variable and no more than a fixed number ko of constants in any inclusion relationship the domain also contains false representing inconsistent inclusion relationships of the form xc and true considered the empty set given the meet operation vi combines sets p and q and the results the relation p iq holds for if for each inclusion relationship of q there is a corresponding inclusion relationship xs of p where since each element of d is a finite set and each inclusion relationship is of bounded size the semilattice dv is well end of example a function f dd is if fp fp for all such that p p similarly g dd is for all pp such that p p and qq if a program statement is neither a transmit or receive statement then we assume a function the transfer function of n an dd weakly describing the change of state on execution of program statement n more precisely if holds just before execution of program statement n then holds on exit from n need not be the strongest such predicate as would be required in a hoare logic example a ye xe ye that is if x is known to be either or and y is known to be then after execution of the statement the variable x may be either or we associate with each transmit statement n an function n dd such that is p d holds on input to n then is a predicate describing the value of the message transmitted by n a symbol mc is used to represent the collection of all messages transmitted over channel c example if n ys mc c for each receive statement n we assume a an function such that if holds just on input to n and holds for each p true yl message received by n then holds on output to statement n the objective of our data flow analysis is to compute for each program statement nn the recall that an event spanning graph of the predicates where last section is acyclic and has node set n the set of program statements a topological holds an input to n on all executions ordering of an acyclic directed graph is a total holds an output from n on all executions ordering of its node set ordering before successors a topological predecessors ordering may be let c be the set of channels occurring as argument easily computed in linear time as described in to transmit and receive statements for each knuth channel we wish also to compute a we now present an algorithm which repeatedly predicate holding over channel c for all messages transmitted computes approximations to the above data flow analysis equations in each pass the algorithm specifically we wish minimal each node in n in topological order of an d for each program statement ne n event spanning graph and minimal d for each channel cs c satisfying true if n is a start node otherwise all predecessors m of n if n is a transmit statement if n is a receive algorithm b input program statements n channel set c process flow graphs g gr an event spanning graph and the functions an tn on defined for each appropriate output minimal for satisfying the data flow analysis equations statement over channel c and otherwise all transmit statements over channel c example illustrated below is an example containing maximal solutions to the data flow do sql if n is a start node then else equations relations in the case of the domain of inclusion e p true for each do compute a topological ordering of until no change do for each in the topological of for each predecessor m of n do if n is a transmit statement then m let c be the channel over which n end i else if n is a receive statement then m let c be the channel through which n end else end let ml be the set of all message links let e be the set of all the edges of the process flow graphs gl gr clearly each iteration of the algorithm requires ml operations in the worst case this algorithm after iterations where a is the longest strictly decreasing chain of dv thus the total time cost is a there is evidence however that the algorithm much faster in practice on convergence the data flow analysis equations and are clearly satisfied and we can show theorem algorithm b yields a minimal solution to the data flow analysis equations l and data flow analysis in the case of dynamic in the previous section we assumed that all message arguments of transmit and receive statements are constants we are able to further refine our data flow analysis techniques to the case of a dynamic communication arguments of the communication where the channel primitives are expressions which must evaluate to channels but not necessarily the same channel on all executions our analysis is made more difficult by the fact that the messages between processes may be channel names for example a given process may other processes of new channels over which they may communicate let c be the set of all channels over which processes might communicate let dv be a semilattice with ordering and let tn pn and an be the functions describing transformations of predicates in d through transmit receive and statements respectively as defined in the last section we also assume for each transmit or receive statement the function from d to the power set of c approximation is an essential technique in global flow analysis here we use approximate the possible channels over which n may communicate more formally given a predicate weakly describing the state just before execution of statement n channels must con at least all channels over which n may communicate by we mean here that if p q then for all example in the domain d of inclusion relationships defined in the last section c we minimal for all program statements and channels satisfying l true if n is a start node otherwise all predecessors m of n if n is a transmit statement if n is a receive statement all otherwise all transmit statements cc with for any solution of the above data flow equations and are predicates in d holding on input and output respectively to program statement and holds for all messages transmitted over channel note that the above equations differ from those given in the last section for static communication only in that we use to estimate the channels over which each transmit or receive statement n may communicate the following algorithm yields a solution as long infinite to the equations l as the data flow domain dv strictly decreasing chains and has no our algorithm combines algorithms a and b of the previous sections building an event spanning graph while simultaneously carrying out data flow analysis as in algorithm b the event spanning graph is used to order the nodes through which we propagate data flow information algorithm c input the channel set c process flow graphs with the set of program statements and the functions tn pn an and for each appropriate output blocking set nb or event spanning graph with minimal for nn and satisfying the data flow analysis equations l and begin for each predecessor do m of n if n is a transmit statement begin then for each cc s w if o for each ms such that si add m to ­ end fj e end end else is a receive statement then then for each c add n to else for each else if not for each successor m of n such that not add m to for each ms then qd m to the node set of end add nm to the edge set of end end initialize if n is a start node then m add n to end else s false false if n is a receive statement true then else false for each channel do initialize to node set sl sr and edge set main until no change do w g nb until do w choose and delete some ne for each node n of in topological order do for each cc cc u b o then return blocking set nb else return and for each nn and a proof of algorithm c will appear in the full version of this paper conclusion the data flow analysis algorithms presented in this paper are currently being implemented in a program analysis system for a language ball et al with concurrent communicating processes we are developing direct non iterative data flow analysis algorithms which run very efficiently in the case the programs and their communications are well structured ball gj and low jr preliminary language description tr computer science department university of october graham s and wegman m a fast and usually linear algorithm for global flow analysis no january pp ja a programming methodology for distributed computing among other things tr computer science dept university of new york pb concurrent programming concepts computing vol no dec pp ms data flow analysis pro of computer new york ms and unman jd analysis of a simple algorithm for global flow problems siam j of computing vol no dec t hoare car communicating sequential processes computer science dept university march jones nd ch and ye of some problems in petri nets computer science no pp and unman jd monotone data flow analysis frameworks tr computer science dept princeton university jan ga a unified approach to program optimization proc acm symp on principles of languages jan pp knuth de the art of computer programming vol fundamental al addisonwesley reading mask knuth d e the art of computer programming vol reading mass r the reachability problem and problem for petri nets and hard conf on petri nets and related methods mit july also yale research report m recursive of problem ann of math pp ml petri nets computing vol no se pp tarjan re depthfirst search and linear graph algorithms siam j of computing vol no june b property extraction in wellfounded property sets ieee trans on software pp appendix definitions a directed graph ne consists of a finite set n of nodes and a set e of ordered pairs nm of distinct nodes called edges if nm is an edge m is a successor of n and n is a predecessor of m a graph ne is a subgraph of ne if n cn and e ce length k from n to m is a sequence of nodes n k m such that se for oi the path is simple if no nk are distinct k except possibly no nk and the path is a cycle if no nk a graph is acyclic if it contains no cycles a directed graph is if n n are disjoint and n e a flow graph g is a directed graph n e with a distinguished start node s such that for any node s there is a path from s to n rooted xt is a flow graph such that ini the start node s is the root of the tree any tree is acyclic and if n is any node in a tree t there is a unique path from s to n if g is a flow graph and t is a tree such that ne is a subgraph of nn and ss then t is a spanning tree of g 
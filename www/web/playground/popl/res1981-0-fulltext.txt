carrier arrays an extension to apl p department of computer yale university new science the apl programming style is limited by the constraints of a array as a data structure data is difficult to represent and manipulate and the apl functions have no uniform extension to higher rank arrays the carrier array is an extension to apl which these limitations while preserving the apl style a carrier array is a array with an associated partition which allows functions to be applied to in parallel the primitive functions are given base definitions on and vectors and they are extended to higher rank arrays by uniform application mechanisms carrier arrays allow the dimensions of an array to be treated as a single datum the primitive functions are given extended definitions on scalars and vectors of this data construct the in a explicit looping is replaced by the parallel flow of function application along the of the array the ability to program concise apl programmers to develop large sets of software tools e tools are called idioms and they are characterized by their wide range of applicability and frequency of use for example is an idiom v to remove duplicate elements from a vector apl has three major which restrict the class of problems which can be solved simply in the apl style apl arrays characters represented must be collections and numbers cannot and of be this paper defines changes primitive functions carrier arrays are issues are discussed the carrier array and the to the definitions of the apl of with presented and implementation introduction concise expressions parallel function application and the development and use of idioms characterize the apl programming style arrays in apl are used both aa a data structure and as a means of controlling the flow of function application this dual of an array gives apl an of expression not found in other programming languages apl has a unique this research was supported corporation by a grant from the permission to make digital or hard copies of part or all of this work or r are to prior to copy otherwise a acm o x apl functions are designed for scalars data simulated but the functions power of parallel application arrays can lose of be the only the primitive scalar functions can be uniformly applied to the elements of an array there is no consistent definition for the application of a function to an array of arguments all of these problems from the limitations of apl arrays as a data structure the apl community has proposed nested arrays as a new apl data structure a nested array is a recursive data structure where the elements of an array may be arrays themselves data can be represented trivially with nested arrays and new operators are defined to allow the parallel application of all primitive and userdefined functions nested arrays in apl their own programming style parallel function application is no longer aa natural with a data structure the programmer moves toward the lisp paradigm of recursive movement down and up the tree in sample programs the level of nesting of data replaces the dimensions of the array as a means of structuring data nested arrays introduce new idioms into idioms do not generalize naturally data structure apl and current to a recursive this paper presents an alternative to nested arrays the in extending language such as apl an important an goal is its idioms we call this the principle of the development of the carrier array has been driven by an attempt to generalize existing apl idioms for example how can apl be extended to allow to mean the removal of duplicate words from a word list and what extensions would enable the idiom to remove from many vectors in parallel the carrier array ia an abstraction which permits both it is a array with an associated partition which allows the programmer to view an array as a collection of word lists and to apply functions to each list independently carrier arrays are designed to facilitate both the representation of data and the parallel application of functions an of many apl programs has shown carrier arrays preserve apl idioms and the apl style while greatly increasing the power of the language the limitations of current apl are discussed in the next section and section presents the nested array alternative carrier arrays and the changes to the apl primitive functions are motivated and defined in sections through section discusses mechanisms for controlling the parallel application of functions and section the of the primitive functions in more detail in section we present the small number of changes in apl syntax required by carrier arrays several examples of carrier apl programs are given in section and we end the paper with a discussion of implementation issues problems with apl as an informal introduction to carrier arrays and the problems they address we consider the idiom in more detail as mentioned in the introduction we would like to extend the idiom in two directions to operate on data and to remove from many vectors in parallel in this section we examine by means of annotated examples the limitations of current apl which make these extensions difficult removes from a vector maps each element of v to the index of its first in v pv gives the index of each element of v comparing these two values we can identify and remove all but the first of each element of v for example v ac i data removing duplicate entries from a list of we first represent the word list as a apl array this is most easily done by the words with and storing each word as a row of a matrix note this is not an adequate solution for storing a list of arbitrary text strings for the character must not occur in the string we now adapt the functions in our idiom to this new data structure we can use the inner product operator to derive the function a which tests for equality between vectors however we cannot derive a variant of i which uses a as its for equality thus we must discard our current idiom and develop a new combination of primitives to identify the first of each row of the matrix ri v apl basic apl cobol basic fortran r apl basic cobol fortran pr parallel application we now consider removing from many vectors in parallel we represent the vectors as rows of a matrix the vectors appropriately to apply our idiom to the matrix th e primitives functions operating in the idiom must extend on each row of the matrix independently however of the primitives functions used in the idiom only the scalar function extends to a matrix row by row testing equality between the elements of corresponding rows the other functions extend to a matrix in various ways compression and i a vector left argument independently each row of a matrix right argument matrix left argument is not permitted apply to a shape p is not a function it gives the shape of the matrix not of the rows which compose it monadic scalars matrices t is only it does not extend defined to vectors for or to extend our idiom to apply independently to the rows of a matrix we must rewrite it with a new collection of primitives in the code below the first line creates the mask mo which for every row the of each element in the row the next three lines use this mask to select the corresponding elements from v v pv note this program can be extended data by making further changes to the the inner product a in line and the of v on line to code using analysis the two extensions demonstrate the mentioned in the of the three limitations of the introduction idiom language representing arrays are structures for apl functions do not data easily extend to apl functions cannot be independently applied to the rows of a matrix notice the two problems are partially a consequence of the first since data cannot be represented naturally the primitive functions cannot easily manipulate it similarly many apl functions applied independently to the rows of a matrix would produce results for example in his first published definition of apl allowed a boolean matrix to another matrix each row of the boolean matrix compressed a corresponding row in the right argument the compressed rows could have varying length for there was no restriction on the boolean matrix they could not be stored as rows of a array therefore the result rows were into one vector this however subsequent parallel function application for the row structure which the application is lost this extended compression was eliminated in later definitions of the language it is essentially incompatible with arrays nested arrays the apl community has proposed two new functions for creating and manipulating nested arrays and converts an array into a scalar and is the inverse operation which the original array ie a a for all arrays a a mapping operator called or each been proposed it is similar to the function of lisp if a function f is applied to an array a each element of a is in turn selected and the function f applied to the element and the result of the application of f is and stored in the result array no order for the selection of elements of a is specified more formally if then ri for all valid indices i note that these additions to apl do not change the meaning of any current apl program operating on arrays thus the idiom remains valid for vectors of simple scalars we will now examine how to extend the idiom using nested arrays data to remove from a word list we first create a vector v of character vectors each element of v represents a word in the word list the definition of is extended to arrays by a recursive definition of equality two scalars are equal if their have equal shape and equal elements in corresponding locations the other primitives in our idiom are to the type of the elements of v thus using nested arrays the idiom extends to data with no changes pv pv parallel application to apply we scalars function our idiom to several each vector and in a new vector in the idiom vectors in parallel the resulting v we then apply each to v r v iv i pv v v ri note this solution will also remove from multiple word lists in parallel v must be constructed with two levels of nesting will cause the functions to one level and operate on each word list independently nested arrays the three limitations of apl outlined in the introduction structures are represented as vectors of vectors primitive functions are defined to manipulate and provides a mechanism for parallel function application in the extensions above the nested array serves two purposes in the extension to data it is a data structure for representing a collection of character in the extension to parallel application it is terminology a frame for the application of functions with note it is not used to create a recursive structure the nesting is the three level structure used in the combination of the two extensions a three level structure is a natural one for parallel function application the lowest level holds the data the words the middle level contains the structures being manipulated the word lists the top level provides the structure to parallel application it is an array of word lists a more nested structure is not often needed for parallel function application the operator provides a uniform means of applying functions to several vectors in parallel this allows the programmer to the ad hoc extension of apl primitives to higher rank arrays notice in our example that when the operator ia used it is applied to every function in the idiom if the nested array was not such a change to the apl data structures perhaps the operator could be implicitly incorporated into the application of the primitives the carrier concept carrier arrays are modeled on the relationship between scalar functions and arrays of scalars in current apl the scalar functions are defined on scalars higher since and they rank arrays the elements of an extend to this extension is natural apl array coincide with the domain and range of the base definitions of the scalar functions in carrier apl we extend this identity by an array as a carrier of base arguments to a function an array of a function has if the of a functions arguments determines the shape of a functions result for example reversal has uniform shape if ab the shape of a is determined by the shape of b and is in fact identical to it does not have uniform shape the value of the left argument to determines the shape of the result has noted that an array argument to a function of uniform shape can be viewed as a frame or carrier of and the function can be independently to each since the function has uniform the results will all fit in a array for example can be applied independently to the of a p giving a rank two result r pz in terminology the first dimension of a is a frame holding three cells to get r from a we apply to each cell keeping the frame the problem with approach is that he introduces a special operator to indicate how the array should be partitioned into frames and cells the current definitions of the apl primitives do not allow the partitioning to be implicit consider the apl primitives so that they are defined as a mapping on a of arrays with a characteristic functions rank two this mapping sets for is called the w of the function for example scalar plus is defined to add scalars rank o arrays up ia defined to sort vectors rank arrays is defined to join vectors with a few exceptions all the primitive functions can be defined as mappings of scalars and vectors to scalars and vectors the definition of each function can be characterized by a rank vector for a function the vector has three components the rank of the left argument the rank of the right argument and the rank of the result for monadic functions only two components are necessary the rank of the left argument and the rank of the result we call this vector the w of the function scalar functions have base rank o o etc when a function is applied to an array the array is partitioned into a frame or of independently and the function is applied to each the programmer need not indicate a partition it is determined by the base rank of the primitive functions a it is applied and s respectively there must exist function f with base rank a b c to two arrays x and y with r for x and y to be a j such that x and y are partitioned into of rank j and the function f is applied independently to corresponding of rank a and b respectively the results are in z z will have rank cj we call the first j dimensions of x y and z a the of x and y must have the same except for scalar extension see section but other constraints are determined independently for each pair of base arguments to maintain evaluations independence we allow between the results the parallel to vary in shape and in type thus when the carrier partitioning is removed the basic data structure is a heterogeneous array for example consider the compression mentioned b is a boolean matrix generalized matrix above see section and m ie an equal matrix compression has base rank both b and m are partitioned into of vector arguments corresponding vectors in b and m are and the compression performed independently on each the results are stored in a r when the partitioning is removed r is a matrix bl m r fj i we illustrate the carrier concept by extending the idiom to apply to several vectors in parallel suppose primitive functions in characteristic the base the idiom definitions have the of the following monadic monadic i i p then removes independently from the rows of a matrix or an arbitrary rank array is defined on vectors it is applied independently to each vector in its argument it produces vectors which are in a result array of the same rank shape is defined to give the length of a vector applied to a rank n array it will return a rank n array of lengths monadic is defined on scalars it is applied to each scalar its argument it produces vectors applied to a rank n array it produces an array of rank nl vm pv o on abc data how can data be represented without the introduction tree or of a new data nested array type eg string arrays allow structures to be represented but the primitive functions must still manipulate the structures what is needed is a mechanism for indicating which of the last of an array treated represent one structure aa a unit serves and should this purpose be in the nested function the datum array system is applied rank indicates in carrier aq the rank apl when a is specified of the data structures represented in the array if we apply function f with datum rank k to a rank n array x ie then x is treated as a rank nk array with data elements of rank k most apl functions have natural to data the and selection functions manipulate are equality to the type of data they and its related functions have obvious extensions of meaning for example we say two structures are equal if they have the same shape and equal more formally corresponding elements are a where k equals the rank of a and b recall the shape of a array of rank n is a rank n array of the lengths of each vector along the last axis any array into a vector equality for datum rank o is defined as the current apl equality between scalars thus the recurrence has a welldefined base case the extended definitions of the apl primitives will be discussed at length in section two matrices can be tested for equality different ways we can compare them as scalars as vectors of vectors or containing matrices for example in three matrices of as scalars v cobol cobol algol cobol vv vv we can extend the idiom to word lists by adding the appropriate datum rank to the code shape and compression view their arguments as vectors of data only the right argument for compression the other functions are applied with the default datum rank of o v apl basic apl cobol basic fortran pv apl basic cobol fortran carrier arrays note that the code in the above example will remove from several word lists in parallel if each word list is represented as a matrix in a array each primitive function ia applied using its base definition and the array v is partitioned into a structure a frame of lists array of words a carrier with an associated three level partitioning it is similar to the nested array used to remove from multiple word lists see sections and unlike nested arrays the structure is dynamically imposed when a function is applied to an array and removed when the application is completed a carrier array exists only during a function application the basic apl data structure is a heterogeneous array the process is analogous to the execution of machine code no type is associated with a machine word it is imposed on the word when it is and an operation performed and the type is when the word is stored how do we characterize a array we define a h to be a tree where all paths from root to leaf have the same length we call this length the depth or rank of the tree a e each level is a tree with uniform note that an array branching at is a complete tree we define a a tree an empty is represented by associating a rank with a leaf node in the tree and including this rank in determining the length of the path from root to leaf a carrier array must be described within the context of a function application consider a monadic function f applied with datum rank k to a rank n array a ie let f have base rank i j when the function partitioned into a is applied a is carrier array each level in a carrier consists of a number of dimensions in the array this number is the rank of the level the lowest level is the it contains manipulated by the function the data structures when f is applied to a with a datum rank of k the last k dimensions of a are implicitly and treated as a single datum the middle level is the m it consists of arguments to the base definition of the function being applied the size of the base level is i determined by the base rank of the function f the top level is the carrier m it is a frame carrying the base arguments to the applied function the size of the carrier level is the difference between the rank of the array a and the s of the base rank of the function and the rank k this difference cannot be negative an exception is described in section if it is zero we have a scalar carrier a is an for f with datum rank k for example reversal is applied with datum rank to a rank array a a where a has shape a is partitioned into a carrier of base arguments the carrier has shape each base argument is partitioned into a vector of matrices the base level vectors have length and the datum level matrices have shape each base level vector is in a new carrier and array the results are the partitioning is then removed from both a and the new array the net result is equivalent to the reversal of a on the third dimension in current apl ie a any array with rank large enough to permit the partitioning described above is a valid carrier array for f with datum rank k as noted in section for a function applied to two arrays eg the of a and b must have the same not necessarily shape but all other restrictions for both monadic and functions are determined independently during the application of the function to its base arguments in the arrays the uniform rank of the primitive functions the results of each application can be in a new carrier array so we see by appropriately substituting the datum rank the remove independently from of objects values of idiom will many vectors application forms the concept of an array as a carrier of function arguments and the definition of primitive functions on arrays of characteristic rank permit a great freedom in the pairing of functions with arguments much of the control flow of a program can be subsumed into operators which control the distribution of functions throughout carrier arrays of arguments throughout the paper we have assumed functions were applied a monadic function is applied independently to each base argument in a carrier array a function is applied independently to base arguments in corresponding locations of two we call this application scalar for monadic functions scalar product is perhaps the only reasonable application form for functions however other possibilities exist as noted in section arrays in current apl are of arguments to scalar functions this permits apl to offer a rich of operators to apply default scalar functions to arrays application form of scalar along with the product scalar functions can be applied using inner and outer product reduction and scan in this section we examine how these application forms can he extended to carrier apl scalar product a useful addition to the concept of s scalar extension consider a function f applied to two arrays a and b assume a ia partitioned into a and b into a the one in b is with each of the j base in a and the function is applied independently to each the is extended to with the two arrays are under scalar product if each is partitioned into a or if one or both is a for example suppose we to cross reference a list of variable with the text of an apl function for each variable the lines it appears on assume the variable names are all one character as they too frequently are in apl programs we can represent the variables in a vector v and the function in a matrix f one line per row we do not include the function header in f we then wish to apply the apl membership function between v and each row of f this is simply membership has base rank f is partitioned into a v becomes a which can be applied with scalar extension each row of the result is a boolean mask indicating which variables are present in the corresponding row of the function ie v f a s ll ao a s shape what if v a argument vector described v was a scalar membership a scalar v it can then and the above in the above requires a is implicitly be partitioned computation example eg vector left to a into a proceeds as outer product when a function is applied as an outer product to two arrays a full product of the base arguments in the two is formed and the function is applied independently to each pair we define outer product using the concept of scalar extension consider the outer product form where f is being applied as an outer product with datum rank k to the two arrays x and y let f have rank a b c and x and y have m and n respectively when f is applied x is partitioned into an and y a where and the is the frame for the application each base argument in x is applied using scalar product to the entire of y eg for every base argument b in x we evaluate b and the result ia stored in a corresponding location of a new for example ao bl where the two of the for convenience result are displayed recall suppose formal function the example discussed above we want to separately cross reference the parameters and the other used in a v is now a matrix the formals in the first row want to test f this is rank vector base array the other variables in the second we each row of v with every row of expressed membership has base so both v and f are partitioned into the result is a carrier containing arguments it is also a rank v f same as above shape assume we to two functions in parallel ignoring the distinction between formal parameters and other variables v is now a matrix each row corresponding to the for a function f is rank array each representing a function note scalar extension is not applicable here v is no longer a to perform the cross reference we take an outer product making all possible membership tests and select the relevant results with a rank reducing v i xyz af ll ao ­ a ys s x p pf yo p shape the combination of outer product and is very powerful and it occurs frequently unfortunately in most apl implementations it is a computation for the entire outer product is calculated before the is performed has noted that the can be regarded as a further specification of the pairing of arguments by the and the pairs can be discarded before the function ia applied unfortunately in the presence of sideeffects this merging of and outer product is not equivalent to a sequential interpretation of the two functions the of this optimization has been a the apl community for years in carrier apl we allow the programmer to determine how a outer product combination should be evaluated if the is to be a guide in the pairing of arguments to the outer product the vector can be included in the outer product form eg we write vo cf if a full evaluation of the outer product followed by the is desired we write vf reduction reduction is a mechanism for sequentially applying a function to pieces of an array reduction is defined for vectors of rank k datum ko and is extended to higher rank arrays the simplest definition is recursive as suggested by and let f be a function and v a rank kl array we define v identity or error if if if since apl equivalent evaluation is right associative this definition is to placing f between every in v if followed by the of the resulting expression note that k is the datum rank of f it is a specification for a partition of v a separate datum rank for f can be specified as in and fm is substituted for f in the above definition for convenience if no partition is indicated in the reduction form v is partitioned into the base arguments of f this default is welldefined only if the left and right base arguments of f have equal rank ie the base rank of f is of the form a a b for example limited be a character each reduction can has base rank matrix one word per word of m into one vector effect let row a m m the apl idiom list m idiom list if rank thus of m array it is a carrier m independently for each note the definition of reduction places no constraints on f any form can be used in particular an outer product form is valid for example n out the first n numbers a in the matrix s number system forms each datum in an array since the datum rank is zero each scalar is to a vector the outer product produces a cartesian product of the eg i shape scan scan is best defined be a function kl if the reduction v then the scan of in terms of reduction and v a array of f is defined on f is let f with rank a vector recall gives the length of the of v take has base rank o thus using scalar extension the v is with each element of appropriate the index prefix is vector selected and reduction the is to each row of the resulting matrix scan extends to higher rank arrays as for reduction the rank of the function is used as a default partition of v for example in creates a column matrix containing vector and scan is applied to combine the index the rows in similarly np creates a form inner product inner product is essentially an appropriate combination product and definition here a macro expanding of reduction we do not extend into outer its primitive functions in this section we present the base definitions of the apl primitive functions and discuss how they can be extended to data a few apl functions have no natural fixed rank definition they will be defined separately as special forms base we define each primitive its current apl definition rank here we a base of the primitive function to arrays datum rank functions by restricting of specific of zero the are monadic scalars p o e t note the restriction in rank changes the effect of many functions when they are applied to higher rank arrays for example take has base rank o and tm where m is a matrix with two rows creates a structure selecting two elements from the first row and three from the second we introduce distinct functions for and has base rank it joins vectors into a longer vector has base rank o it makes a vector out of two scalars introduced a new called it is defined below in the context is of data extended we now extend the base definitions of the primitive functions to data all the primitive functions defined here are uniform with respect to datum rank the datum rank of the arguments determines the datum rank of the result for many functions such as compression or only the right argument is permitted to carry data the left argument is a boolean or numeric guide to the of the data for these functions any explicit datum rank supplied in an application form refers only to the right argument other functions such as encode are defined only for scalar data and a datum rank other than zero in an application form is an error in the table below we give the datum of the arguments of each primitive function and the corresponding datum rank of the result an n in the table represents any integer greater than or equal to zero monadic scalars p nn no nl nn nn i e t in giving functions the extended definitions we split the functions of the primitive into four groups the arithmetic scalars functions and obvious ions we will turn the relations the the functions without examine each group in arithmetic scalars the arithmetic scalars are applied to data by leaf for monadic functions there is no constraints the function is applied to each element of the array the datum for functions the two arrays must have the same rank and else an error occurs if the corresponding elements of the two arrays are and the function applied relations the relational scalars treat a datum as single entity equality was defined in section the definition builds recursively on the current apl scalar equality two arrays are equal if they have the same shape and elements in corresponding locations the other relational s are defined to determine a order for example we define to be where k is t t t v t the rank of a and b al a al we use the current data ko thus base case apl definition the recurrence of for scalar a welldefined the definitions of and membership extend naturally to data given a generalized definition of equality similarly the above definition of gives an extended definition of up and down functions the functions the elements of an array they are to the type of the elements thus they extend naturally to data as mentioned above many functions have a boolean or numeric left argument which the of the data data is not allowed in these the functions are reversal s expand take drop and q shape p which gives the structure of a array will be discussed in the context of the special form is unique among this group it the data carried in the array has base rank o and datum rank n it each datum in an array into a vector elements in order selecting the and expand require a fill character the fill character is a singleton with rank equal to the datum rank of the base array if all the leaves of the data in the base array are numeric the base array is of type numeric and the singleton will contain a zero otherwise the type is character or mixed and the singleton will contain a for example m apl basic cobol apl basic cobol shape functions without obvious extensions encode and have no obvious extensions to data we are considering generalizing these functions through their relationship to array indexing function monadic would become the described by and others but the corresponding extensions to encode and are not as obvious special forms special forms are used to define primitive functions which cannot be independently distributed across a carrier of these functions cannot be applied using the application forms described in section the argument arrays are not partitioned into before the function is applied the function definition determines how the array the function arguments applied should be partitioned and to the functions defined as special forms are b indexing and p we discuss each in turn is defined arbitrary array k is given eg rank k data as in current apl into a vector if ka the result it a datum rank is a vector an of of is and an arbitrary defined rank for a vector left right argument argument consider where the length of v is i and the rank of a is j a is partitioned into an of rank i each containing rank k data where v is applied to each rank i independently using the definition of in current apl the results are in a new if an error is given indexing indexing j plus remaining treated from the is defined as in current apl consider a is partitioned into an array of rank the number of in the form the dimensions if any are and as data indices are computed index list as in current apl if a element ia indexed an error occurs a array introduces a new concept of shape into apl the shape p of a rank n array is an array of rank nl each element containing the length of the corresponding vector in the original array we call this the additive shape for tile number of elements in an array equals the sum of the elements in its shape arrays have traditionally had a multiplicative shape the multiplicative shape of a rank n array is a length n vector each element of the vector giving the length of the corresponding dimension in the array thus the number of elements in an array is the product of the elements in its multiplicative shape note that the multiplicative shape of any nonempty array can be calculated from its additive shape n kl is the rank of a k for i kl to for any array with no empty the above code gives the shape of the smallest array which contains it we define p in terms of additive shape consider where s is an additive shape and a an arbitrary array of rank n a is partitioned into a frame of rank k and the frame is to have shape s the elements of the frame are selected in order to the beginning of the array if necessary p pl a word on syntax carrier apl requires no significant additions to the apl syntax are included to indicate datum rank a new function token with monadic and is introduced additional primitive functions may be applied with reduction be included in an outer and a product form vector may note that the axis operator of current apl is datum rank captures its usage with reversal expand and an explicit is necessary to replace its use with reduction and scan some examples key word in context the has often been techniques and problem is given used style a list problem described to of by programming the produce a sorted list of by each word in the title a title appears once for each word in it gives an line apl solution which is complicated by the need to manipulate data words and using apl s scalar primitives the algorithm however is quite simple and can be expressed naturally with the extended primitives of carrier apl we give a four line solution below the list is represented as a rank array each is a title and each row is a word line one a into a vector of words and stores in s the indices which will this vector line two is a standard apl idiom for each element i of s it the index of the title containing the word associated with i line three the offset of each word in its title these offsets will be used to each word to the front of its title line four sorts the and performs the rotation the result is then for output si l la s ia a structured the programming apl idiom list a programming language si f r a programming language i apl idiom list i the idiom list i the apl language i a programming list i the apl idiom programming i structured programming language i a structured programming i the apl idiom list i strings the input data structure a in the above example can be easily constructed from a character vector of each delimited by a return or other special character a common apl idiom called in the apl idiom list breaks a character vector of strings separated by into a matrix one string per row the idiom coded in carrier apl appears below we assume there are no adjacent in the input vector and that i is terminated by a line creates a mask m marking the d in i and line stores their indices in l line the length of each string in i and stores the lengths in s s is the additive shape of the desired result construct the result in line we the input vector with the removed pm this program generalizes without changes to arrays of character vectors independently to produce the input array for the program we apply the idiom twice first using return as the we produce a matrix of from the input stream we then apply again with as the each title in parallel symbol table update consider the symbol table update problem presented in idiom list two structures a and b the symbol table a is a list of symbols b is an associated usage count list x is a new symbol to be added to the table if x is in a the appropriate element of b should be if x is not in a it should be to a and a count of one to b an elegant assume each character scalar solution can be written in apl if we symbol can be represented as a single a and b are then vectors and x is a this solution symbols to vector of extends immediately to the table in parallel symbols we assume it add several x is now a contains no in this example the data structures and m are all vectors membership and compression are all evaluated in the restricted domain of their base definition in carrier apl thus the evaluation of this program using the semantics of carrier apl is identical to its evaluation in current apl however by inserting datum rank we can extend the program to symbols all the functions in this program are applied using scalar multiple product symbol thus this program tables in parallel will update consider the evaluation of mo in this parallel case miss matrix each row representing the additions to a symbol table partitioning it is o is a scalar during to a vector carrier the vector is a row of m using scalar and it is applied to each extension in each application the base definition of compression extends o to with the row of m this natural generalization of apl programs essence of is the implementation issues much of a carrier apl implementation is identical to an implementation of current apl the and syntax analyzer are essentially unchanged the base definitions of the primitive functions are a subset of current definitions there are two research areas in the implementation current ly being investigated new possibilities for streaming computation and efficient representation of carrier arrays the carrier concept of parallel computation along the dimensions of an array allows a straightforward streaming of base argument evaluations consider the remove example discussed above see sections and when removing from the rows of a matrix the interpreter can process one row entirely before starting another with significant in temporary storage and loop overhead moreover base argument streaming allows the more apl optimizations proposed by and others to be applied largely within base argument computations eg removing from a single row of a matrix on this restricted domain these optimizations may prove more successful to represent carrier arrays we need a heterogeneous data structure which is easily partitioned into the three level carrier structure the data structure must permit fast access and easy manipulation of the base level of the partition to which the functions are applied we choose to represent a carrier array as a nested vector ie a matrix is a vector of vectors a rank array is a vector of vectors of vectors etc the basic storage object is a vector of one of three storage classes character number or pointer each vector has a length and storage class associated with it along with other type information required for efficient execution of the primitives perhaps additional links in the nested structure will be required for fast traversal of the tree conclusion in our the major semantics strength of apl is the of the primitive functions and operators the replacement with the parallel flow of of explicit looping function application along the of an array carrier apl is a natural generalization of this control flow the rank structure of the array which permits the implicit iteration is maintained but the constraints of and are removed primitive functions are to make their parallel application more uniform the carrier array a nested mathematical has developed is not as general a data structure as array it does not yet have a theory defining its semantics a rich theory of nested more arrays but it introduces no new concepts that are difficult to integrate into the language carrier better at what apl is an attempt to make apl it is already good at it is a conservative extension to apl alan suggested to me the problem extending idioms to higher rank arrays and notion of a carrier array is his carrier has been developed under his direction and made helpful earlier of this paper of the apl of i would like to thank the apl workshop in for present a preliminary version of this of the allowing paper me to references philip s an apl machine technical report uc stanford linear center february philip s wrong with apl in apl pages june bob and e operators and arrays presented at a standard apl workshop conference center september october a d and dl development of an apl standard l q part june and general arrays operators and functions july j and k compilation and delayed evaluation in apl in nw proceedings pages popl january w e and ma recursive data structures in apl january e ain john and sons inc new york e technical ti function report rc ibm thomas j watson research center operators e october ma and operators in an apl containing nested arrays apl december l the dynamic incremental apl q part compiler of apl june w and pj m addisonwesley uses of general arrays and operators in ws pages apl may compilation a design for an apl compiler part june more jr axioms and theorems for a theory of arrays march more jr the nested array as a model of data part june morris james h and ip experience with an applicative string processing language in pages popl january private communication oct dl on the criteria to be used in systems into modules u december alan j k technical report updated yale university march alan j and technical report yale university april alan j and programming with idioms in apl part june the apl workshop session on standardization of apl systems ail december apl problems with order of execution march berkeley apl ca 
a unified approach to global program optimization a computer science group school california abstract a technique is presented for global of program structure in order to perform compile time optimization of object code generated for expressions the global expression optimization presented includes constant propagation common subexpression elimination elimination of redundant register load operations and live expression analysis a general purpose program flow analysis algorithm is developed which depends upon the existence of an optimizing function the algorithm is defined formally using a directed graph model of program flow structure and is shown to be correct several optimizing functions are defined which when used in conjunction with the flow analysis algorithm provide the various forms of code optimization the flow analysis algorithm is sufficiently general that additional functions can easily be defined for other forms of optimization introduction a number of techniques have for the compiletime analysis of program structure in order to redundant computations perform constant computations and reduce the number of sequences between memory and registers some of these techniques provide analysis of only sequences of instructions while others take the program branching structure into account the purpose here is to describe a single program flow analysis algorithm which extends all of these optimizing techniques to in branching structure the algorithm is pre formally and is shown to be correct im of the flow analysis algorithm in a practical compiler is also discussed the methods used here are motivated section which follows in the constant propagation a fairly simple case of program analysis and optimization occurs when constant computations are evaluated at compiletime this process is referred to as constant propagation or folding consider the following algol program integer ia bc al co il until de c end end this program is represented by the directed graph shown in figure ignoring which con the the nodes of the directed graph represent sequences of instructions contain ing no alternate program branches while the edges of the graph represent program control flow between the nodes at j b c b d d ab f iii c figure a program graph corresponding an algol program containing one loop to for purposes of constant propagation it is convenient to associate a pool of propagated constants with each node in the graph the pool is a set of ordered pairs which indicate variables which have constant values when the node is thus the pool of constants at node b de noted by pb consists of the single element al since the assignment al at node a must occur before node b is encountered during execution of the program the fundamental global analysis problem is that of determining the pool of propagated constants for each node in an arbitrary program graph by inspection of the graph of figure the pool of constants at each node is pa pb al pc al pd al b pe al b d pf in the general case pn could be determined for each node n in the graph as follows consider each path ap p pn n from the entry node a to apply constant propagation throughout this path to obtain a set of propagated constants at node n for this path only the intersection of the propagated constants determined for each path to n is then the set of constants which can be assumed for optimization since it is not known which of the paths will be taken at the pool of propagated constants at node d of figure for example can be determined as follows a path from the entry node a to the node ii is a considering only this path the first approximation to pd is p al d b c a longer path from a to d is which results in the pool p c cl e corresponding to this particular path to d suc longer from a to d can be resulting in pa pi for arbitrarily large n the pool of propagated constants which can be assumed no matter which flow of control n is the set of constants that is common to all pd d vi p this procedure however is not effective since the number of such paths may have no finite bound in the case of an arbitrary directed graph hence the procedure would not necessarily halt the purpose of the algorithm of the following section is to compute this intersection in a finite number of steps a global analysis algorithm the analysis of the program graph of figure suggests a solution to the global constant prop problem considering node c the first approximation to p is given by propagating constants along th path a b c resulting in al c c o based upon this approximate approximations to subsequent pool the first nodes can be determined p d p e d f using p the constant entering node c is pool resulting from node f p note however that since nc i c vi it follows that pc p n p thus assuming pc p the second approximation taken as rather to than pc is p dec al using p the circuit through the loop past c is traced once again the next approximation at sub nodes can then be determined based upon p n al b al p n p n d al b d b around the loop once to node c the third approximate determined as again pool from node p ia f p p n d al clearly no changes to subsequent approximate o cur if the circuit again since pc pc and the effect of pc on the in the circuit has already been investigated thus the analysis stops and the last approximate at each node are taken as the final constant note that these last approximations correspond to the constant determined earlier by inspection based upon these observations it is possible to informally state a global analysis algorithm a start with an entry node in the program graph along with a given entry pool corresponding to this entry node normally there is only one entry node and the entry pool is empty b process the entry node and produce optimizing information in this case a set of propagated constants which is sent to all immediate successors of the entry node c the incoming optimizing with that already established at the successor nodes if this is the first time the node is assume the incoming pool as the first approximation and continue processing d considering each successor node if the amount of optimizing information is reduced by this intersection or if the node has been for the first time then process the successor in the same manner as the initial entry node the order in which the successor nodes are processed is in order to generalize the above notions it is useful to define an optimizing function f which maps an input pool along with a particular node to a new output pool given a particular set of propagated constants for example it is possible to examine the operation at a particular node and determine the set of propagated constants which can be assumed after the node is executed in the case of constant propagation the function can be informally stated as follows let v be a set of variables let c be a set of constants and let be the set of nodes in the graph being analyzed the set u v x c represents ordered pairs which may appear in any constant pool in fact all constant are elements of the power set of u ie the set of all subsets of u denoted by pu thus f ix pu pu where vc c a v c c p and the operation at node n does not assign a new value to the variable v or b the operation at node n assigns an expression to the variable v and the expression evaluates to the constant c based upon the constants in p consider the optimizing with an empty the graph function constant of figure can be applied pool resulting for example to node a in fa al similarly the function f can be applied to node b with al as a constant pool yielding fb al al c o note that given a particular path from the entry node a to an arbitrary node n e the optimizing pool which can be assumed for this path is by composing the function f up to the last node of the path given the path for example b is the constant pool at d for this path the pool of optimizing information which can be assumed at an arbitrary node n in the graph being analyzed independent of the path taken at execution time can now be stated x n formally as where fn pp pn n is a path from an entry node pi with corresponding entry pool p to the node n before formally stating algorithm it is necessary notions the global analysis to the a finite directed graph g e is an arbitrary finite set of nodes n an edges a path from a to bin g for ab c of nodes pp pk pi a and pk b where vi i k length of a path t pp pk is k the a program graph is a finite directed graph g along with a nonempty set of entry nodes c sy such that given n c a path pc and pn n ie there is a path to every node in the graph from an entry node the set of immediate is given by in n successors of a node n nn c similarly n is given the set of immediate by predecessors of n q e e let the finite set be the set of all ble optimizing for a given application eg pu in the constant propagation case where u v x c and a be a meet operation with the properties a p x p x a y y a x commutative x a y a z x a ya z associative where x y z c the set p and the a operation define a finite the a operation given by defines a partial ordering x y x a y e p similarly on x y x s y snd x y given x c p the generalized meet operation xa is defined simply as the pairwise application of a to the elements of x is assumed to contain a element q s x vx e p an augmented set is constructed from p by adding a unit element with the and a x x c p l it follows that an optimizing function f is defined f n x p p and must have the homomorphism property a y a n xy c note that vn e and x the global analysis algorithm is now stated algorithm a analysis of each particular program graph g depends upon an entry pool set x where e x if e c c is an entry node with corresponding entry optimizing pool x e node pool l if l then halt let l l l some n n and pi c for pn be the current pool of optimizing mation associated with n initially pn if pn s pi then go to the node step a pp ap e in go to step a for purposes of constant propagation pu where u v x c as before the meet operation is n and the rela tion ia c note that the zero element in this case is t e pu the unit element in pu is u itself the algorithm requires a new unit element however which is not in pu the new unit element is constructed as follows let be a symbol not in u and let u u it follows x c pu and pu thus u y is obtained from by adding a unit element aa demonstrated in the proof in theorem the addition of the symbol to u causes the algorithm a to consider each node in the program graph at least once appendix a shows the analysis graph of figure using the entry a of the program pool proof each from theorem the algorithm a is finite the algorithm a terminates when l evaluation of step a removes an element l and elements are added to l only in step a thus a is finite if the number of tions of step a is finite informally evaluation of step a reduces the size pool pn at some node n since the size each of the cannot be less than the process must be finite formally step a ia performed only when pn pn a pi pn a pi s pn thus the approximate pool pn at node n can be reduced at most to since pn py a p further since the first approximation to and the lattice is be performed a is finite finite only it follows a can a finite number of times thus an upper bound on the number of steps in the algorithm a can easily be determined let n be the cardinality of and h be a function of p which in turn may be a function of n pro the maximum length of any chain between and in step a can be executed a maximum of h times for any given node since there are n nodes in the program graph step a can be per formed no more than n q h times in the example let of u in addition case of constant propagation for u be the cardinality of u the directly with the number of nodes the maximum length of any chain size n uk such that ul u u u u and uk fl where thus hu u and the directly algorithm theoretical bound is n u with n it follows that the a is no worse than n since order u of the the correctness of the algorithm by the following theorem a is theorem let fn node pl with corresponding is a path from an entry entry pool p to the node n further let a corresponding to a particular p and optimizing function of the algorithm approximate pool associated halts then pn program graph g set f which satisfy the a if pn is the final with node n when a theorem thus relates algorithm to the intuitive earlier the proof in appendix b the final output of the results which were de of theorem is given an interesting sideeffect of theorem that the order of choice of elements from a is arbitrary as given in the following is l in step corollary the final pool pn associated with each node n c upon termination of the algo rithm a ia uniquely determined independent of the order of choice of l from l in step a proof this corollary follows immediately since the proof of theorem in appendix b is independent of the choice of l since the choice of l from l in step a is arbitrary it is interesting to investigate the effects of the selection criteria upon the algo rithm the number of steps to the final solution is clearly affected by this choice no selection method has been established however to this convergence rate one might also notice that by treating accesses to l as critical sections in steps a and a the elements of l can be processed in parallel that is independent processes can be started in step a to analyze all elements of l it is important to note at this point that the algorithm a allows one to ignore the global sis and concentrate upon development of straight line code optimizing functions that is if an optimizing function f can be constructed for a sequence of code containing no alternative branches then the algorithm a can be invoked to perform the branch analysis as long aa f satisfies the conditions of the algorithm elimination global common subexpression elimination in the analysis of a programs structure in order to detect and eliminate of expressions a fundamental assumption is that it requires less execution time to store the result of a previous computation and load this value when the redundant expression is encountered as an example expressions consider the simple sequence rx of which could occur as part of an program figure shows this sequence written as a directed graph note that the redundant expression ab at node v is easily recognized the entire sion at node v is redundant however since r has the same value as ab at node u and is computed at node u of node v it is only necessary to describe an optimizing function f which detects this situation for code the algorithm a will make the function applicable u rx v w b figure an acyclic a simple computation program sequence graph representing a convenient representation for the optimizing pool in the case of common subexpression tion is a partition of a set of expressions the expressions in the partition at a particular node are those which occur before the node is at the optimizing function for common sub expression elimination the classes of the partition two expressions are placed into the same class of the partition if they are known to have equivalent values con figure for example the set of expres sions which are evaluated before node t is is empty thus pt the expressions evaluated before node u are exactly those which occur at node t including partial computations the set of partial computations at node t is since r takes the value of ab at node t r is known to be equivalent to ab thus p where the classes of the pool similarly pv and pw the expression ab at node v is redundant since ab is in the pool pv note however that the redundant expression at node v is not readily detected this is due to the fact that rx was computed at node u and as noted above the evaluation of rx is the same as evaluation of at node u in order to account for this in the output optimizing pool is added to the same class pv becomes as rx thus this process is called structuring an optimizing pool structuring consists of adding any expres sions to the partition which have operands to the one which occurs at the node being considered the entire expression at node v is then found to be redundant since the struc pool pv contains a class with an optimizing function for common sub expression elimination can now be informally stated consider each partial computation at node n e in the ex if the computation e is in a class of p then e is redundant otherwise create a new class in p containing e and add all partial computations which occur in the program graph and which have operands to e ie structure the pool p if n contains an assignment de remove from p all expressions containing d as a sion for each expression e in p containing e as a subexpression create e with d sub for e and place e in the class of e the meet operation a of the algorithm a must be defined for common subexpression elimination since the optimizing in are partitions of expressions the natural interpretation is as intersection given by classes denoted by that is c p pi h p is defined as follows let and pc n pc vc e c c is the set of expressions common to both pi and p while and pc are the classes of c in pi and p respectively thus the class of each c c c in the new partition p is derived from pi and p by the classes p c and pc for example if p a then it is easily shown that required of the meet operation ment relation is defined h has the hence properties a refine that is pi of p the ing required p if refinement on the and only if pi is a refinement relation provides the order set for the algorithm a the function fl can be stated formally and shown to have the homomorphism property required by the global analysis algorithm p k before considering fl with the algorithm ed to combine constant expression elimination an example of the use of a the function fl is extend propagation with common sub constant propagation and common elimination the common subexpression elimination optimizing function fl of section can easily be extended to include constant propagation consider for example the following segment of an algol pro gram u v uv y xy yx figure shows a program graph segment assume the entry pool pb the analysis proceeds before resulting in representing is empty up to node this ie e as pe uv note that u and v are both propagated constants in pe since they are both in classes containing constants if the expression at node e is processed as in fl the output pool is noting that u and v are in classes with constants then uv must be the propagated constant hence the constant is placed into the class of uv in the resulting partition thus f the analysis continues resulting in as before up to node h ph in the case of the f optimizing function the expression xy at no i e h is placed into a distinct class the operands x and y however are constants since they are equivalent to and respectively the expression xy is equivalent to which is already in the par thus xy is added to the class of resulting in pi similarly the output pool from node i is ly the analysis above depends upon the ability to recognize certain expressions as constants and the ability to compute the constant value of an expression when the operands are all propagated constants it is also implicit that no two constants are in the same class an optimizing constant propagation elimination can be step as follows function f which combines with common subexpression constructed from fl by a create a new class in p containing e and add all partial computations which occur in the program graph and which have operands to those of e structure the pool as before b if e does not evaluate based upon propagated to a constant value constant operands then no further processing is required same as step of fl otherwise let z be the constant value of e if z is already in the tion p then combine the class of z with the class of e in the resulting partition if z is not in the partition p then add z to the class of e the expression e becomes a propagated constant in either case the function f is stated formally and its properties are investigated elsewhere figure effects af yz e oh xy i yx a program graph of constant propagation the expression optimization expression optimization as defined earlier includes common subexpression elimination constant propagation and register optimization the first two forms of optimization are covered by the f optimizing function only register optimization needs to be considered it will be shown below that f also provides a simple form of register optimization in general global register optimization in the assignment of high speed registers and index registers throughout a program in such a manner that the number of store fetch sequences between the registers and central memory is sequences arise in two ways the first form in redundant from memory consider the sequence of expressions abc for example a straightforward translation these statements for a machine with multiple registers might be of r b r a r c r e r r r ar r r r dr note however that the operation r a is not necessary since r contains the value of the vari able a the operation dis a technique called optimization which eliminates these redundant within a basic block figure shows a program corresponding to the register operations above the f optimizing func tion is applied to each successive node in the graph resulting in the optimizing shown in the figure in particular note that pe the operation at node e assigns the variable a to the register rl since a is already in the class of r however the operation is redundant and can be e it hence the f optimizing function can be used to generalize optimization further the algorithm a extends f to allow global elimination of redundant register load operations is known by the author at this time a solution to the global register allocation problem will be aided by the analysis of live and dead variables at each node in the program graph a variable v is live at a node n if v could possibly be referenced in an expression subsequent to node n the variable v is dead otherwise re cent work has been done by kennedy using in analysis techniques to detect live and dead variables on a global basis an optimizing function f can be constructed which produces a set of live expressions at each node in the graph the detection of live expres sions requires the to proceed from the end of the program toward the beginning figure shows the graph of figure with the direction of the edges the live expressions at the beginning of the graph correspond to the live expressions at the end of program execution hence ph there are no live expressions at the end of execution the expression at node h refers to the expression r thus rl is live of node h this fact is recorded by including rl in pg pg rl since rl is assigned a new value at node g it comes a dead expression but since r is also involved in the expression rr it becomes a live expression again thus be pf the analysis continues producing the optimizing associated with each node in figure the expressions which are live at node c for example are pb lg h r o r g f figure elimination of redundant register load operations the second source of sequences arises when registers are in use and must be released for another purpose the contents of the register is stored into a central memory location and again at a later point in the program an optimal register allocation scheme would minimize the number of temporary stores this form of register tion has been treated on a local basis including algorithms which arithmetic computations in order to reduce the total number of registers required in the evaluation global register allocation has also been formulated as an integer programming problem by given that register interference and cost of data from registers is known no complete solution to the global register allocation problem figure detection of live program graph expressions in a the optimizing function live expression analysis can as follows which be informally provides stated if the expression at node n involves an ment to a variable let d be the destination of the assignment is sub expression in ed and all expressions con d become dead expressions consider each partial computation e at node n set p p u e e becomes a live expression the value of is the value of p the algorithm a can then be applied to the program graph using the optimizing tion f the exit nodes of the original graph be come t e entry nodes of the graph in addition the meet operation of the algorithm a is the set union operation u the union operation induces the partial ordering given by pi p p u p where p is the set of partial computations which occur n the program graph note that p and in this case thus all initial in the algorithm a are set to there is a simple generalization of detection of live expressions to minimum distance analysis where each live expression is by the minimum distance to an occurrence of the expres sion the optimizing in this case are sets of ordered pairs ed where e is a live expres sion and d is the minimum distance in program steps to an occurrence of e the optimizing function extends live expression analysis by a distance measure as the live sion analysis proceeds in addition the meet operation consists of both set union and a com of the corresponding to each live expression this minimum distance mation can then be used in the register replace ment decision whenever all registers are and contain live expressions the register con the live expression with the largest distance to its occurrence is examples are given in the section which follows the fz and f optimizing functions when used in conjunction with the algorithm a a tabular form for the algorithm a the processing of the algorithm a can be expressed in a tabular form the tabular form allows presentation of a number of examples and provides an intuitive basis for implementing the optimizing techniques in particular this form allows representation of the approximate optimizing at each node the elements of l and the node traversing decision as shown in table i the column labeled n contains the current node being processed i e the n in l n p in step a the column labeled pn pn a p the change in the approximate pool at node when the node is traversed in step a the column marked fn pn contains the output optimizing pool produced by traversing the node n the set are omitted for convenience of notation the last column marked l represents the set of nodes remaining to be the set l of the algorithm a the algorithm is processed as follows a the tabular form list all entry nodes and entry in the righthand columns with entry node ei in column l and associated entry pool xi in column normally there is only one entry node with the null set as an entry pool select an l from l as choose any node from column l say node n if there are no elements remaining in l then the algorithm halts the line where n was added to l con the associated output pool pi in the column eliminate l from l by cross ing out n from column l using l n pi from step scan the table from the bottom upward to the first occurrence of node n in column n the current approximate pool pn is adjacent in the column pn p a pi if node n has not appeared in column n the first approximation hence pn i a pi pi to pn and if pn s pi then go to step otherwise write the node name n in column n and the value of the new approximate pool determined by pn a pi in the column marked pn pn a pi compute the output pool based upon the new approximate pool pn in the column and write the names of the immediate successors of n in column l go back to step upon termination of this algorithm the table is scanned from bottom to top the first occurrence of each node n n is the pool associated with each in column pn pn a pi is the final for that node nodes of n which do not in column n cannot be reached an entry node and can be eliminated from the pro gram graph table i shows the analysis of the program graph given in figure using the f function the entry node set for is l a as before l is treated as a stack elements are removed from the lower right position of column l in step after processing the graph the final at each node are listed in the table opposite the nodes the final pool at node e for example is pe the final determined to those determined by the algorithm previously in section step n i c d e f u table n al o d ab e ab al ab i fn pn ai o ab e ab a e figure shows a program graph with feedback loops the analysis of this graph is given in table ii using the f function note that in step two optimizing pf applying the resulting output pool is the expression xy is placed into the class of when the partition is structured that is xy ia an expression which occurs in the program and xy is operand equivalent to thus xy must be added to the class of in the output pool the redundant expression xy is detected at node g since the final pool pg contains xy a entry f b xy cx e ux d x g xy figure a program feedback loops graph with two parallel n c g d n y y table fn pn y y y u xy y xy global live expression analysis can be formed on the program graph of figure the as ho in figure by re given that node c is the exit node of the original graph node c becomes the entry node of graph thus c in the table using the f optimizing the analysis shown in function for example the final a indicates that the expressions x y and live immediately following node a in the graph g xy d x c entry x f b xy w e ux xy are original the program ab the graph corresponding graph of to gx j g xy xy x y xy x yx y x y x y uu y x y xy x yx y xy xy y x y this tabular form can be used for processing any program graph using an optimizing function which satisfies the conditions of the algorithm a implementation notes implementation of the above optimizing tech in a practical compiler is considered below in particular the optimizer operates upon an in form of the program such as tree struc tures or augmented by branching mation the control flow analyzer accepts the in form and calls the various optimizing functions to process each basic block roughly the tabular form given previously a single stack can be used to list basic blocks corresponding to l of the tabular form pool information must be maintained for each basic block corresponding to the p p a pi column but may be discarded and replace if he node is encountered again in the analysis ie the node in column n the output optimizing found in column however can be with all immediate successors as they are produced and thus need not be main during analysis the final optimizing determined by scanning the tabular form are simply the current attached to each basic block the optimizing functions meet operations are generally using bit strings for sets pairs common subexpression requires further consideration and manipulation is particularly and corresponding simple to implement and lists for ordered elimination however since direct repre of structured partitions one approach to handling structured partitions allows direct representation of the classes but limits the number of expressions which appear a list of all subexpressions is constructed by the program an optimizing function which always returns ia useful for this scan when a partition is structured only those expres sions which occur in the expression list the set of expressions are can be further reduced by first performing live expression analysis the expressions which appear in a tion are limited to the live expressions at the point the partition is generated the use of live expression analysis before common subexpression elimination will generally reduce partition size and improve the convergence rate of the analysis algorithm a second approach to representation partitions involves the assignment of value numbers to assigned to sequence of the expressions in the optimizing a value number is a unique all elements of the same class statements integer the results abc db sa in the structured pi bd i c i next assign three classes dc by l of class the value numbers and to the and replace the expressions bc and representing the addition of elements and class pi can now be written elements and mm where n and m are value numbers in p for each such pa r p for an entry n m if found let v be number matched expression scan r for an element of the form and make a new entry if not found as above he expression n q m with value number v is then placed into the intersection p as an example consider the class intersection of the partitions pi and p given previously these partitions are represented by the value number tables similarly the sequence of assignments produces ad bc the structured partition represented p which expands to p by thus the assignment of value numbers provides a data structure whose size is linear in the number of expressions in the basic block in addition the value number representation is particularly easy to construct and use in the detection of common given two partitions p and p in value number form the meet operation p p h p can be computed the i on proceeds as follows construct a list c consisting of the number of occurrences of each value number in p the elements of c thus provide a count of the number of elements in each class of p this count is whenever an of the class is processed until the count goes to zero indicating the entire class is a list r is also maintained which gives a mapping of the class numbers in p and p to the resulting class numbers in p th elements of r are of the form indicating that value number rl from pl and value number r from p map to value number r in the resulting p r is built during the construction of p the elements of pi are scanned and processed until the classes is an identifier count corresponding of p are in pi with suppose q value number v the to vi in the list c is first next element if q does not occur in p then the of pi is selected otherwise let v be the value number corresponding to q in p r is scanned for an element vv v if not a new value number v is assigned and is added to r the identifier q is placed into p with value number v if the element selected from pi is not an identifier then it ia an expression of the form nl ml with value number vi where nl and ml are value numbers in pi assuming all operations are binary if the count of either class nl or ml is nonzero in c the processing of this expression otherwise class v in c as above the count for examine r for pairs of d a e d b e the class initially count list c for the partition val m count pi is the identifiers b d and c are processed first reducing the class counts for and to zero in c the class mapping list at this point is r the identifiers b d and c are placed into p with value numbers and respectively the ex l with value number is then processed from pi since the class counts for both and are zero based upon the mappings in r p is for an occurrence of or since occurs in p with value number r is scanned for an element of the form v and since no such element is found is added to r the expression with value number is included in p the identifier a is then processed resulting in another mapping in r a is added to p with value number fi the identifier e from pi with value number is processed a match is found in p with value number since the element is already in r e is added to p with value number lo the final value of the class list is r which can now be discarded partition p is the value of the d a e lo lo which represents the structured partition note that the predicate p pi is easily computed during this process the control flow analysis algorithm has been implemented as a optimizing module including several optimizing functions the imple is described in some detail elsewhere conclusions an algorithm been presented which in conjunction with various optimizing functions provides global program optimization optimizing functions have been described which provide con propagation common subexpression tion and a degree of register optimization the functions which have been given by no means those which are useful for tion simplifying formal identities such as ox x can be incorporated to further equivalence classes at each application of the f optimizing function in addition it may be pos to develop functions which extend live analysis to completely solve the global register allocation problem references aho a sethi r and unman j a formal approach to code optimization proceedings of a symposium on compiler optimization university of illinois at july allen f program optimization in annual review in automatic programming press a basis for program optimization ifip august ­ control flow analysis proceedings of a symposium on compiler optimization of illinois at july j a note on some compiling comm acm march b b and graham r an algorithm for translating boolean expres sions acm april p a contribution to the problem of the optimization of programs ifip august a and d tions of programs ifip august m generation of optimal code for ex via comm acm june v and d optimization of expressions in comm acm dec j global common proceedings of a on com optimization university of illinois at july and r some analysis techniques for computer programs proc second international conference of system sciences january ­ and schwartz j programming and their compilers preliminary institute of mathematical new york university languages notes sciences w compiler assignment of data items to registers ibm systems journal c k and j analysis of graphs by ordering nodes acm m and s code generation technique for large language compilers ibm systems journal r optimal code for serial and parallel computation comm acm dec technique m a compiler the computer optimization review r an algorithm arithmetic operations for coding efficient comm acm d expression optimization using unary complement operators proceedings of a symposium on compiler optimization uni of illinois at july a study of optimization using a general purpose optimizer phd thesis university ind january r the compiler conf proc c high speed compilation of efficient object code comm acm aug d compiler construction for computers john and sons nc new york hill v h schwartz h and g efficient handling of sub variables in algol compilers proc symbolic languages in data processing gordon and new york m an optimizing compiler ifip august l r r and s index register allocation acm h and w compiling techniques for boolean expressions and conditional statements in algol comm acm h compiling techniques expressions computer journal for algebraic april d on writing an optimizing trans for algol in introduction system programming academic press inc new york ibm system operating system fortran iv g and h programmers guide c international machines kennedy k a global flow analysis j of computer mathematics a vol algorithm section g global expression optimization during compilation technical report no tr university of com science group university of june a code synthesis filter for basic block optimization technical report no tr university of computer science group university of january e and c object code comm acm f a comment on index register cation comm acm sept w introduction to computer language san francisco w optimization acm july comm on compiling arithmetic expressions aug algorithms for comm acm j on the automatic of computer programs acm june j compiler effectiveness of a symposium on compiler optimization university of illinois july b and russell l algol implementation academic press inc new york and trees r on arithmetic expressions comm acm j a algorithm for determining the forward and backward compute points for a term or subscript during com computer journal aug v on the number of registers needed to evaluate arithmetic expressions bit sethi r and unman j the generation optimal code for arithmetic expressions acm oct of r some techniques for algebraic optimization with application to matrix arithmetic expressions thesis carnegie mellon university june a on programming of arithmetic comm acm aug automatic programming system of high efficiency acm l appendix a al l api a a n pa a pa l a l b ail l a pb al l cal c o a l c al c o l a c l a l l a d l a l l a e l bd e a l l bd e a pf e l d e a l c al c b d e a c al l b a l l a d l a a l pe al b d l l a a a l f pf d l c l dc l halt appendix b the proof of theorem is given below first note that given a program graph g with multiple entry nodes an augmented graph g can be con with only one entry node with entry pool the construction is as follows let fe ek be the entry node set and ex set corresponding be the pool to a particular analysis con the augmented graph g where v vi v v ee vi el the augmented graph and entry node set of f is defined for g has a single entry v the functional these nodes as mode v value vp c and c hence the analysis entry node vg proceeds with entry as if there is only pool o ie lemma if ap a then f sp vn c i pp p a proof the proof is immediate since p sp fn fn p fn p pj s lemma let x if vn pp e then fn xx proof the proof proceeds by induction on the of x denoted by cx if cx then f n fn x and the lemma is trivially true if gx k kl assume is true for all xx i k let yx and x x y fn y fn x xo proof of theorem it will induction on the path length first that be shown by consider the following proposition on n final node pn s pn and pl with entry fp for all paths of length n from the pool to node n qn e n entry the trivial case is easily proved the only node which can be reached by a path of length o from the entry node pi is pi itself hence it is only necessary to show that p s o this is p ­ immediate however since p is initially placed into l in step al an in step a as l p but is initially and hence p pi in step a thus p in step as thus it follows that p os p ­ ­ suppose the proposition is true for for ko that is pn s fp fp for all paths of length less than k to node n for each node n c n all nk pi let k c a path of length will be shown that p s k it g consider each immediate predecessor in let p denote one such predecessor and let t f pk by inductive hypothesis s t it will be shown that pk s since p is the final approximation to the pool at pk in step a but lemma the pair must have been added to l by be processed in step a before the algorithm halts thus either pk in step a or a in either case p but pk s s pk s pk thus since the proposition holds for paths of length k it follows by induction that the tion is true for all paths from the entry node to node n for all n c n the following claim will be proved show that xn p for all n n in order to the processing g by the g has not been encountered where p is the current in step a or approximate pool associated with no e n for all n q n the proof proceeds by induction on the number of times step a has been executed suppose step a has been executed only once then l pq and the only encountered in step a is the entry node pi the entry pool corresponds to a path of length zero from pi to pi thus f pi p trivially true since and the proposition is suppose that either n has not been encountered in step a or step a has been executed nk times kl the kth execution of step a let l nt where t for some n s the pair nt was added to l when the node n was processed in the nth execution of step a for nk hence t by inductive hypothesis but using lemma a s v paths fp fn a v paths p pn s n t using lemma if this step is the first occurrence of node n then for any n c p e p t since i in this case after step a suppose this is not first occurrence of node n in step a pn the step a is executed hence the proposition for each execution of step a in particular holds xn pn q n c n upon termination of the algorithm a hence the theorem is proved since 
conference record of the fifth annual acm symposium on principles of programming languages a partial evaluator iterative laboratory and its statements by use for compiling in lisp university abstract a partial evaluation program for lisp is described and an application where it has been used the partial evaluator performs a number of other related operations such as opening of functions and certain optimizations on programs the application is based on the fact that we can generate from an interpreter and a partial evaluator the same object code as a corresponding compiler should do the paper will first formally describe the relationship between an interpreter and a compiler through partial evaluation the partial evaluator system is then briefly described and finally an experiment is shown where an interpreter for the iterative statement in is partially evaluated introduction this paper describes partial evaluation program for and an application where it has been used the partial evaluator performs a number of other related operations such as opening of functions and certain optimizations on programs it operates on almost full lisp in the and unlike previously reported partial evaluators it is not restricted to a small subset or a language the application is based on the fact that we can generate from an interpreter and a partial evaluator the same object code as a corresponding compiler should do a correspondence first mentioned by this research was by the natural science research under contract f partial evaluation has long been known as a promising method to implement languages language extensions and special purpose languages and has been used by several researchers a discussion and a survey of the use of partial evaluators are found in et al in which it is that this technique if properly developed and can be a very useful tool in practical program development an improved program manipulation system called the system is described in it uses partial evaluation as its central operation the experiment reported here has been carried out in that system and the work demonstrates that the technique is practical in section we will formally describe the relationship between an interpreter and a compiler through partial evaluation in section we will describe our system and in section report an experiment with an interpreter used for the iterative statement feature found in in section we will draw some conclusions of the practical use of this technique and propose some directions for further work partial evaluation partial evaluation in simplified form is a technique can be described which as suppose s is a xl x first m arguments vm a generated by that procedure of n arguments xn and the values of the are known as vi v new procedure s can be partial evaluation such xn vm xml xn for all xi if p is the partial we have the relations evaluation algorithm xr xn xn xn we call partial remaining variables the variables evaluation variables xi variables the the and the runtime suppose assume expression environment association suppose following we have an interpreter i that it takes two arguments expr to interpret and env for example lisp if expr is known we can derive relation we an an the we the i env the program i is accordingly a specialized version of the interpreter i which only can interpret expr in different environments env the program i is an object program for expr if we on the other hand have a c and compile expr we obtain env i env if we assume the compiler then it holds that the interpreter c are that i and compatible if p is good enough in practice if there exist both an interpreter and a compiler they are usual ly not fully compatible with each other such as the interpreter and the compiler in lisp which do not always agree the next step the partial respect to the then obtain is to partially evaluator interpreter evaluate p itself with i we will p pi expr env env from that have from and is in an interpreter we a compiler generating can c a conclude here we compiler if we go on further and want to generate compilers for different interpreters then we want to partially evaluate p with respect to p itself we would then an conversion program we have the relations ppp i exp env exp env env env ie ppp i generates c and is the conversion program ppp if this theoretical reasoning can be realized as a computer program such program is useful it is easier to write an interpreter than the corresponding compiler an interpreter often to be more and therefore easier to understand and maintain an interpreter however is not as efficient to use as a compiler and therefore in most applications a compiler had to be written the question partial implement practice is can we construct evaluation algorithm it so it could be used a and in in the ideal case such a partial evaluator should be able to handle an interpreter wr without any restrictions on the programming language although it is probably a restriction if some of the most constructs in the language were not used or used in a restricted way a call to the function eval in lisp can be if the evaluator has no information at all about what can be evaluated through that function call when the partial evaluator is applied to itself it must naturally also be written with these restrictions in mind it is not clear if we ever will be able to produce a practical conversion program through running ppp another program simple rather way to go directly we such program which simple code and is to write that have written a only handles is described in further demands are that the partial evaluator must be written efficiently enough so it can be used in practice and the partial must be powerful enough so the resulting as good as the compiler object generated code is code gives description algorithm but small examples in his paper of a partial evaluation he had only run rather through it a partial evaluation useful unless it operations such and various types it is important in itself is not so is combined with other as opening of functions of and to consider how such operations partial are evaluation incorporated algorithm with the the partial system evaluator in the we will first describe a partial evaluation then briefly describe system in principle how algorithm the works and in principle a partial evaluation algorithm p works as follows p takes two arguments a program s and the set of partial evaluation variables pv p will be recursively applied to all expressions and subexpressions in s variables in pv are replaced by their values whenever this operation yields any expression which contains only known values that expression will be evaluated this assumes that we have no sideeffects involved otherwise the expression normally must remain as it is and its evaluation is until runtime in conditionals if the predicate is known either its true or false branch and the predicate as well can be eliminated assignments found in the processed program must be taken care of and pv must be updated according to them the partial evaluation algorithm in denoted works as above it can however also handle cases when although we do not know the value a variable will have we know the set of possible values of the variable or know some values a variable can not have or know the of the values a variable can be bound to such variables must be treated as runtime variables we denote and must remain such variables in the code rv for an expression which contains such variables the system tries to calculate its value range and these values can be useful in order to discard parts of the processed program such ranges are determined by the system either through repeated of the expression with different values combinations or by invoking of argument so called semantic procedures associated with a function by which of the value range can be performed all functions used in s must be depending on which operations are allowed to be performed on them there are functions which are pure in the sense that they can be evaluated at partial evaluation time if all arguments are known functions which either perform or depend on sideeffects and functions which evaluate their arguments in a nonstandard fashion which must be treated the system also performs other transformations and optimization it provides a facility to open procedures in various such as insertion of etc and perform transformations in the code from rules given by the user for expressions there are for structure and for the assignments made in the various branches after partial evaluation has been carried out in a expression there are a number of transformations of a more nature such as removing local variables not used any longer removing unnecessary assignments eliminating dead code and the the full system is large lisp program it takes pages to print in and words on our dec a quite about format in the computer an experiment in order to test the power of our system we performed the following experiment with results an interpreter denoted s which previously had been written at our lab was taken as test example the interpreter had been written lisp programmer without knowing anything about our ideas about partial evaluation of interpreters or that the program would be used as a test case for our system the program s the iterative statement feature found in this feature allows for example following constructs for i in al for x from to do print collect car in l join cdr x when x i the implementation uses the compiler approach and compiler denoted translates th iterative statement to efficient we have here which tn is executed the cases and from section our expectation was that from an expression of the form where is the system interpreter and expr iterative statement we would be produce object code as good compiler in would do through s is is an able to as the we could naturally not expect to generate interpreter by different assumptions the same and the code because the compiler are written and with different notice that both the implementation and interpreter are language extensions in lisp in the sense that they are transformed to conventional lisp code which can be interpret by the lisp interpreter or compiled to machine code using the lisp compiler the interpreter such a way s is implemented that it first in the iterative statement during that step a number of variables are bound to values which fully describe the statement in a second step an is called which executes the on these variables statement in our depending experiment the parsing step can remain as it is and is called at partial evaluation time the main task is then to partially evaluate these the variables with with respect to known values produced in the parser step the is a program about code is shown in appendix idea of the complexity system can handle some other examples are with a size of lines and its to give of code an our in appendix given we will simple here statement give the code for the for i from to do print i our method gives prog lp i setq setq i t go out out print setq nil i i setq go lp return nil plus and the compiler in produces prog lp val setq cond i i return i val lo print i iterate setq i go lp i both expressions can of course compiled to machine code using the be lisp compiler in comparison there is no real difference between these t wo the in depends on the design in the implementation of the interpreter version it uses a local variable as an internal loop variable and a change of the external loop variable will not change the internal one in the compiler implementation the loop variable i can be affected in the loop body ­ some problems actually there was one change in the original s program in order to produce this code the function see appendix was first written iteratively as a prog with a simple loop the calls to that function were of such nature that one wants to the loop in order to get good code out of it unrolling of loops has not yet been incorporated in the system this problem was solved s imply by the function to a recursive one by opening the function recursively the desired code was achieved another problem is partial evaluation of loops points out this problem in and that his partial evaluation algorithm may not terminate if the loop is not good enough for us the problem is that when variables in pv and rv are assigned ins the loop such assignments must be considered before the partial evaluation of the loop takes place it can then happen that an assignment affects pv or rv but that the assignment will later because the code containing it is eliminated a simple example setq setq cond cond a b eq eq b a setq a foo x y go we assume there are no other assignments of a and b inside the loop the of in the loop will report that a may be assigned there to the value will therefore conclude that after the label the variable a may have either or as value b can only be this means that c m eliminate the first but must leave the second one however if we simply perform another complete iteration of assignment analysis and partial evaluation the second will also be eliminated however always even help more iterations s there may not may be an assignment to a variable which depends on a condition which includes that same variable actually there was such a case in this experiment simplified it appeared as prog a setq and a a setq a in this case failed to but solved by manually giving the analyzer program that no assignment of a can inside the loop eliminate the problem was the help to in this case be performed figures in the example it took the system about seconds cpu time to to produce the code the system was straightforwardly compiled some more efficiency could be obtained through and compilation of all procedures stored on property lists as comparison the compiler takes seconds cpu time to compile the functions those shown in appendix conclusions by our partial evaluator and the experiment we have shown that this method is useful in practice to compile expressions from the interpreter has obviously its and is useful in applications when the compilation is not performed too often and there is no point in resources to build a real compiler we will extend our work to experiment with other interpreters a greater would be to generate the compiler from the interpreter in order to achieve this goal there are at least two major questions the first question is how powerful the partial evaluation algorithm has to be in order to handle itself or if the partial evaluator can be written in such a way that it is possible if it is not possible one way to go is to write another partial evaluator which is simpler but still powerful enough to handle interpreters written with some restrictions the goal is then that generates a useful compiler the other question optimizations perform conventional compiler incorporated in the generated normally such optimizations included in the interpreter how by can compiler are the b not acknowledgements thanks to for reading this paper and for giving valuable comments and to who the interpreter for the iterative statement which were an test case for our system references w manual xerox palo alto center reference research y computer programs and partial of an approach to a j inst communication p the interactive verifier phd thesis xerox center palo alto ca program research b transformation third acm principles of programming program symposium on compilation ap on the essence computing center of sciences of l a o e a partial evaluator a its use as a programming tool artificial intelligence journal a manipulation system based evaluation phd thesis laboratory a program on partial university appendix we will here show the lisp code those functions in the iterative statement package that was partially evaluated by the system in experiment described in section code is shown here to give the reader idea of the complexity of code system can for the the n our lambda nil prog t go out skip go iterate nil setq do nil collect setq cons join cond setq cons last t cdr last cdr sm plus and always cond null never il setq nil go out cond eq quote in car range left t range left go out iterate and quote and t go out go lp out finally return join car collect lambda nil set cond in car range left t sum always never o setq t nil lambda nil or never dynamic is where to was not given dynamic only first time through and is numeric see and the nil cond not cases see o to left t and quote while and t and quote when and t quote skip lambda nil in car on generator set prog tmp set plus the dynamic case see am or quote dynamic and set lambda nil quote in set lambda l r r constant l number function apply l r function l eval lambda l cond l r fn v r l t cdr l r fn apply fn car l the last function compared has here with the original been one in package discussion in section in the compare report let us follow the example for i from to do print i when all the parsing step the following and given to free variables from the have been bound to values expression was set up the partial evaluator prog quote i quote from to do print i quote from quote number nil quote number quote quote number nil nil quote do quote print i nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil quote i return prog i return all the functions from the iterative statement package shown here are functions which are through ie the procedure body replaces the procedure call with appropriate substitutions after partial evaluation and other optimizations in this code we obtain the final code as prog lp out i setq setq i t go out print nil setq i setq plus l go lp return nil appendix some further examples experiment reported in section examples will only show produced from the partial step with from the these the code evaluation the statement for i from to n by sum i will cause produced the following code to be prog lp out i setq setq i setq n setq o t go out nil setq i setq plus setq i setq plus go lp return the statement in al collect car which in lisp corresponds to al function car will cause produced the following code to be prog lp out setq al setq car t go out nil setq car setq cons setq car setq setq cdr go lp return the statement for x in and l join cdr x eq car x x when quote a which in l in which the atom a will cause be produced cdr of those first element the following is the code to prog x setq l setq x car lp or and t and x eq car x quote a t quote skip t go out skip go iterate nil setq cdr x cond setq cons last t cdr last cdr iterate setq x car setq setq x cdr x go lp out return car 
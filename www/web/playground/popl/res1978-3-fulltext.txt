conference record of the fifth annual acm symposium on principles of programming languages polymorphism data types as typechecking encapsulation alan james demers computer science department cornell university ny abstract this paper describes a novel approach to the treatment of data types in programming languages which allows a simple interpretation of or generic procedures makes a simple set of typechecking rules semantically and provides a straightforward treatment of encapsulation introduction one of the goals of research in programming languages is the of the underlying con of languages ie those basic ideas that allow us to understand the relations among various language features this paper presents a novel approach to the treatment of data types inspired by the work of scott that allows us to several aspects of the design of data type and manipulation facilities in programming languages in the next section we show how data types may be treated as values in a lan guage while not considering the possibility of data type variables we treat data types as semantically meaningful arguments to procedures functions and data types we then show in sections how this view of data types allows a simple treatment of generic or poly procedures preserving full static and having no difficulties with recursion how a simple rule for typechecking can be justified by our treatment of types and polymorphism and how a general encapsulation mechanism can be developed as a natural consequence of the basic ideas inherent in a poly language in this we achieve from a basic view principles a of concept of data types and some of language design we show how t work was partially science foundation grant grant af c supported by national and some rather powerful language constructs can be added to a language like pascal because of this we argue that the approach captures well the underlying concept of data type the examples used in this paper are written in the programming language russell russell ie syntactically to clu liskov et al et al and et al indeed many of our design goals were identical with those of these efforts what is new with however is the seman tic treatment of data types the thesis of this paper is that the new semantics has us well data types a central question of language design especially for languages like russell is what is a data type that a generally accepted answer has not been reached can be seen by looking at the recent acm conference on data sigplan where several varying definitions are given the paper by and is particularly in this regard below we present an approach which may be most simply characterized as types are sets of operations more common approach and contrast typ es are sets it with the of values ing our view of data types is the follow a data type an interpretation value space is a set of of operations specifying values of a universal to define work of calculus approach what we mean by this whose models of provided the we draw from the the untyped lambda for this in scott describes several un domains continuous lattices or value spaces ie domains that contain their own continuous importance function spaces the immediate of such domains is that they allow a simple definition of languages that allow self application for example like the untyped lambda in the lambda expression calculus the identifier x simultaneously stands for a function and its argument which makes sense only for values in a universal domain these domains exhibit another interesting characteristic as scott shows they may be viewed both as ie consisting of only a single type and as infinitely typed ie as being com of elements of an infinite hierarchy of more and more complicated types thus we may the question of whether each value belongs to only one type as in hoare in one sense the question is since there is only one type on the other hand we may say without infinitely contradiction many types that it all a value depends belongs to on how we wish to view the domain even more surprisingly scott shows how data types themselves may be regarded as elements of a universal domain using the notion of a a is a continuous function such that ff have the property that their ranges are proper of a domain thus we may consider as the data types of a universal domain either the proper or the of the space with these as their ranges but the of a domain are elements of the domain since the domain contains its function space thus the data types of a universal domain are themselves values of the domain the of a universal domain d may be viewed as defining how each element of the space may be interpreted in the sense of out the meaning of as a value in the given by the range of the remember that a is a function f such that thus a f of d d onto the range of f and is the identity function on each value in its ie f maps each element of d into its image in the given by the range of the as was shown in scott this use of as the single operation interpreting values of a universal space is precisely the notion of data type needed to give the semantics of typed lambda calculus variants but what has this to do with data types in more common programming languages a good deal we argue we can find natural of universal domains on von machines and can treat type definitions in algollike languages as sets of operations giving the interpretations of such domains first the elegant and universal domains constructed by scott have a in the memory of most machines one of most obvious characteristics of the underlying hard of most machines is its the same sequence of bits may be used to represent logical values integers floating point values and pieces of program that manipulate any of the preceding moreover this domain of bit sequences is universal because of the of program and data more importantly data types in algollike languages can be understood as sets of operations giving the interpretation of values of this space consider for example a language like algol which has only primitive types more complicated examples will be seen later in the paper in such a language we may store values in variables extract values from variables and compose values by application of certain tive functions our approach to data types takes the universal domain of bit strings as the value space and the meaning of this set of primitive operations over this space as the meaning of a data type for example program fragment consider the following algol integer xy y x we take integer as the meaning or denotation of the meaning of value extraction so we know which bits of the value of the variable x to use on the side of the assignment y x the meaning of assignment so we know how many bits of the result to store in y and the meaning of the ie which bit sequence o function represents o two points need to be raised here first although we discuss a particular universal domain in this paper our approach is not limited to any particular domain of values l model would do just as well sequences of bits do have an intuitive however second what set of operations provides an interpretation is obviously a matter are sufficient for the lambda calculus while a more complicated set is required for pascal but the basic approach works in both cases this approach to data types is obviously similar to the idea of algebraic specification described by in its focus on the set of operations provided by a type it differs from the algebraic view of types in two important aspects the use of a universal domain does not appear in the algebraic approach this makes our approach somewhat more concrete but it is necessary to the of data types aa values the algebraic approach seems most useful in considering properties of data types our approach is motivated from a more general interest in understanding data types in a wide variety of languages including those like algol or typed lambda calculi that have no type definition mechanisms thus the set of operations a type using our approach includes operations like value extraction that would not appear in algebraic specifications this approach has a less obvious connection with the more common types are sets of values approach but we can find a way to treat our set of operations as defining set of values through the use of another if we use the standard mathematical semantics cf and meaning for the value ex and assignment operations eg value extraction is defined by a function s for and el and assignment is defined by function v s for where v is the domain then we must have that for all and s a s of type vv must be a and the range of this has a natural interpretation it is the set of values which may be assigned to variables of the type ie the definition of data type given in and for example if we decide to represent integers by bit values then the range of this for the type integer would be we have now described what is meant by universal space and set of operations providing an interpretation ie we have said what we mean by data type but have we anything by this approach yes we now have a means of handling types as parameters to proce function or types independently of any particular type argument consider the pascal like definition function identity type identity x end t val xt t where we have parameterized identity to a type t the meaning of can now be understood as follows with the parameters the value parameter x is simply seen as for some value from the universal domain of bit strings which will be interpreted in the body of the function as an element of a particular and the type parameter t stands for an of the elements of space ie the set of operations used within the body of identity and this set of operations can be treated as just the natural extension of procedure and function parameters already allowed in many existing languages so we can now give a meaning to constructs independent of any particular arguments applied to these we consider this constructs in the next section point in more detail giving the syntax and semantics of polymorphic constructs in russell as we show in section this view of data types also allows us to adopt a simple rule for determining type compatibility and in the final section of the paper we show how the russell treatment of data types is affected by our view of data types polymorphism in this section we continue the discussion polymorphism in section by giving specific details of the syntax and semantics of polymorphic constructs in russell we begin by discussing procedures only then show how the extension to polymorphic type definitions can be made in a straightforward way of the syntax of polymorphic procedures in russell is similar to that used in clu or details important to our discussion are illustrated by the following procedure proc update type ta with function f ta integer var field cnt integer var a array for i ln loop n of ta end end update the syntax of the body of is no different from that procedure body and should the only new elements are and its associated with a polymorphic procedure of a present few problems the type parameter clause the type parameter naturally enough specifies that the corresponding argument must be a data type value the with clause lists those operations which must be provided by the type argument in any legal call in particular the with clause for ta in update requires that any type argument supplied for ta include a function f map values of the type to integers as well as an integer field cnt other operations which can be specified in a with list include declaration q assignment and equality treated as a selector function a field is returning left values thus the inclusion of a field in a type parameter specification is not with our basic view of a type as a set of operations that interpret values in a universal domain constructs similar to the with specification appear in other languages for example the notation in et al and the where has specification in clu liskov et al the most obvious purpose for these constructs is to allow the body of a polymorphic procedure to be only once independent of any arguments which may be supplied in calls of it the procedure body is in the usual way under the assumption that the only operations supplied by the type parameter are those listed in its with specification for now we rely on the understanding of the usual way of typechecking this point is discussed in section procedure calls are checked to ensure that each type argument includes at least those operations listed in the pending with clause our goal of demands however that with should have a semantic purpose as well other we should be with ing the user with syntax and our treatment of data types gives with an obvious meaning in the terms of the transmission of data type arguments to procedures within the body of a polymorphic procedure a type parameter denotes a type value that is a set those operations specified in its with clause an acceptable argument provides those operations and perhaps others as well the semantics of argument transmission in russell re that the type argument be transformed to match the parameter specification of course this transformation is straightforward it merely in selecting from the type argument just those operations listed in the the with clause has both syntactic and semantic im syntactically it allows static type checking of polymorphic procedures semantically it specifies the transformation to be performed on a type argument when it is passed except for this transformation which can be viewed as a very simple form of coercion passing a type argument is not essentially different from passing any other kind of value the treatment of polymorphism in russell which follows directly from our approach to data types has several advantages over the more obvious approach of treating a polymorphic as a macro or procedure scheme and it for each call most obviously we are permitted to typecheck the body of the procedure just once not for each call more important however is the gain in conceptual since data types are values of a pro with respect to a data type is no different from of a procedure with respect to any other value we do not or procedures except as an optimization given the right interpretation of data type there is no need to polymorphic ones this symmetry of polymorphic and non polymorphic procedures also allows us to know that recursive polymorphic procedures present no special difficulties either in typechecking or tation as and show this is not true using the macro expansion approach and just as we may pass procedures as arguments to other procedures we may pass polymorphic procedures as arguments something we at first were to discover we close this section with of polymorphic type definitions extend our polymorphic procedure definitions like the a brief discussion how easily can we mechanism to allow polymorphic stack type stack type t with end the answer can be seen in our definition as a set of operations since have the ability to define polymorphic no semantic extension is required at of a type we already operations all a polymorphic type definition is simply a general of a polymorphic operation ie proce or function definition in that it defines a set of operations rather than a just single one the only minor technical difference is that a type definition must also provide meanings for opera tions like declaration and value extraction which the programmer cannot define explicitly but the basic idea remains unchanged again our goal of typechecking in the preceding sections we have assumed the reader was to an informal ment of typechecking in this section we show how the need for syntactic typechecking can be motivated from our approach to data types and how a particular the treatment rule of follows of polymorphism in the language from typechecking refers to the common sensitive restrictions placed on programs the compatibility of the type attributes identifiers and expressions for example russell program fragment on of the var x integer var y boolean y true y is said to be illegal because of the of the type attributes integer and boolean of x and y in shows that such type checking rules serve as an effective means of re the frequency of errors in programs how ever as a redundancy leaves open the question of how much typechecking should be performed we give an answer to this question based on our approach to data types remember our earlier description of data types as providing interpretations of values of a space because of the nature of such a any operation may be applied to any value in the space however were we to ignore type in in russell programs our language would allow programs with representation semantics for example the value ­ by following program fragment would depend on which value in the universal space was used to represent the boolean true var x integer var y boolean y true x y print x exactly this effect external procedures may be achieved using in some implementations certainly we wish our semantics to be free of such dependencies if only to allow the tor as much freedom as possible in we were able to show that typechecking is to guarantee representation independence and the thesis of contains a proof that checking syntactic type compatibility along with a careful treatment of union types is sufficient to guarantee representation of russell semantics the question of when the type attributes of two variables compatible is somewhat by the introduction of type declarations for example the following pascal fragment type t integer var x integer var y t x o y x is this program wellformed ie should the assignment y x be allowed various answers this question have been presented in the ture to the pascal report interestingly says nothing about this question one way or the other the report et al states that the program is correct a type name is regarded as a for its definition the designer of regard the equivalent of the preceding program as in we have adopted the approach each type definition specifies a distinct type thus we regard two type attributes as compatible iff they are the same type identifier or for types the same type identifier applied to compatible arguments as we argue below this choice is not at all arbitrary in fact it is by our view of data types and polymorphism the justification of our particular to follows from the principle of correspondence suggested by this principle is that declarative and parametric forms should be semantically equivalent thus the context of the question at hand the program fragment in should t integer var x integer var y t x o y x be semantically equivalent to procedure t with var x integer var y t x o yx end p integer q where we have simply replaced the declaration of t with the of the following block with respect to t note that in doing the transformation we also must make explicit those operations ing this provided principle by t the reasons for adopt is there is no over reason to regard the two mechanisms as so we are to make sure that we keep them identical the must regard a type are first declaration of the form we type t t as having the following semantics the meaning of tie the set of operations it provides is taken from the meaning of t also a must have a meaning independent of what type appears on the righthand side of a type declaration as long as the type provides the operations necessary to per form the evaluation of the body of the program this means that for the program fragment given above where the only are variable tion and assignment there should be no fundamental difference between the program fragment beginning with type t integer and the same fragment beginning with t boolean since both provide the the body of the fragment look at the polymorphic necessary put procedure operations another way used in if we procedure var var end p t x integer y t x o p yx the types providing ment will integer or boolean or any other type the operations of declaration and assign be acceptable arguments to p the second point is that the program ment given above must then be the program only seems correct because of the declaration of t as the same as integer should t be declared as anything else the program must be invalid if we are to hope to achieve a repre ­ independent semantics we would allow implicit coercions between integers and whatever ts were but because of our treatment of type declarations we may not depend on the identity of t and integer ­ any type other than integer providing the same operations must be treated similarly so the program must be incorrect note that were we to adopt the macro expansion view of polymorphism discussed in previous section the rule of a type is a for its definition would become the more natural interpretation of type compatibility using this rule just as the name is type var t integer x integer x o y x while type var var t boolean x integer y t xo y x is so one call of a polymorphic procedure could be considered while another call might be this suggests one reason to prefer our view of types and to the macro expansion approach it allows a more abstract treatment of and polymorphism any call of a polymorphic procedure for which the argument and parameters match is correct independent of the identity of the argument furthermore the rule that type attributes of two variables are compatible iff they are identical is a particularly elegant and simple rule the alternative requires much more space to state precisely cf et al pp encapsulation a type separation type encapsulation of a concrete from its use facility allows the realization of an ab in a program et al p thus the primary function is one of access control ­ it enables programmer to specify which operations the are able to the only within significant abstract the type question program and which are known definition itself then the to answer in language design is what w should not be hidden from the user of a type to make data types abstract for example both clu and include the notion of the representation of an type specification of a types representation is separated syntactically from the specification of its operations and all details of the repre are automatically hidden from the ab program as a consequence a degree of independence is the abstract program has no access to details of representation and so cannot depend on them directly the is that representations for distinct abstract types defined in a correct program can be chosen arbitrarily and independently type encapsulation in russell is closer in spirit to or et al anything declared within a type definition can be exported or hidden and there is no explicit representation component of a type definition an type definition has the basic form id exports end the is syntactically and as we shall see semantically identical to the with list occurring in a type parameter specification thus fields ie components of the types tion as well as operations can be exported a fundamental advantage of our export mechanism is that it can be defined without intro any new semantic ideas given our view of types and polymorphism we can treat the exports clause in a declaration as semantically equivalent to a type parameter specification in a polymorphic given below procedure by doing the details this we gain are conceptual and maintain a symmetry between declaration and we illustrate with an example taken from jones and liskov the example involves an abstract type account providing a set of operations for account number determination etc the problem is to write a procedure which sorts an array of account values by account number but is from reading or any account balance consider first a russell implementation the account type itself in the implementation would appear as follows of form type exports account proc proc readonly field int end just as in or clu this declaration the program into an inner region in which all details of the types representation are known and an outer region in which the type is viewed abstractly and only those operations listed in the exports clause are available as declared above the abstract type account provides operations such as with draw which can read and modify an account balance our task is to write a procedure which can manipulate account values in order to sort them but is from accessing their in any way this requires that operations like be hidden from in much the same way that details of representation are hidden from the abstract pro gram the solution in russell is to make a polymorphic procedure type as an argument itself looks like and supply the the procedure proc type with readonly field var a array ln of body of end t jones and liskov is a discussion of pro rather than encapsulation many of the me issues arise especially given our view of encapsulation as selective hiding the interested reader is to compare their solution in their with ours the essential treatment of access difference lies as separate entities their procedure can sort an array of values provided the right to access the function is ours can sort an array of any type provided the type an field the calling program contains var b array n of b just as of the type with the original we can identify definition two distinct of views in the the abstract procedure all type properties of are known in the body of the only available operations namely and are those explicitly listed in the with clause of the parameter specification these two views of the type correspond exactly to the inner and outer views provided by a cap definition thus the definition of en types requires no new semantic notions the necessary machinery is already provided by our view of polymorphism we can treat an en type definition as syntactic shorthand for an equivalent construct obtained using exactly the same program trans formation discussed in section in connection with type equivalence the program type t exports body end program body is exactly when with respect is supplied equivalent to the program which re the program body is parameterized to t and then the definition of t as an argument proc p type t with program body export end type t exports body all end g list we believe this approach yields greater and simplicity than could otherwise be achieved there is a single set of rules and a single syntax for describing and limiting the set of operations provided by a type in addition we maintain an exact correspondence between our declarative and parametric the access control available at boundaries is in no way different from that available for type parameter specification conclusions we have treatment of and discussed described a new approach data types in programming the implications of this to the languages approach for the turn to approach design of russell in conclusion we re the main thesis of this paper that this s a useful tool in language design we strongly believe in the that the language designers task is not hoare for us this has meant trying to find a small set of basic ideas that would allow us to understand existing languages and to justify or validate our design decisions in russell these we below our treatment of data types allows a simple means of handling polymorphism types are values and thus legal arguments to procedures functions or types moreover as we argued in section our view of types that of types as sets of values it just depends on whether you look at the or its range the idea of a semantics discussed in section is the justification for the requirement of typechecking thus leading to a theorem to show the correctness of our typechecking rules the principle of correspondence is the justification of our rule for type compatibility and a for the treatment of type declarations it of this we were is in the design of work significant that that most first type parameters to definitions could be allowed as both clu and indicate type parameters are a necessary aspect of a general type definition facility we in advance that these could be handled giving us one less ball to definitions would not affect the typechecking rules of the language by our to the principle of the rule for is formulated independently of what may appear to the right of the equal sign in a definition of the form type t thus whatever form eventually took we that their introduction should not cause us to alter the type checking rules in fact had we been forced to make a special case we should have known immediately that our design had second success in is reflected in the degree which we may explain in terms of types and polymorphism data types are sets of operations merely provide a means to collect opera tions together to form a set ie to declare userdefined data types in polymorphic operations allows us to some operations included in the argument type exports lists in simply provide a syntactic shorthand for a use of this general mechanism thus we claim are not in two they are similar to clu clusters forms and modules in ones similarity with ones may seem but part of our goal was to develop ideas to simplify and generalize the work of others thus we would be most had been completely they may be understood without the in of major all of the ideas needed are present in other parts of the language thus a valid test of the correctness of our sign becomes how little additional we need to explain or indeed any other particular feature of the language we are writing an informal russell report and a formal semantics for the language which will appear in thesis our goal is to guarantee that the entire language shows the same to first principles as that part of it described above references james on cornell department june the semantics of computer data types tr jd an experimental evaluation data type conventions cacm r of f and david and data types in highlevel june p some ideas on languages john w the tion to university of specification of abstract technical and types report john development june abstract of data p data types and the structures cacm hoare car notes on data in dijkstra and hoare programming academic structuring structured hoare car hoare design conference symposium on principles october on programming language record of of programming languages and and manual and report second verlag edition pascal user springer jones and liskov k jones and age extension for expressing access technical h a constraints report april data h in sigplan a p visibility and types et al bw jj rl london mitchell and gl report on the programming language sigplan notices february liskov et al alan and craig in clu cacm abstraction mechanisms p and r and c ming language semantics a theory of program press and dl john e and david abstract types defined as classes of in sigplan p variables scott d scott computing data types as september lattices siam j d cacm logic and september programming sigplan proceedings of conference on definition and volume special issue data rd language semantic principles pp design methods acts informatica based on et al william london and abstraction introduction and verification in to language and research report june william private 
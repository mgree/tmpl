a robert l scott d johnson department of cornell computer university ny science abstract is a new formal system which commands and assertions it includes axioms and rules for a theory of programming over integers and characters since arguments in the theory can be checked by the proof checker the system offers an approach to mechanical program verification the proof checker is efficient enough for classroom use early experience with indicates that it supports formal verification of elementary arguments con work should enable the formalization of reason ing as well introduction overview here is a brief presentation and dis of a new formal system which commands and assertions the system contains a programming language whose can be compiled and ed the rules for writing arguments con a formal logic including a theory of the predicate calculus a theory cf ar aid a of programming the system offers a style of mechanically reasoning in that arguments in the calculus can be checked by the checker since these arguments can be about programs the system provides a new approach to verification the system illustrates several interesting principles cf programming languages the ideas and techniques used to make high level programming languages are employed to make this high this work was supported grants in part by nsf and el logic eg block structuring of proofs highly flexible definition and abbreviation facilities with ordinary mathematics etc moreover the implementation was designed to make proof checking efficient but for a few well exceptions in arithmetic and checking the system is the first working example of a new type of programming system i n which the logical and languages are in the is novel yet simple and the implementation permits experimental verification of a type dis from that possible in other cation systems principles the design of was in a system was tested in the version described here was available as of july the design was by experience with the pi lot system and a few simple criteria which we enumerate from the a to investigate of modern concepts computing suggests that the command language should be the core of an algollike procedural language restricted to commands for which simple rules can be found as in pascal see experience with mathematical reasoning and nearly a years of study by suggests that the deductive structure of the system should be based on the familiar and wellknown predicate calculus to permit compact natural ex of computational reasoning the steps of an argument should allow commands and programs hence ic in the of arguments are programs especially long ones should permit arguments within them as in the programs of unnecessary notation should be avoided we do not use primitive nor do we introduce special ele ments to denote undefined objects the only notation used is that of ordinary mathematics and procedural programming along with syntax to combine them it should be for ple to write and read complete formal proofs in the system hence the formal system should as closely as possible informal methods we therefore adopt the natural deduction style calculus of and this system should be to ordinary formal proofs as al is to turing machines and it should be as to the average pro as algol is the formal proofs should be good documentation for the reasoning behind the program thus it must be possible to ar directly about the program without translating it entirely into logic as is done in most other eg pascal system system etc it should be possible to check the correctness of these formal arguments with a computer the use of the proof checker should be enough to tation with the system and to permit its use in the classroom based on our experience dealing with partial correctness we believe the logic should be confined to describing terminating computations commands cannot be introduced into an argument unless they are shown to terminate partial correct ness arguments can be considered only by explicitly assuming termination the first version of the system should meet the above goals on the class of elementary arguments encountered in be in program ming and discrete mathematics modern logic has provided an organization of mathematics which makes it possible to at least roughly this class of elementary arguments by beginning with these we can concentrate on the issues of whether a logic f this type is feasible at all if we succeed cn the elementary arguments we can then examine more com e g that user defined data types higher type functions etc comparison with other systems the command language of is a subset cf which is accepted by the and compilers the stanford pascal verifier in that its command language is a subset of an algollike language however unlike the pascal verifier not translate programs into the predicate cal but instead rules for directly about in this regard the system is calculus similar to unlike the stanford pascal verifier and all other program we know does not employ a theorem prover instead arguments are checked by a proof checker in this regard the system is similar to and fol although we have been particularly en by the success of methods uses a number of decision procedures and automatic rules which allow the user to take fairly large proof steps unlike for lisp or variants such as typed lisp and milners with procedural languages is their actions e g assignment the log ic does not consider its domains to be lattices or cpos as in it deals directly with partial functions over in and strings however in general is quite close to and was directly inspired by it both systems present their logic in great de tail and are concerned with the structure of proofs both also provide powerful mechanisms for proofs unlike treats forms of arguments including the ability to formalize the we expect to draw upon when we attempt extend is based on a constructive log ic all automatic rules are constructive though classical reasoning can be ex by making explicit classical as but on a unlike other systems based method in a quantifier free setting e g uses the full predicate calculus a full predicate calculus is fundamental tc our intention of providing a very expressive logic indeed soon we will permit full constructive second order predicate cal in the remainder of this paper we consider these led to the system and we briefly discuss what we have learned from using the system there being much more to learn the resulting logic is simple enough that it has been used by yet it is rich to permit the serious study of the problems of computational reason ing program verification and the design of programming languages the logic the form of proofs the logic can be viewed as an extension cf a natural deduction tion of the predicate calculus that in commands and that takes the con of an argument than a la as the central object to understand this viewpoint one must know how natural deduction style logics are organized for each logical operator there is a rule for introducing the operator into an argument and a rule for eliminating that operator are trees whose nodes are formulas the is the formula proved and the leaves are assumptions for example let and denote and or and im here is an informal proof of c ac bc assume c then is assumed and the ab c likewise and c establishing ac since if a immediately assumption and c that b deduce bc qed this argument would be formalized in logic as the natural deduction tree in figure lines and are the main assumption notice the assumption is replicated each time it is needed the application of an inference rule lines and are also assumptions line line arises by introducing assume al i assume a bc i i k c i i i i a c assume al bc i ab c b i c al bc a figure the operator into line line follows by using line to eliminate the implication operator from line l line introduces the rule justify ing line requires the in dotted lines which c from the as say the a and at assumption line all at line we has been in this tree structure is replaced by a linear representation of text the linear form is compact by eliminating occurrences of lines in of rules for accessing a line from a point in the proof the of tions and their intended order of tion is made apparent by block structure the version of this argument is in figure the proof is complete without the lines in the line numbers are also not part cf the proof the tree form has been replaced by a compact and readable tion the justification by intro that the operator will be introduced by the argument that follows much of the above proof is redundant and has been written out here for the sake of clarity by making use of abbreviations and automatic rules the lemma in figure can be proved as follows abc proof assume pl ab c by intro a c by intro proof assume a p a i b i from pi and p lo qed b c by intro proof assume b p a b l from pi and p qd qed figure ab u c ac proof ac by intro bc by intro qed i bc by intro here are two propositional ar ac by intro cases abc ab b a by intro intro intro the justification it by intro that the main connective of the assertion will be introduced in the second example is implicitly as by that assumption ab can be by a case analysis on al bc if a holds ly likewise if bc the automatic reasoning in clearly is discussed in section are parts have notice that these sample proofs similar tc their yet they are completely and been checked by a machine in an linear representation of a every previous line is available as an hypothesis in but in a block struc proof rules apply and it is an error to refer into proof blocks from outside them for example in the proof of the assertion c is made at line but this assertion is clearly not accessible as a conclusion at line other restrictions on are necessary because commands are allowed in arguments some of these are discussed in section automatic rules and proofs certain rules correspond to steps of reasoning that most people perform au in their heads in there are three classes cf automatic rules propositional rules equality rules and normalizing rules except for introduction i elimination tion and introduction all of the rules are automatic if all of the propositional rules were automatic the result would be a checker since the is complete a limited set of automatic rules was upon the algorithm used for checking propositional follows normal form theorem for natural deduction the automatic equality rules in the theory of equality with uninterpreted function s ym the used to decide this is due tc and nelson and and also and sethi the normalizing rules are the and of certain pre and arithmetic connective and simple arithmetic facts such as the equivalence cf ab and ab and cf not all cf the automatic rules may be used in a single proof step as discussed in unrestricted combinations of these rules leads to complete problems the use of for rules and are the main methods used to proofs a checker of both and tic is available with but we have not found its use necessary or even especially convenient it is our claim that propositional arguments which we understand well correspond to very short proofs furthermore any pro that we do not under stand well should be out as an aid to the reader and not inside a decision procedure rules for commands are introduced into ments and eliminated from them just as logical operations are thus for each command there is an introduction and rule for example the tion rule for the loop is the usual termination rule for loops the el rule corresponds to hoare s while rule here is a simplified no version of the combination of the introduction and el rule welldefined some n fixed no tn p do arbitrary n fixed where tn assume p statements t lo welldefined tn p end p the hypotheses of the introduction rule are lines and the variables of the body of the loop are related by t to a free variable that de by one on each iteration of the since the variables cannot be re to zero the loop must halt conclusion of the introduction rule is loop itself one introduces the p proving it terminates the the by the hypotheses of the elimination rule are lines and at lines and welldefined is an assertion which guarantees that will evaluate without error that is ar subscripts are within bounds and the arguments to each called function are within its domain line asserts that p the loop invariant holds before the loop execution begins line is an in hypothesis the induction step that p holds after the execution of the loop body must be proved at the conclusion is line how this rule is checked by the proof checker is discussed in section a short example divide division b q r algorithm declare a b fixed declare q r fixed assume ao bo readonly a a bo a by ra qo some i fixed s ri by intro r do o assume a ro arbitrary i fixed where ri ro by a u rb by rb i by ri bo bo r rb end rb by rb a rb return end divide figure as an example of ho w the rules are used in a program division mark algorithm example an is shown in figure it is shown exactly as it is input into the proof checker so that the same input may be used for both the compiler and the proof checker all of the proof statements are in special brackets other syntactic conventions which may not be immediately clear are that fixed is the attribute used to integral fixed values and some and all are used for the existential and universal quantifiers a longer example the procedure the of a one dimensional sorted array the mode of an array is an element occur ring most frequently we define this in terms of a basic function called which counts the number of occurrences of x in array a index l to index h ai is a of a if count is greater than or equal to count for any x where low and high are the and high bounds of the array a in order to the correctness lemmas involving of find mode we need count these lemmas four have been listed without proof just before the program the of these lemmas in turn require several facts count all cf these facts and lemmas have been proved but the proofs are not included here this example illustrates several features of proofs first and definitions the definition are used extensively for a fixed define for example says that is a property of di integer arrays defined by the formula or after the equality a second feature cf the example is that the find mode uses another program count in the proof text but not in the program text this feature is used extensively in the proofs of the lemmas not shown where various mathematical theorems are proved using and loops in the proof of the basic facts about count this of program rules in proofs is even more count is an iterative function essentially number o do i low to high if then number end but in the proof count is called and the recursive function used for the inductive proof is although readers not familiar with may have with some of the notation used in the logic such as for the name of the all elimination rule we hope this example will be informative process count procedure declare fixed assume lb h x x l ah ah b means true in o count rest of count omitted end count says that i belongs to the domain of the array a the domain of an array a is the interval from the low bound of i to the high bound of a i and are builtin functions for ai fixed define l a ii an array is for a fixed all if and only if identical elements define fixed where occur extending by one or extend count the interval counted leave it the same all fixed a u a i u a u over by one will increase where by proof i the count in a array if than l occurrences of ai up to i block upper all il fixed where by omitted then there are no ii l lo in a array if then there occurrences of ai in a up to i block lower all il fixed where by proof omitted are at least ll ll lo process find mode procedure a fixed readonly declare model fixed l is the length of mode block definitions the mode of an array is an element occurring as many times as any other element define low i define high for i fixed define mode all x fixed for i fixed define mode program specifications i assume mode declare i fixed i body of the argument in a array the length of a block of consecutive elements is the number of occurrences of that element to find the mode of a we find the longest block of consecutive as the basis basis step find the empty array the case s of our inductive to the case of the loop invariant holds l o initially there are no blocks low low count mode all x fixed a proof a low low qed by function low low by intro o by a low l loop invariant holds at low mode inductive case assume we have the mode up to then mode up to by looking for the longest using the loop the block do i low to high if then do end end prove loop executes at least once by loop do i u i to i the loop invariant is that the a up to i is in mode we find the mode up to ll assume by mode of is a consequence of prove il range by by lo o l if then do extend bound fixed count x a low i ll by intro proof al a low by mode a a low i a by extend count x a i a low i by al a qed bl b by extend by by ai ll is the mode is the length jp to of the mode block up to o ll by ol i ll low by mode ai l ll the invariant holds mode at f end else do no more than l occurrences of ai up to there are l occurrences of mode so ai not replace mode and l does not change does r extend bound all x by intro proof j by count by proof case count x by function by count case count by qed qed x ail cl c by c a a low i l from invariant a low i a low i extend count mode a i a l by low i l by cl c c the invariant holds at end end end loop find mode l low by o l low x mode the proof checker il local context checker above is a diagram of the proof checker the written by the user is processed by the local context checker the is responsible for checking all explicitly written tions of rules producing error messages when rules are applied most of the arithmetic reasoning in con of applications of a powerful rule called hence a large module of the is a checker of arithmetic the output of the is known as is essentially a of the proof containing only the portion dealing with and automatic rules it is checked by the inter to illustrate the interaction of the and the interpreter consider the following line from an pro gram ab cd by ac bd the checks that ab cd is consequence of ac and bd it the following indeed a then gen require require ac bd ab cd when the interpreter above instructions it checks to see previous instructions have guaranteed ac and bd and that ab cd the that that in the assertion table the primary data structure of the v code interpreter is the assertion table at at each point in the processing of the the at contains a collection s of all assertions which have been proved each instruction specifies kind of manipulation on the at the v instructions and the actions they specify are instruction p add p to s require p test to see that p is in s or is using au rules from the assertions in s if not print an error message new v create a new and replace variable v every open make a copy of s onto a stack it close restore the stack s from stack the and top pop cf the the instructions are net all implemented as described above but the implementation behaves as though they were generation the is very similar tc a com the difference being that net object code is produced as an exam ple of the type of processing performed here is a description cf the gen for the rule given in sec lines to translate to re line generates an open in with the corresponding close at line these instructions guarantee that assertions proved in the of the will not be used by statements after the which would be a of restrictions lines to translate into of t and p the statements at line are parsed and appropriate is ed these statements may be needed if the proof of line which is translated into a require involves rules at line the body of the loop is parsed and corresponding is generated lines to result in re claim and line results in a pro not mentioned above are the new in that are also generated a new instruction is generated by any statement that can change the value of a variable for example in the following intended proof if x then do x by x the assertion because x is on line set to is by the incorrect assignment statement at line line will cause x to be but the re x generated by line will fail because the new x generated by line will cause the of x in the assertion table to be changed into x in the rule a new tion for every variable that could be modified by the body of the loop must be inserted just before the open in generated by line the new instruction is needed to prevent tions about the state of variables before the execution of the loop from being referenced by proof statements in or after the body of the loop since those tions are by an execution of the body of the loop such references would be violations of res were it not for these new in and some problems with procedures and functions the could be interpreted as it is generated since the cannot be in until after the entire loop body has been seen has been as a system implemented has been implemented on an ibm using the operating system contains a large subset of pl in assignment if do until goto return select and leave statements arrays recursive functions and procedures and external variables the proof checker was written in and contains about lines for a typical proof the pro gram uses about k bytes of storage of which about look is data area programs are usually checked at a speed of about lines per second although on some examples it has run as as five lines per second some of this ness is due to the high overhead when using on the ibm conclusions benefits of a unified approach one advantage of the logic is that it presents reasoning about programs as a un i form extension of ordinary mathematical reasoning for example the approach reveals that the rules for pass ing parameters to procedures are simply special cases of substitution for free and bound variables the rule of substitution for free variables requires that a term t be free for the variable it is replacing thus in the existentially quantified for y y x the term z is free for y z is valid but the term y is not free for x because its meaning is in changes upon the formula substitution y y y that the quantifier has captured a y similarly an external consider a procedure global variable with assign declare y fixed declare x fixed external s assume y x y x yi return end assign the variable x is a bound variable bound by the assignment x u y thus the substitution causes an illegal capture which explains the sion x x from experience we have been using in number theory and the predicate calculus since april we have verified of small under lines examples and several size to lines examples since july we have been checking programming arguments as well including large examples over lines we have developed a substantial piece of algorithmic number theory including the fundamental theorem of arithmetic the formalization of elementary number theory and algorithmic number theory is direct and formal proofs are congruent to their in formal counterparts and only four to six times longer although we have discovered ways to significantly arguments by providing higher level rules such pro improvements are not necessary or for example cases of the following general frequently arise all x where all x where px px a general lines of rule but proof of this form would save per application would only be about we have also discovered common proof schemes that could be made into new rules just as the do i to n loop is a form of the do while loop but in elementary number theory these im are not necessary and we ex most of them to become special cases of a systematic extension of the system to reasoning e g to higher order predicate calculus and reasoning in contrast to number theory the current system is when it must deal with programs that extensively modify arrays while maintaining complex invariants about them the ty is that invariants about every part of the array must be whenever an y part of the array is modified in his thesis research scott johnson has discovered a much more array rule that the difficulties so far un covered we will incorporate the new ar rule in the next of the checker because unlike the other improve ments mentioned this one is essential to many ordinary programming problems experience with has ed the extent to which even the simplest arguments about programs rely on an of previously proved facts early work has required formalization of a large number of obvious lemmas we are learning a great deal about the problem cf providing appropriate mechanisms scope rules collections cf theorems etc for using the information from these theories by examining a large number of arguments we expect to discover which principles of reasoning wi be most use of the implemented system and attempts to formalize arguments are both essential in learning how to provide a more programming the current system is evidence that this discovery process succeeds is a improvement over is not only a complex research tool but it is also a valuable aid if we succeed to the same extent with non elementary arguments we will produce a valuable programming aid in such arguments we expect to learn a great deal from and which we can combine with our own unique experience we would like to the and of chan b and daniel r in implementing michael j is a principal designer of and the logic on which is based moreover he and chan are responsible for the elegant arithmetic package we also the advice by cartwright and references r s and moore j s ing theorems about lisp functions vol january cartwright robert s user defined data as an aid to lisp proceedings of international conference on programming ­ languages ­ edinburgh press edinburgh chan an algorithm for checking arithmetic technical report computer science dept cornell university r l and m j programming logic pp con way richard w a on using pl ie and pp con way richard d an introduction tc programming structured using and second mass ed i pg n g the mathematical language its usage and some of its extensions symposium on automatic in math ny vol lecture notes springerverlag dijkstra w a discipline of programming pg peter j and sethi variations on the common sion problem jacm to appear robert w assigning meaning to programs proceedings of in applied mathematics can hoare car an axiomatic basis for computer october programming comm acm hoare car and an axiomatic definition of the ming language pascal informatica acts r l london dc automatic program ve i a logical basis and is implementation act informatica kleene s c introduction to d van princeton pg kozen c complexity of finitely presented algebras ph thesis cornell computer science dept b the assertion table system for the program technical report comput er science dept cornell university david c program tion and verification oriented pro gramming information processing b ifip north holland manna computation p mathematical hill theory of new manna z and r j studies in automatic programming logic amsterdam john computer programs for checking mathematical proofs proceedings of in pure mathematics ms milner robin implementation and applications of log ic for computable functions ac m conference about programs on s co of proving new milner r f l morris and m a a logic for computable func tions with reflexive and polymorphic types report no department of computer science university of january nelson cg and d c a sim based on efficient decision algorithms conference record of the fifth annual acm on of programming language acm ny pratt r con on logic proceedings of th annual symposium on of computer science october d natural deduction schwartz j t technology computer science report institute of mathematical sciences new york university september scott data types as lattices siam journal computing constructive methods in program verification ieee transactions on software se e may richard w a users manual for fol report no computer science dept stanford university july pg 
axiomatic of languages a theoretical report by r meyer and y a precise definition is given of how or termination assertions serve to specify the of classes of program schemes assert ions involving only formulas of first order calculus are proved capable of specifying program scheme semantics and effective axiom systems for such assertions described such axiomatic specification we possible despite the limited expressive of predicate introduction the thesis that programming be defined by systems for proving properties in cj it hm been applied in practice to define ii fragment of pascal in hoare h x in nd further and applied in dijkstra schwartz nevertheless it is not clear in what precise art axiom system for proving assertions serves to de ii programming language moreover the of how serve as definitions his been in the literature in what follows we consider following and meyer vo kinds of xl it programs namely assertions nd assertions we on to offer a precise formulation of the property that an for deriving such assertions defines the semantics of a programming for the sake of ve he our be expressible in the natural formalism first predicate calculus with this is in to the treatment in and meyer predicates were purely settheoretic with no i ion to the existence or derivation of formulas them permission to make digital or hard copies of part or all of this work or are that copies to computing machinery to copy fee andor specific permission acm our result see sections is order correctness assertions are of specifying input of program general languages moreover here is an procedure for generating enough true partial his correctness to it open whether there is an of this effective procedure in terms of a reasonably axiom taking the abstract view a axiom system is in general nothing other then effective procedure for true or we that defining programming semantics by of effective axioms for first correctness assertions is indeed possible we found this result ill general first predicate calculus is to uniquely infinite mathematical for example nonstandard models of the r of integers which to the with respect to all properties using first ie they are but are nevertheless not isomorphic to the stand this might lead one to expect that assertions ing only first order would also be consistent nonstandard perhaps interpretations of semantics but this is in fact not the despite this po conclusion regard our study as just how is the thesis that or be given ic by of correctness the of the first order partial correctness assertions semantics suggests for example that there is no intuitive way to from axioms for partial to the n t its even though this is in fact under restrictions on formulas i slight of the of finite flowchart schemes the correctness true of a program scheme are not adequate to define t hc semantics of the scheme see especially section we consider termination assertions appear to be more tractable thm assertions from ii viewpoint for ve exhibit a complete system for first order about schemes ind show such assertions uniquely determine semantics results similar to our d i hc lemma were in for the of deterministic effective schemes in response to a by the first author partial equivalence correctness termination and first order logic a type or is a set of objects called each symbol k either a symbol or a predicate symbol and has an associated nonnegative integer a s consists of a type rs a domain d and an assignment to each function resp predicate symbol in rs cf a function resp predicate on d of the associated arity variables are simply treated as function symbols the type of formula f denoted tf is the set of function and predicate symbols appearing free in f a formula f of the first order predicate calculus equality is defined to be true or false in a state s such that s tf in the usual way we write iff is true in state s we write to indicate that f is ie true in all states we extend the class of first order follows as let r denote some binary relation on state let then a formula rf iff tf for fill t such that st c r also r i ii formula equivalent by definition to this is just notation for dynamic logic cf a relation r is rf is to i first order formula of predicate calculus with whenever f is such a formula cf pratt our results depend on the class of program we consider the richer the class the larger semantics to be specified and therefore our results take their strongest form when we allow more powerful program schemes than are reasonably realistic we consider four classes of schemes which listed order of generality are a are possibly infinite finite deterministic are regarded as a special case whose be arbitrary first order formulas and instructions consist of of the x term array of the more fx term and random assign of the form x the random assignment x means sc x to value in the domain cf b an scheme is if there is an effective procedure to the labels boxes of the vii weakening of recursively enumerable schemes are possible by array assignments etc c are enumerable schemes h open tests ie tests ing of quantifierfree formulas of predicate ith equality and simple assignments only ie no or array assignments cf friedman d a special case of effective schemes are i he familiar schemes with the following program simple assignment program else while open formula program od the type a of an arbitrary scheme a is the set of function find predicate symbols appearing in the instructions and tests of the scheme definition if a is an scheme then is the initial state final state relation defined by k ie ra stl t is i state which is a possible of performing a starting in state s let t st e ra when there can be no we will use a instead of ra eg we will say af of definition schemes a and b are equivalent iff ra ri that is they always take an to equal sets of final partial and termination a partial correctness resp consists of a of formulas fg and a program a and is written the assertion is iff f rg resp f r is a valid formula thus fa i is true iff whenever s f and state t is a possible result of performing a starting in state s t t satisfies g similarly is true iff whenever sf there exists a t such that st c ra and tg the correctness resp of a resp ta is fg i fg are first order of with equality and resp fa ct is true for any type r we let pc u fg tf c t and g c r we observe that lemma if a and b are equivalent and ta tb schemes then lemma pratt if a is a finite scheme then u is if a has only assignments and f is quantifierfree t is equivalent to a quantifierfree formula if ui i is a set of then denotes the scheme which is the union of the aj ie is equal to ur qi it is now easy to see that any recursively enumerable i is to a recursively enumerable union of and hence by lemma schemes that finite scheme uses only the instructions tests which appear in a moreover if a is enumerable we can effectively generate the schemes from an index for a axiomatic definitions of language the definitions of programming proposed in the literature consist of systems for deriving classes of program schemes involving calls with passing to other schemes in nearly all cases with a fin exception cf and the programs equivalent to arbitrary schemes of various types we interpret the claim that such an the programming language as that enough assertions provable to distinguish between programs by we cannot expect to make among equivalent programs using partial correctness or termination assertions more exactly ve offer the following definition let be a set of assertions and bc a set of then that for schemes a b e j there is an assertion in about one of a or b which k not true of the other that k let pc z fg i e then pc a u pc x let be the program which halts without and let a be the following program scheme if y x v z fx then else while y z do z y fy od y x z fx fi it is easy to see that am when it halts like it has no effect however under some interpretations a does not halt for if x y fz and is the successor function on the integers so nop and co have different meanings to be the set of all true partial correctness assertions and to be the set of all true partial correctness assertions then it is easy to show that see appendix a thus it follows that quantifierfree partial correctness assertions do define schemes on the other hand if we quantifiers we can distinguish a and indeed the of formulas x a y ft and ww fy is in pc l ao but not in pc as the may verify in fact theorem shows that defines the semantics of defining semantics by partial correctness assertions in this section we prove our main results partial correctness assertions we show in that despite the of first predicate calculus the set of true partial correctness assertions defines the semantics of recursively schemes in the we show for schemes we cm find a recursively enumerable set of i order correctness assertions which v ill the semantics for recursively enumerable schemes h c of finite type implies b and c are the proof of theorem on two the first is purely model theoretic and reveals in ii certain sense firstorder formulas are closed under recursively enumerable conjunctions this lemma discovered independently by the authors turns out to be refinement of a classical result of kleene see lemma let fo f be any recursively enumerable sequence of first order formulas of finite t pe r then one can effectively construct a first order formula g such that b if s is a state with infinite domain and s ali serve to distinguish the partial correctness theories and c the only difficulty comes from the fact that may not be equivalent to a first order formula of b ch by lemmas and c is equivalent to where each ci is hence ch is equivalent to taking fi to be ih which is first since ci is by lemma a we can effectively construct a first order g such that g ch then there is an expansion t s of s the restriction to type such that sg of s the of the proof is to introduce new and include in g axioms involving these new which define a possibly nonstandard copy of the of integers then we implicitly define a predicate t acts like a truth predicate and make sure the number of each fi t the proof is to b lemma if b and c are arbitrary schemes of finite type and such rb rc z then there is n first order formula h such that ch a bh is satisfiable suppose st e rb rc let xl xl f be the free variables and functions ment in b and c choose fresh variables and functions x xl f fin and define a state s in which x xn fl have the same respective values as they in s while x xn f fin have the same respective they do in t let h be the formula xi a a xn a z fz a a then s ch a bh as the reader may verify u proof of suppose b and c are without loss of generality we may assume r rc j by lemma we have a formula h and an s such s k ch a notice that this is to the t is false of course is true for c h the pair of predicates moreover if s t ch and s has an infinite lemma b says we can find an expansion of s to s such that s g then gh c if s has finite domain our task is even if t b u c then we can find a first order such that s ss iff s is isomorphic to si so iff s and s look same as far as b and c concerned then clearly we have ss c since s t e rb rc u remark the and of finite type in c u that b are both c be recursively necessary is we theorem the set of iii true correctness assertions which is not recursively enumerable even in the the of schemes in it is ii cf meyer pratt the question of whether some recursively enumerable set of correctness ions from an effective axiom system can semantics with a slight restriction on the of recursively enumerable schemes for to effective schemes will suffice we can give an answer theorem there is a recursively enumerable set of first order correctness assertions y which the semantics of effective schemes and a of while program schemes proof all the essential ideas of this proof already in the proof of theorem for any iii c and sentence h let ghc be the formula the of theorem such that where c is equivalent to and each ci is ch is always true y ghc ch i h is a first c is an effective then enumerable since the proof of lemma how to construct ghc effectively p is recursively shows from h ind c moreover defines the of effective schemes to see this suppose b and c are and st rj rc without loss of generality wc can s has an infinite domain otherwise s z s so that s has an infinite domain then there is a corresponding s t e rb rc the point here is that since b and c are effective they only tests and simple assignments so adding new i domain will not affect the value of the tests take the h from lemma such that s i ch a bh then the proof of theorem shows wc can extend theorem s to of recursive y enumerable schemes in to schemes with random and array as well m first order tests allowed a technical arises with the introduction of first order tests and random assignments namely we can no longer assume we did above that we can find an s with in domain such that s bh a ch the details are left to appendix d u theorem wc showed if h and c then ill the proof w the cj am h from lemmas and use of symbols such t f xl etc wi did not ii either b or c can we still a distinguishing partial correctness assertion if we ourselves to rb u tc h general the k ii r is the following theorem shows let bc a type with only finitely m ny function symbols of positive arity and predicate symbol infinitely many variable symbols and at least t vo function symbols of j then there enumerable schemes b c that b u c g and let f g fl fin pi p iw the function and predicate symbols of t with m n o fi is ij is for let us assume f g are unary functions let trivial xl x be the following where n max a a a xl a a x a xl a xl then let b and let c be defined as follows v v xx y else xl xx if xn then xl y xn y else x while x x do x od x y y fi fi the program scheme c nondeterministically checks to make sure that xl x xn y pl are all predicates fl are all projection on the first coordinate f and g are inverse functions and f has no loops ie z x for any x if any of these conditions are not met c acts like a if they arc all met c diverges hence kc g r but rc r since if we take s to be the integers with f successor and g predecessor and xl xn y o then ss c r rc finally it is not hard to show see appendix e that pc c h section we will take a more detailed look at the whole of symbols defining semantics by termination assertions termination assertions can also be used to define a class of program schemes and they are in a more powerful tool for doing so than partial correctness assertions as the following theorems show theorem the set of all true termination assertions the semantics of arbitrary schemes of finite type proof suppose b and c are of finite type without loss of generality suppose st rb kc by lemma b is equivalent to where each bi is hence must be b such that st e rb rc by lemma there is a in state s and a formula h such that s i a or equivalently s a remark the hypothesis of finite type is the programs b and c of appendix c demonstrate this as the example in showed the set of quantifierfree partial correctness assertions define the of the class of termination assertions will do the job true not but the set of all true quantifierfree termination assertions defines the semantics of the class of arbitrary schemes of finite type with quantifierfree tests md simple assignments ie no assignments or random assignments and defines the semantics of effective schemes and wl i le schemes proofi let x x be the of b u c as in theorem we can assume loss of generality uses only that we have st c rb rc since t o only xl x could been changed by b in going from s to t no functions could been changed since there are no assignments thus h from lemma can be simplified where h is to h xi xi a a xn x and we still have as in theorem c tb tc but by lemma is quantifierfree done u so vc arc a complete axiomatization termination assertions for firstorder consider the following deductive system for schemes axiom f x yf where f is the obtained from f ly uniformly renaming all bound occurrences of y in f find then replacing all occurrences of x in f by y ta f do a ta ta ta ta i f then u else b i f then b a e do a do a e of equivalent formulas fig whenever restricted rule of consequence the quantifierfree assert ions derivable from quantifierfree instances of the ax ion schemes ta are precisely the termination assertions true for that is the axioms ta are complete for quantifier free termination assertions proof the soundness of ta should we now prove completeness by induction structure of schemes be the a suppose is true then e so f a j f hence we have i i i since f a g f a ta b suppose fx is true then using b ta and ta we get c suppose is true since a and b effective they are respectively each i resp b is equivalent to since is wc have t by it follows that there exist finite sets i j such that thus is is also true assumption true and clearly so by the t ion ii nr q then using ta we get i d suppose f then a else b ii true then and must both bc true so by the induction assumption derivable from ta using and we get f then a b and f then a else b using ta we get v f then a b and hence since v e g using ta ve have f then a else b i e suppose f do u for formula of first order predicate calculus f denote the program is i le let if f then else while x x do oi fi tt t t f and f is in fact fg is equivalent to again we can i k equivalent to where ai is let be the wi of all finite sequences of natural numbers and for s sl sn e define as f al f os fa program scheme as is since f f are and aj is by hypothesis g by there is a finite set s c such that let denote the length of the sequence s re prove by induction on that af while f do a od h if si i then fh and i while f do a od h by ta if s s s n let s s s now a sh fl as h is true so by the rn induction assumption l ah a ah and by our induction on i sh f a od ii hence by ta and ta using the fact k we have t while f do a od h now using ta we get while f do a so by ta ta f do a · it is now immediate from theorem that the quantifierfree theorems of the axiom system ta define the semantics of schemes note that the proof of theorem through in the case of the full first order we get also language goes so the first order termination derivable from first order instances of the axiom ta are precisely the first order termination assertions true for schemes that is ta are complete for first order termination assertions remark theorem continues to hold if we the class of primitive instructions to include i lot h random and assignments and indeed any instruction with the strengthening of ta lb namely to now read for a primitive we may also allow first order in the note that by allowing random vc are dealing with a highly nondeterministic class of schemes which illustrates the point that completeness of the axiom system does not depend on the property of determinism u the role of extra symbols although showed that it is possible to distinguish recursively by correctness assertions theorem showed that in one must use symbols that in neither scheme in order to do so in this investigate the role of extra symbols more carefully both in correctness and termination assertions basically we observe that no extra symbols not even extra variable symbols are needed as as first order tests and random assignments do not in programs theorem two further of interest are given random assignments or first order tests extra of arity necessary es t ra do not so theorem finally if array assignments are then termination not require extra symbols aside from variables in contrast correctness assertions we will say r is a rich similarity type if it contains at least one function or predicate of arity or at least two unary function symbols the type r is a weak of t if t u a finite number of variable symbols t has if it has at least more symbol than the maximum arity of the function and predicate symbols in it our major result is a positive one for effective schemes a b even allowing array assignments as primitives if a u tb t k sufficiently rich then pc c pc h and ta t that is we do not need extra in order for either partial correctness assertions or termination assertions to distinguish programs outline of proof we show that under our hypotheses we replace the g and h of lemmas and by new formulas say g and h that perform the same function without using extra symbols this g and h instead of g and h in the proofs of and we get our desired result replacing the extra symbols in g and h is carried out as follows it is easy to show that we can replace all the extra symbols occurring in g and by one predictive symbol of sufficiently arity since is sufficiently rich assume without loss of generality that it a binary predicate symbol say r then using r it is possible to write a first order formula which implies the existence of new elements which are not the values of terms of type the formula asserts the by r between these new elements and the old ones serves to encode the large arity predicate on the old values this idea then to the following of refinement lemma let fo f be any enumerable sequence of open of finite t j m t then one can effectively construct a first order g such that b g and c if s is a state with domain and s then there is an expansion such that sg infinite s of sl the details of the proof are omitted u lemma may be of independent since it implies that the theory of any enumerable set of quantifierfree of finite type is finitely the finite in must have additional quantifiers but are of the finite type is the set of cf note as we noted theorem shows if we allow either assignment or first order theorem in fhe case of assertions in for schemes using random or first order tests it is the case that extra symbols of arity are required for termination assertions w well as partial correctness assertions as the strengthening of theorem shows for any finite r variables and at one function symbol of positive arity there exist schemes a b such that a u rb t and for any extension of t pc ii nd tb of the construction is an of the constructions used in theorem and appendix f we can assume without loss of generality that we have a unary function symbol f in we a flowchart which generates and for some chosen integers m z n then using array assignments switches the values of terms using random assignments as in i he proof of theorem we also define a finite which diverges on states in which every and every function besides f is trivial and like otherwise then let a be u nop and b be u again we omit the remainder of the proof o if array assignments are cd then termination assertions without any extra aside from variables can distinguish even arbitrary with random etc theorem suppose a b are arbitrary schemes without array assignments then we can find a weak extension t of a u b such ta z tb except that the proof is just that of theorem since might now have assignments is not general quantifierfree note that x f is equivalent to xf u note that the proof of theorem shows that partial correctness assertions do not share the of termination assertions given in theorem provides instance the somewhat theoretical properties of termination as opposed to par correctness assertions conclusion we have given a technical formulation of t hc thesis that languages can be assertions we led this thesis in detail in the context of first order assertions about program schemes and in t there is an system for effectively deriving enough assertions to define the behavior of any effective scheme we interpret the technical of the proofs of these positive results for the of correctness assertions is that specification by such is likely to be ill assertions somewhat in that the proofs are straightforward and these ions have a simple complete for i lc another significant advantage of in contrast to partial correctness assertions former can be viewed as a kind of termination is the operational specification with the proof of a termination ion about a corresponding to steps in a comput at ion of the program we shall not elaborate on this observation here but wc expect this would a specification using termination assertions much useful to programming language it be interesting to examine extensions of the termination axioms to more realistic kinds of program schemes the property of completeness plays a smaller in this paper than in many others on proving assert ions about the reason is simple the property of completeness of an axiom system and the property of its yielding enough assertions to define semantics arc as we noted just before stating no effective axiom system for correctness assertions even about is possible yet a recursively enumerable set of such assertions does define semantics there are eg using open formulas where the complete set of true assertions about some of programs does not semantics some comments our use of first predicate calculus must be made here a to our concern about the technical arising from predicate calculus is that one could choose instead some richer logical such s second order predicate calculus or first order augmented with the uninterpreted function and in programs for these richer languages the it is easy to show t partial correctness andor termination formulas from these languages define put semantics indeed these richer logical are the ones implicitly used in most of the literature on axiomatic definitions of programming languages but on richer logical languages one x high price in terms of effective proof procedures of weak second order predicate calculus and first order arithmetic augmented with function symbols are of quite high degree of h since one of the central of axiomatic programming language definitions is to i he generation of proofs about programs it is obviously important to constructive proof properties such is those of predicate calculus further we observe that with minor exceptions the use of arithmetic formulas in the literature on axiomatic programming languages arises only in the specification of arithmetic primitive operations in programs above the level of primitive operations for example in the specifications of sequencing constructs or subroutine calls the arithmetic properties of the primitives are not used thus the specifications fit wit the framework of predicate calculus and uninterpreted flowchart schemes considered above a f to appear notes inputoutput semantics do not reflect the full operational behavior of programs eg information about looping or failing is lost but dealing with such extended semantics and the kind of assertions proposed by capable of defining this extended semantics is technically more complicated and does not appear to raise any new issues about the of definitions of programs in the terminology of and determines the standard relational semantics of c i result for pure first order calculus without equality was formulated in terms of finite namely the theory of any recursively enumerable set of axioms of finite type equals the theory restricted to the same finite type of some finite set of axioms in general however the finite set of axioms must involve extra symbols immediately implies since without equality a first order formula is iff it is satisfiable in an infinite domain conversely proof of his result is quite similar to the independent proof given in appendix b given wo t t with t g t s a structure type s a structure of type then s is an s if doms and s s of of i it is not too difficult to show that the set of ail true termination assertions defines the semantics of deterministic schemes even those of type if we array assignments we can even handle the case where is not sufficiently rich but t we must use a weak extension of in order to achieve the desired references apt k r j a l g l t recursive assertions are not enough cr are theoretical science pp j a j and j v correctness theories and program equivalence im cook s a soundness and completeness of an axiom system for program verification on vol no february dijkstra e w and formal guarded derivation comm of the acm vol no of dijkstra e w discipline prenticehall of program ming r w assigning meaning to in of er science c of symposium in applied cd j t z pp math society island r friedman h algorithmic procedures turing algorithms and elementary recursion theory in logic cd r o and c kl e pp holland amsterdam i and a r meyer specifying semantics of laboratory computer science tm m i t cambridge april the for d logics of programs axiomatic nd power m i t laboratory for science tr cambridge mass d a r meyer and v r and completeness in logics of proceedings of a cm on theory of computing hoare c a r complementary formal programming languages and p consistent and theories of the semantics of pp hoare c a r and n definition of the programming language pp an axiomatic pascal t il v and p he expressive power of logic in the ic of programming languages amsterdam may kleene s c two papers on calculus of he ai i pp math society island london l program verification in directions in software technology ed cr pp press cambridge lm m p an introduction to he theory of north lq pratt v r considerations of logic annual ieee or he of science pp schwartz r an axiomatic algol university of california at semantic de of i 
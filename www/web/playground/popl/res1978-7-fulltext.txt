conference record of the fifth annual acm symposium on principles of programming languages automatic a general scheme for the inference of variable extended abstract by jeffrey princeton a kaplan d unman university se present for te known or runtime thm types ln programming language requiring demonstrate no type it s to published algorithms and that it is the best possible algorithm among all that use same set o in we a model of computation that is an abstraction o programming languages s apl and based on this model we present a general scheme tne types o the variables in a given program ur type system is more than tne op jones and lj and t in ii w a model or tne treatment type in a op relationships that enables us to types is discussed in then iv gives a we believe is best without new concepts o tp the v our view by how lo tne best of primitive result a given set operators and starting tions in vi show that our solution is at least as good as other pro methods and vii is an example that our solution can be better than other known work partially supported by nsf grant ii a model of computation language in a programming the basic gramming language is ment statement whose q block of the parallel most general our pro assign form is x xx xk yy d i e k f are variable names e are operators k dd dk and y s are jm variable names cf to simple assignment x is included writing it as where s operator may be o is they may no arguments and yield constant values the is that are bound to associated wit values members or a universe values v operator aj with degree dj corresponds a function d v names to now statement ables y jm assignment executed meaning of an assignment should be clear let tne de bound to values jm j is q s xl xk become bound to j v kl k any tne values w j o a lt may have been to d all other pro gram i jm values a is a whose nodes is labeled an statement by an instance subject to the there s a node we tne si node is reachable the sf node tne s node is reachable every tie j node is labeled bv an ment statement in every appears on the ef and no appear on tne side the program sr node and ends at the does not any s node s a sf path at but correspondence language of the model to real programming tbe corresponds to all tne sf node tion corresponds if we like to program we may the existence value v and constant u yields value then a program ts sk node labeled wit lz p p j can tne and output statements a real operators state ments can be modeled real language as j d l new db i xv we only te that p s evaluated in a either may p s evaluated outcome here may o ps execution n tne model o a real program which are not execution in the real pro but it is true that every possible real path is through tne model program statement holds true o a model program a possible path any for all p must also hold for program every execution or d models if we take the any reasonable set of computable for executions so our is not or the set of paths is a reasonable approach and to the usually made in code a g h la ki sc assume that all programs that we analyze that are correct n the sense of every will be or all input values occur any execution and all executions reach the sf a finite number o statements lll ri type determination a compiler could range op values that variables may take on ing tne execution a it could tne to produce simpler more code to carry out the operations by the program for example te statement jk ln te text o an apl program and tne compiler could that bot j and k would always be bound to scalar values for every statement compiler could code would use a simple machine instruction to add the values or j and k rather than a generalized addition routine and could allocate a word for i in which to place the result than to tne storage the generalized would allocate f a global check showed never takes or scalar on any other than tbe compiler could allocate i at compile time assuming no recursive uses b that a simple type determination can result tn substantial more generally we would to partition universe or computable values v into for tne purposes of this paper a s any subset o v instance types may correspond storage representations to of re st a data structure capable op storing any value in the universe v de it ls for one type to contain values are also contained in another type it is also possible to incorporate tne constant propagation problem into our scheme by having string types abc such as constant and so on constant in general the decide on tbe set types to consider here we shall assumptions that writer t he is only make the set of types we shall by t forms a ne meet greatest lower bound os two elements st t is denoted by st the join least denoted upper bound o s by a partial and t ordering s on t is by tne rule yx w xy e shall for but w not ne there exists a ast element q and a element o s j such or all st the partial interpreted as saying a program bound to a value o type cse than merely to a value type t should iq st variable s is more that x s be then x is a symbol or represents an element of t will usually appear by brackets t s important the reader o as a subset or v as well as a member of t this in we that the lattice join and meet are related to set and intersection as and be as ol ws it program variable x is bound to a value o type t or a value o type s then t is bound to a value of type must the set on the other hand we know that x is bound to a value whose type s by t and s then x is type is tne set bound to a must finite chain condition all sequences or elements t are of length related note by tn that this is not bounded so strong a condition as all have by some constant chain does the that t is a complete lattice t an to its j lattice may theory and be found n a lattice ls if elements has both a least a greatest lower bound every upper chan bound o and to sj that these are reasonable lattice of let us consider may be how such constructed a first we some subsets of v such above as the example types mentioned may also include some alter such as or tial or types in this a natural tial ordering of subsets cs given by tne subset to tbe of and least types w add v and the empty set to our collection or types next we must extend our col subsets so that for pair s and t or v that appear ln our tion also a unique largest subset that the o s and t and a smallest sub set that contains union o s and t tne o a greatest lower bound and a last bound or each par ln our collection our tion is now a lattice and or our satisfy assumption if we were then in in we should all als p he started only many basic subsets our to a complete wi also be finite way to about the con o a lattice o types t is to view the process as th tion or a o powerset c v that is a lattice assumptions and l gives a very detailed example o such a lattice of types or the program ming ur goal is to automatically tile type of values each variable may bs bound to at in program s will aid compiler in deciding what code to generate or each statement tie begin the task by the operators our language suppose we know that at some point in a program x is bound to a value of type t or how the expres x x xk tie like to about ts cons vk includes all type e names a function set ti of tne values may have let s be an element o t clear that the value s r then it s oe xl x xk must be of type s or ac operator e we may a function t such that is te least type s such that s rk and d aq as ie constructed a te operator e so we now construct tional operator operator struct functions as or a monotonic m k is the each jl function or of k con kl t tt tk zs tne least element st i ls and that vk de may prove each t co be of proof s and is similar to de tne our type as being tne con more precise tne we have concerning tne type oe an operators inputs the more precise we can be n a statement about me operators output de have considered tne case where the op an operators inputs are known and tie seen how we can a valid assertion about the operators prior now suppose we have some a concerning the type of an operators result and types or some of inputs we may be able to on by m to deduce more about a particular input for example the apl statement ab that a will suppose be an integer w have after the statement has been executed then by the nature or the operator it must be is bound to an i te operator tt fk is applied ls a order by x xk value partial yl yk ae and only xy or ik where d ten is the k and xv is the element such and l t the con then so does tr single we would assignment like to can be made statement by q such what a as the in tion is among data problems in that information may b propagated and backward let t be a map rem the set z program variables to the elements o t about the types of the values to the programs ables d is to construct t and q a new qt what we know about the of program variables te assigned statement to the q is executed ln o our constructing or the d e operators and se the of tne assignment or variable to de z c z we lz i t l does not occur in statement occurs in side lhe m o d of yet expect monotonic that to lt construct t j al t not always these best in such cases be type any approximate the i for all tj may be used in tne de say g x rl domain o f p such that zy mj otherwise m let t be a map rem the set program variables z to elements of t knowledge about tbe types values to programs variables statement d s executed de to construct a new map but which will describe what we can deduce about what the types the values o tne program variables statement q was executed de again make use of were in our knowledge of operators and assignment statement the semantics of the tz if z does not occur in statement f l occurs side d only on let a t i all pairs such that ty m zy mj m otherwise where tw if w appears side of otherwise on q the left notice both t and can be regarded as functions o statement d and q functions that map t tor a fixed b are q into of since monotonic they are functions just and y denotes the set of all the set z to tne lattice t note that is a lattice if rq e zt we for all further i z s a set elements then is isomorphic to t the holds for zt whenever it holds for t language n nodes n consider a p in our consisting o a graph op for convenience let the s and tne other nodes let te l zj program at any be z ln te values the mapping values we may variables by t of z p or the types or be a to each the types each t tz tne of a of v is possibly to z during any program that ip s mappings x it is describes easy to z then or see all s f safely describe z better than t is safe and ts a mapping t is a mapping for forward each and from node j zt o p we to for example node q construct functions as out by construction we have i describes the types of th values to the program variables node j is executed types or tne values node to the program j has been if the types of the values after node j has executed then the were assigned before node j types o the to the program was executed values our type problem in tne notation we have developed above our problem s to xn z to t so that for gram x and or all j p and or all executions times in or our pro a given tion o p at control node j safely j on to node j program de call such a set a sg to the type ing or of types program t lt p under the will be con to write a proposed solution as one vector x xl x x n and v are monotonic arguments ng that way and two ir and x s j code values p we then can our to which the very compiler can its only types of might arise during an actual ke know how to make type when through the nodes in te that our how the variables c and j b j of our program on new types as each statement use con n the flow graph d we now e and ij character forward respectively and backward q type propagation information the program j s from to x xn v j node j at described tn values given the dy vector tne variables types tne fl into j x xl at cl we by x v where j i mj is an in the ow graph o p tp then m ym expresses what can be about the types o the values of the node m the o at tne successors or node m variables variables at we can dx in notation as dx fb m ip d mj tions of monotonic f is an edge o p and b are each f and b related type two show b used to demonstrate a proposed solution two but systems the ol how or b of let vectors such x en x ls x and s in and let be s be safe proof e path length i s carried out by on a and for all so matrix is the inner o and an to scalar lattice scalar or an from to of in and corresponding to a similar lemma holds or b where safe let s is x be such then x is the proof lemma is similar to that o fortunately the two lem not only give a means of solution but of testing they also tbe a way to shall demonstrate forward type of tne compute a sa the case of propagation system f may also b carried de the all out in the el system assume we have a safe solution and we hope to x the act x sx is any sa a better x suggests we look namely that or te smallest we smallest considering s as r s by notice fs is a monotonic because a and f are monotonic be least x x define now let oe fs that such is v is tne least that v of by lemma v is provably notice p implies s the that fg fq tie can v write v explicitly il as oj many steps as long as the lattice considering tne function s as the t no by de summarize what appears by the acts lemma expresses about the some a t is xx b f is decreasing monotonic ie or all c lc for all x px a or d for all x and all ko x is a b let xx xy x claim assume along with tne monotonicity or f us d our the monotonicity b s that xy of a so by bl which c completes tne let tie can y for all i and and c fq fo for all i as in part b we proceed by induction on at cl and c true now assume te induction or cl that and the of fx imply that f but since y ls a of r x completes we the step for cl to prove c and assume apply the iv induction to get but y is a fixedpoint of we also x so we can write have c rj combining tne act f is cl we see by the means we can sub or in c and get completes tne that cj implies that notice ii type to it fs a consequence o lemma ls that any safe s we can apply to get a possibly solution but no or can any over fs ence of course all of tne above or te backwards system tie can construct a tion from a by bs b sx and we can state lemmas and by just substituting symbol ln place everywhere appears in lemmas j and s s we can a better solution ls the t the fact a s cannot be improved further applications f or i does that t may not be improved of or s easy to demonstrate programs given by not by an it ts gives a better than either safe safe ds solution we can or xs s eg j compute given which an s always ir s in next we some results about ions on lattices that show sense an optimal solution problem present is xn some to tne type v given set hn o monotone lll e members map a complete lattice l into ev ls meet and c and join functions given a set l we would like to study the set or which can b computed by arbitrary o te functions or ll v to points op a just what we mean by computed and arbitrary wl clear as we proceed in our investigation our motivation or the points s as in s represents a safe solution to te type and each of in il and m preserve safety every in w also represent a sas shall use the tie develop to prove tie f a functions that fs can ind v and an initial ls the best operators safe o s tie shall end or paper such a program at tne since each point n is be computable in many tions should how to or each point c in be some e expresses compute c rem sets d y and s so sa of look tile problem at a we class defined by p ue where the and the by the rules are which intuitively expressions jk s are the are values vectors in l of l and the l j to lk variable variable introduction name then if x is in x is a k application and closure k k both if kk lg if then and and least iterated lower bound upper bound application and z or lub o an or g k to ek b abstraction if k ek and are variable k e function introduction the name or g a function if from g s our is may be interpreted we interpret in a formula as that formula k in l as an element k of l e each free variable an l the jk in may each be interpreted as mapping k lj to l since we are only given functions tn h and pi and tne to start with let tne tn us set of how to stands or the set o e such that e is a in tne set q f x ig a free variable name n e s sm ie x names an element r g s a of s and name ln e then element of n an element of or iq and and g names to a formula we first a maps variable names ss m lattice points or s and maps names and av and m lo tne corresponding functions of we extend to a function is by h lx ix i x is a variable i i tion given is tne by rt tt tj ek where is of an j that is by ie the variable for some i some other or function yi variable name note circular i s not since of ek abstraction fewer than lg name ig if g is a function rules rules should that built the correspondence between these for interpreting formulas and tne given above or building formula be obvious we are just a is interpreted by each of the parts of it was in the case rules and existence it of upper bounds tion that i is be noted that the greatest lower and least is guaranteed by our a lattice and so is each lk thus i maps each formula in the set into a member o i il u jk u because under of rules that and is products closed and closures it is also true that tne pro functions since rule gi allows us to j there write and also o the that i formulas j and and xi is a for lk in u whose interpretation is just g thus tion composition is closed the reader should now be that the set of all points and functions which can be computed rem h m and s by arbitrary composition and two points should b made here first we have introduced the tion construction leads to closure under ini te cartesian products to capture the notion that during a tation may separately compute and store several values which may be later by a further computation second we introduced of function closure two forms to capture the notion function we may arbitrarily apply many a particular times in a fashion results in a only meet minimum or maximum that if meet or or join value underlying join respectively a l tne condition closure can be then com gate all and de would now the properties result says in everything ke to of our speaking that are monotonic in depends m and s on te values n tne sets d domain of an or the single symbol in is tne set names for the elements o h m and s we shall say that fs an for tne symbol or in i the same domain ments as but maps the of s possibly names os values zn l maps names of h into possibly monotonic in lll and maps te names o elements of i into possibly different monotonic in a par tal tions only ordering s i or on defined all e by in t domain i of and we can state let interpretations or ms in and the i be such symbol or that or all or all function ig is a the proof s a induction number on tne structural o applications rules gi and d in the construction of the e for a that e and e ar it is easy we say p to see that equivalence tile is classes by ts relation set of these equivalence into and classes s isomorphic to ° in n the text that convenient members to of tive formulas understood to be since has at least one for represents t we shall find lt the and between all will be interpreted by i unless otherwise that is a natural par tial ordering on elements of or ie and only ip ccl k or some k and or and our result minimal and maximal ments o st and can represented formulas ele be first define or notational convenience we ak v d yy y join s vector of s s s u z s kx x xx x j where where to next theorem we p first notice si or because s also notice h is it is in and that by construction is ie for all x so i ul since l s assumed chain all are continuous li a tc satisfy monotonic and tne for all x dk h ms similar ment shows the result k for b we can state b let jk c s c s for some proof since each has a representative we can carry out a proof by induction on the structure of these formulas tne case te be an ment each tne rules and de only for the sake of brevity te argument for rule after this the manner in which the rest of the proof could be car out will obvious c can be written as ge where g and e smaller minimal and both formulas g and e have than does c by the induction hence by hypothesis e s th monotonicity o ge the hypothesis also guarantees that g so equals similar by the argument preceding shows lemma a that c ii now solution let us apply theorem or iv let to the and s s for some safe tion se where zi is the set graph of variables o an de can now show ow the best safe over the lattice is in rs proof by the previous we know that theorem the smallest ele ment in notice that because bx is monotonic or is qs but is decreasing and any x we have x u xx sim is is fx with x s moreover because decreasing xx and because decreasing and is monotonic x combining these acts a little lattice we get t is a decreasing no confusion result from writing as a similar remark or q t and b observe expressible sense that that in unless terms q is s or n not n s the directly g in the or t is ks is not in a similar statement applies to because o is gen not a safe we do not wish to q into s to explore tne of those or and we shall a new class of com objects is much like except in ng the set o underlying and their interpretations we add rule ev and its interpreting rule ev least fixedpoint lj formation jk variables no free y yk occurrences then yl el and n names a let in ii p yk note that f is a member o z k where represents the least k q element of l k z io which is the least o te ix w are very n tne form qf f tn rule iv do not want to i in tne a in h to argument jk or g is one way to safety ln tne presence a least operator it s not the only way formally we let i be set o all can be built by recursively g i be the natural gi and or the names and and let tne elements f be of of i given by rules and we define le a s w did discussing elements o we usually denote tne members of by representative understood to be interpreted by i in c s not that e s and can be written as d ks which ls ln a form by rules g and g for any s since there are no similar variables tn the can be for if to and are in s te lemma expresses the all in are monotonic and that all objects n depend on j let and i be alternative or tne single symbol or in for all that i then for all that g is in a given by either rule gi or lg is a monotonic the proof s essentially as oe u an is thus we dart consequence of lemma and are monotonic have an alternative way of a fact e stated as lemma tie shall where now show that tn sis the case sm lattice l and f lll then has minimal elements will still as usual ail i b and are uniformly or i and just we as w defined and is meaning clear vector the and context makes our also s stands for a m elements of s t xj where corresponding to lemma we for all jk he proof is much like lemma the key being that of that ls decreasing and and acts b and c of lemma that by parts a a let a a for some k then b let a then a f tn proof that new argument corresponding ev we must to that f present a new assume representative where a k of the form p has qk a t are tv each of a by and jk i ej by rule hypothesis u y functions yk belonging to are all f ms where y yl yk tie hand side to ok o t e can easily where be to s we claim ok or all o s for the claim ty the f shown by s hypothesis true and the on i w and yield te right hand side to uk of may be which is seen to a step o b by twice invoking this completes part d o the so we a i theorem says that given some best solution tn af v s s or other words typ f computing is an optimal way to use f to improve a safe solution s the reader similar remarks we can made about other researchers proposed alternative methods or computing lem these solutions to in section n the we express w have above de prove the indicate that our better solutions jones and j construct sys our of equations and notation corresponds very which correspond to for types in their system closely y by and xf yx system is just for this or set solving the backward system its maximal into system and the minimal that is they and l lj y our s somewhat n that we can incorporate additional information solution s which be derived from user provided might declarations by a given for example in paper suggest the possibility and op also b as than us ing the join xe proposed ln l de do not this o algorithm as pointed out in lj it can lead to determination or types under strict assumptions about program behavior tne program also notice that which s jones and so our as of lj safe ls at as l is to compute ln two a an y to lower case i y is a character string returns tne sum x and y ip x and y numbers returns o x and y both x and y ae is and to our types o types we ig set the set and extend to a lattice hy of integers o all character t which s shown by ij are op n o r real real q o o int nt c g q o c o q i f real al int i t q int in ra l o o int q q qo oo o o also yy for ali y y and x y u or pro forward are given t or statements by u and the subscripts a and b reference te com of a vector t variables a and d tne matrix c the tion s q g l backward t are j ui td l ta he o tne s backward o bl d g b b b q o can now compute so we the fl better our proposed than jones and example solution fl s solution or on la a v o prenticehall j and j unman vol h no lb a and d j ss apl need runtime checking ad vol pp y lo t la press per graham s l and l a cast and usually algorithm or global ow jacm vol no january b pp j b and j unman data frameworks vol january pp g a a unified approach to global program of am qn pp tie can also compute muchnick the language was developed operators points out for or which tne lj algorithm constraints on tne guarantee that is tne same as fd s scott l s unpublished lecture centre amsterdam see also a paper same in or computing vol io september b pp j a qc institute of mathematical new york university 